# 整数类型
我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.

我们先从第一个整数类型开始看.

如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.

但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.

## 定义整数变量
定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 `int1 = 95`, 或者是使用内置函数 `int()`, 如果不给 `int()` 提供任何参数, 则返回数字 0

# 整数运算
既然是数字类型, 那就一定要支持数学运算符.

地板除 就是取结果的 商 部分.

这里需要重点说一下除法运算符`/`, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的`商`, 而在 Python3 中, 所有的除法都会被转换成浮点数.

通过引入 `division[də'vɪʒən]`, 自动使用浮点数运算 `from __future__ import division`

## Python2 中的 long 整型
`sys.maxsize == 2 ** 63 - 1`, 说明 int 是 64 位的, 之所以 `** 63` 是因为头一位是作为符号位的, 所以不计算在内.  
`2 ** 63 - 1` 返回的值是 `9223372036854775807L` 后面追加了 `L` 说明是 long 类型的, 但是 `int` 类型的最大值明明是这个, 为什么这里会转成 `long` 类型呢? 这是因为当我们计算 `2 ** 63` 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 `long` 类型.  
`type(9223372036854775807)` 和 `type(9223372036854775808)` 分别为 `int` 型 和 `long` 型

# 整数的本质

跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.    
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.  
首先用 `dir(int)` 列出整数类型有哪些方法.

    @@@ python
    a = -5
    a.__abs__() # 绝对值
    a.__add__(3) # 加

使用内置函数 help 可以帮我们查看这些帮助信息: `help(int)`

数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 `val1 = 15`, 当我们为 val1 重新赋值 `val1 = 16`时, `val1` 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: `const int * a;`) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.

# 整型的进制
二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为  
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理  
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.

# 位运算
每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:

- `1` 执行全新啊
- `2` 写权限
- `4` 读权限

这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.

在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?  
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.


# bool 类型

`int((True)`, `int((False)`

`val1` 和 `val2` 可以是任何对象, 一个变量, 一个函数或者一个类

# 比较关系运算符
返回 bool 类型的值

`is` 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 `id()` 来获取一个对象的 ID.

# 浮点数的本质
我们都知道, 在计算机中, 小数都是不准确的, 都是用近似值表示的. 要理解为什么小数会不准确, 我们首先要知道, 无论是什么类型, 在计算机里都是用 `0` 跟 `1` 来表示的, 整数的表示很简单, 如果是带符号整数, 最高以为表示符号位, 因为计算机只能表示 0 和 1 2个数字, 所以底数是2, 指数就是位的位置. 此时每位代表的数值就是2的n次幂, 范围就是 `-128~127`, 如果是无符号, 范围就是 `0~255`.

浮点数都是以指数的形式存储的.

定点数: 小数点固定的位于实数所有数字中间的某个位置

指数位同样有正负, 就是十进制一样, 可以乘以 10 的3次幂, 也可以乘以 10 的-3次幂.  
第一位作为符号位 , 除去第一位的指数符号位, 剩余10为用来表示指数大小, 范围为 -2**10 ~ +2**10 - 1

# match 库
Python 还提供了强大的数学库, 里面提供了可用于各种数学计算公式的函数.

| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |