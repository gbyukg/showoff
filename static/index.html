<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Python Training</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>

  
  <link rel="icon" href="../_images/clientdb.ico"/>
  

  <link rel="stylesheet" type="text/css" href=".//css/highlight/solarized_dark.css"  />
  <link rel="stylesheet" type="text/css" href=".//css/mermaid-6.0.0.css" />
  <link rel="stylesheet" type="text/css" href=".//css/font-awesome-4.4.0/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href=".//css/introjs-2.5.local.css">
  <link rel="stylesheet" type="text/css" href=".//css/jquery-ui-1.12.1.css">
  <link rel="stylesheet" type="text/css" href=".//css/showoff.css?v=0.19.0" />
  <link rel="stylesheet" type="text/css" href=".//css/zoomline-0.0.1.css">

  <script type="text/javascript" src=".//js/jquery-2.1.4.min.js"></script>
  <script type="text/javascript" src=".//js/jquery-ui-1.12.1.js"></script>

  <script type="text/javascript" src=".//js/jquery.cycle.all-2.8.0.js"></script>
  <script type="text/javascript" src=".//js/jquery.batchImageLoad-1.0.0.js"></script>
  <script type="text/javascript" src=".//js/jquery.parsequery.min-6a20f83.js"></script>
  <script type="text/javascript" src=".//js/jquery.doubletap-4ff02c5.js"></script>
  <script type="text/javascript" src=".//js/highlight.pack-9.2.0.js"></script>
  <script type="text/javascript" src=".//js/jTypeWriter-1.1.js"></script>
  <script type="text/javascript" src=".//js/bigtext-0.1.8.js"></script>
  <script type="text/javascript" src=".//js/zoomline-0.0.1.js"></script>
  <script type="text/javascript" src=".//js/simpleStrings-0.0.1.js"></script>
  <script type="text/javascript" src=".//js/mermaid-6.0.0-min.js"></script>

  <!-- waiting on https://github.com/usablica/intro.js/pull/727 -->
  <script type="text/javascript" src=".//js/intro-2.5.local.js"></script>

  <script type="text/javascript" src=".//js/coffee-script-1.1.3-pre.js"></script>

  <script type="text/javascript" src=".//js/annotations.js?v=0.19.0"></script>
  <script type="text/javascript" src=".//js/showoff.js?v=0.19.0"></script>

  
    <link rel="stylesheet" href=".//file/cusStyles.css" type="text/css"/>
  

  

  <script type="text/javascript">
    $(function(){
      setupPreso(false, './');
    });

    editUrl     = "";
    interactive = false;
    master      = false;

    keymap               = {
  "space": "NEXT",
  "d": "DEBUG",
  "up": "PREV",
  "left": "PREV",
  "pageup": "PREV",
  "down": "NEXT",
  "right": "NEXT",
  "pagedown": "NEXT",
  "R": "RELOAD",
  "r": "REFRESH",
  "c": "CONTENTS",
  "t": "CONTENTS",
  "h": "HELP",
  "/": "HELP",
  "?": "HELP",
  "b": "BLANK",
  ".": "BLANK",
  "F": "FOOTER",
  "f": "FOLLOW",
  "n": "NOTES",
  "esc": "CLEAR",
  "p": "PAUSE",
  "P": "PRESHOW",
  "x": "EXECUTE",
  "f5": "EXECUTE"
};
    keycode_dictionary   = {
  "0": "\\",
  "8": "backspace",
  "9": "tab",
  "12": "num",
  "13": "enter",
  "16": "shift",
  "17": "ctrl",
  "18": "alt",
  "19": "pause",
  "20": "caps",
  "27": "esc",
  "32": "space",
  "33": "pageup",
  "34": "pagedown",
  "35": "end",
  "36": "home",
  "37": "left",
  "38": "up",
  "39": "right",
  "40": "down",
  "44": "print",
  "45": "insert",
  "46": "delete",
  "48": "0",
  "49": "1",
  "50": "2",
  "51": "3",
  "52": "4",
  "53": "5",
  "54": "6",
  "55": "7",
  "56": "8",
  "57": "9",
  "59": ";",
  "61": "=",
  "65": "a",
  "66": "b",
  "67": "c",
  "68": "d",
  "69": "e",
  "70": "f",
  "71": "g",
  "72": "h",
  "73": "i",
  "74": "j",
  "75": "k",
  "76": "l",
  "77": "m",
  "78": "n",
  "79": "o",
  "80": "p",
  "81": "q",
  "82": "r",
  "83": "s",
  "84": "t",
  "85": "u",
  "86": "v",
  "87": "w",
  "88": "x",
  "89": "y",
  "90": "z",
  "91": "cmd",
  "92": "cmd",
  "93": "cmd",
  "96": "num_0",
  "97": "num_1",
  "98": "num_2",
  "99": "num_3",
  "100": "num_4",
  "101": "num_5",
  "102": "num_6",
  "103": "num_7",
  "104": "num_8",
  "105": "num_9",
  "106": "num_multiply",
  "107": "num_add",
  "108": "num_enter",
  "109": "num_subtract",
  "110": "num_decimal",
  "111": "num_divide",
  "112": "f1",
  "113": "f2",
  "114": "f3",
  "115": "f4",
  "116": "f5",
  "117": "f6",
  "118": "f7",
  "119": "f8",
  "120": "f9",
  "121": "f10",
  "122": "f11",
  "123": "f12",
  "124": "print",
  "144": "num",
  "145": "scroll",
  "173": "-",
  "186": ";",
  "187": "=",
  "188": ",",
  "189": "-",
  "190": ".",
  "191": "/",
  "192": "`",
  "219": "[",
  "220": "\\",
  "221": "]",
  "222": "'",
  "223": "`",
  "224": "cmd",
  "225": "alt",
  "57392": "ctrl",
  "63289": "num"
};
    keycode_shifted_keys = {
  "0": ")",
  "1": "!",
  "2": "@",
  "3": "#",
  "4": "$",
  "5": "%",
  "6": "^",
  "7": "&",
  "8": "*",
  "9": "(",
  "/": "?",
  ".": ">",
  ",": "<",
  "'": "\"",
  ";": ":",
  "[": "{",
  "]": "}",
  "\\": "|",
  "`": "~",
  "=": "+",
  "-": "_"
};
    user_translations    = {
};

    I18n = new translation({"name":"Showoff Presentation","menu":{"title":"Showoff Menu","table_of_contents":"Table of Contents","downloads":"Downloads","feedback":{"label":"Send Feedback","description":"This slide is...","worst":"Terrible","best":"Awesome","why":"Why...?","send":"Send"},"pace":{"label":"The presenter should...","slower":"Slow Down","faster":"Speed Up"},"question":{"label":"Ask a Question","placeholder":"Ask a question..."},"edit":"Edit Current Slide","clear_annotations":"Clear Annotations","language":"Content Language","close":"Close","help":"Press <code>?</code> for help.","anonymous":"All features are anonymous.","sending":"Sending..."},"navigation":{"next":"Next","previous":"Previous","sync":"Sync Presentation"},"loading":"loading presentation...","activity_complete":"Activity complete","follow":{"label":"Follow Mode:"},"refresh":"Are you sure you want to refresh the slide content?\n\n(Use `RELOAD` to fully reload the entire UI)","reload":"Are you sure you want to reload Showoff?","preshow":{"prompt":"Minutes from now to start?","resume":"Resuming in:"},"tour":{"reset":"Reset Hints","welcome":"<h3>Welcome to Showoff</h3>Let me show you around. After you finish this tour, it won't show again.","displayview":"Start by clicking this button to open the Display Window; then drag it onto the projector.","annotations":"Draw on your slides everywhere the presentation is displayed.","timer":"Set a countdown timer to help you stay on pace.","pace":"Audience members can use this to tell you if you're moving too quickly. Try to keep the indicator centered.","questions":"Questions asked by audience members are displayed here. You'll also see a count indicator on the Display Window when you have questions to answer.","notes":"Configure the notes display by zooming text, resizing the pane, or even popping it out into a new window.","slidesource":"The name of the slide is displayed here.","settings":"Would you like a different presenter layout? Choose that and other settings here.","edit":"This button will open your web-based editor--usually something like GitHub.","report":"Don't forget to report issues when you see them.","activity":{"count":"This will count down as audience members mark their activity complete. Their presentations will pause until completed.","complete":"Check this box when you're ready to move on. The presentation will pause while you're working."},"form":{"responses":"As questions are answered, they'll show up as a bar chart with the number of answers to each question on the right.","display":"Press this button to present a snapshot of the live responses on slide.","save":"Press this button to save your responses. The presentation will pause while answering."},"menu":"The menu in this corner allows independent navigation, file downloading, interactivity, and more."},"downloads":{"title":"File Downloads"},"help":{"title":"Help","next":"Move to the next slide.","prev":"Move to the previous slide.","contents":"Show the table of contents menu.","follow":"Toggle follow mode.","help":"Show this help dialog.","refresh":"Refresh slide content.","reload":"Completely reload Showoff.","blank":"Blank the screen.","footer":"Toggle the display footer.","notes":"Toggle notes display.","clear":"Clear code execution results.","pause":"Pause the presentation.","preshow":"Display slideshow of <tt>preshow</tt> images on a timer.","execute":"Execute the first visible code block.","debug":"Show debugging information.","close":"Close"},"stats":{"title":"Viewing Statistics","stray":"of your audience is not viewing the same slide you are.","idle":"of your audience is idle.","current":"Slides currently being viewed","elapsed":"Elapsed time spent on each slide","nodata":"No data to display.","allcurrent":"All audience members are viewing the presenter's slide."},"forms":{"display":"Display Results","save":"Save"},"presenter":{"topbar":{"annotations":"Annotations","edit":"Edit Slide","report":"Report Issue With Slide","stats":"Viewing Statistics","downloads":"Downloads","display":"Display Window","print":"Print Slides","settings":"Settings","newpage":"Open in a new page...","tooltip":{"annotations":"Enable the annotations subsystem.","edit":"Edit current slide in new window.","report":"Report an issue with the current slide.","stats":"See the slides your audience is interacting with.","downloads":"Open the file downloads in a menu or new page.","display":"Enable the Display Window; you should put this on the projector.","print":"Print slides using a new window.","settings":"Open the Settings dialog."}},"preview":{"next":"Next","previous":"Previous"},"mobile":{"update":"Update"},"notes":{"label":"Showoff Notes","personal":"Personal Notes"},"timer":{"label":"Timer:","start":"Start","pause":"Pause","resume":"Resume","cancel":"Cancel","unit":"minutes"},"pace":{"faster":"Speed Up!","slower":"Slow Down!"},"questions":"Audience Questions","annotation":{"tools":"Tools","lines":"Lines","shapes":"Shapes"},"status":{"label":"Slides:"},"settings":{"label":"Settings","close":"Close","follower":{"label":"Update Follower","tooltip":"Send slide change notifications.","description":"When this is enabled, the Showoff server will track your slide changes. Disable it to observe the presentation without inadvertently causing slide changes."},"remote":{"label":"Enable Remote","tooltip":"Enables tracking of other presenters.","description":"When this is enabled, you can load the presenter in another browser (typically on your mobile phone) to control the presentation."},"layout":{"label":"Layout","default":"Default Layout","thumbs":"Display thumbnail previews of the next and previous slides.","beside":"Display the next slide as a large preview in the main presenter view.","floating":"Open the next slide as a floating window.","confirmation":"Browser security requires confirmation before opening a new window.","open":"Open Window","cancel":"cancel","reset":{"label":"Clear Showoff settings.","tooltip":"Reset Showoff UI settings to default values."}},"language":{"label":"Content Language","tooltip":"Select from available translations, or autoselect based on your browser settings.","description":"This presentation is available in different languages. Choose the language you would like to view or leave it at <tt>automatic</tt> to use your browser settings."}},"print":{"label":"Choose type of printed notes","description":"Select the content you'd like to show under the slides.","none":"Don't include notes","notes":"Presenter Notes","handouts":"Audience Handouts"}},"language":{"auto":"Automatic","disable":"Disable Translations"},"error":{"file_not_found":"File Not Found!"}});

  </script>


  <script type="text/javascript">
    tours['showoff:activity'] = [
      {
        element: ".currentSlide .activityToggle",
        intro: I18n.t('tour.activity.complete')
      }
    ];

    tours['showoff:form'] = [
      {
        element: ".currentSlide input.save",
        intro: I18n.t('tour.form.save')
      }
    ];

    tours['showoff:menu'] = [
      {
        element: "#hamburger",
        intro: I18n.t('tour.menu')
      }
    ];

  </script>
</head>

<body>
<div id="questionsIndicator"></div>

<i id="hamburger" class="fa fa-bars fa-2x"></i>
<div id="sidebarWrapper">
    <div id="navigationHover"></div>
    <div id="feedbackSidebar" class="sideMenu">
    <img id="disconnected" src=".//css/disconnected.png">
    <h3>Showoff Menu</h3>
    <div id="navToggle" class="buttonWrapper"><i class=" fa fa-bookmark"></i> Table of Contents</div>
    <div id="navigation" class="submenu"></div>
    
    <hr>

    

    

    <div id="closeMenu" class="buttonWrapper"><i class="fa fa-close"></i> Close</div>
    <hr>

    <small>
        <p>Press <code>?</code> for help.</p>
        <p>All features are anonymous.</p>
    </small>
    </div>
    <div id="sidebarExit"></div>
</div>
<div id="help-modal" title="Help">
  <div id="help">
    <div>
      <span class="description">Move to the next slide.</span>
      <span class="action">NEXT</span>
      <span class="hotkeys"><span class="key">space</span><span class="key">down</span><span class="key">right</span><span class="key">pagedown</span></span>
    </div>
    <div>
      <span class="description">Move to the previous slide.</span>
      <span class="action">PREV</span>
      <span class="hotkeys"><span class="key">up</span><span class="key">left</span><span class="key">pageup</span></span>
    </div>
    <div>
      <span class="description">Show the table of contents menu.</span>
      <span class="action">CONTENTS</span>
      <span class="hotkeys"><span class="key">c</span><span class="key">t</span></span>
    </div>
    <div>
      <span class="description">Toggle follow mode.</span>
      <span class="action">FOLLOW</span>
      <span class="hotkeys"><span class="key">f</span></span>
    </div>
    <div>
      <span class="description">Show this help dialog.</span>
      <span class="action">HELP</span>
      <span class="hotkeys"><span class="key">h</span><span class="key">/</span><span class="key">?</span></span>
    </div>

    <hr />

    <div>
      <span class="description">Refresh slide content.</span>
      <span class="action">REFRESH</span>
      <span class="hotkeys"><span class="key">r</span></span>
    </div>
    <div>
      <span class="description">Completely reload Showoff.</span>
      <span class="action">RELOAD</span>
      <span class="hotkeys"><span class="key">R</span></span>
    </div>
    <div>
      <span class="description">Blank the screen.</span>
      <span class="action">BLANK</span>
      <span class="hotkeys"><span class="key">b</span><span class="key">.</span></span>
    </div>
    <div>
      <span class="description">Toggle the display footer.</span>
      <span class="action">FOOTER</span>
      <span class="hotkeys"><span class="key">F</span></span>
    </div>
    <div>
      <span class="description">Toggle notes display.</span>
      <span class="action">NOTES</span>
      <span class="hotkeys"><span class="key">n</span></span>
    </div>
    <div>
      <span class="description">Clear code execution results.</span>
      <span class="action">CLEAR</span>
      <span class="hotkeys"><span class="key">esc</span></span>
    </div>
    <div>
      <span class="description">Pause the presentation.</span>
      <span class="action">PAUSE</span>
      <span class="hotkeys"><span class="key">p</span></span>
    </div>
    <div>
      <span class="description">Display slideshow of <tt>preshow</tt> images on a timer.</span>
      <span class="action">PRESHOW</span>
      <span class="hotkeys"><span class="key">P</span></span>
    </div>
    <div>
      <span class="description">Execute the first visible code block.</span>
      <span class="action">EXECUTE</span>
      <span class="hotkeys"><span class="key">x</span><span class="key">f5</span></span>
    </div>

    <hr />

    <div>
      <span class="description">Show debugging information.</span>
      <span class="action">DEBUG</span>
      <span class="hotkeys"><span class="key">d</span></span>
    </div>
  </div>
</div>

<div id="preso"><center>loading presentation...</center></div>
<a id="synchronize"><i class="fa fa-link" aria-hidden="true" href="#"></i> Sync Presentation</a>
<div id="notes"></div>

<footer id="footer">
  <span id="followLabel" class="container">Follow Mode: <i id="followMode" class="fa fa-ban" aria-hidden="true"></i></span>
  <span id="slideInfo" class="container"></span>
  <span id="debugInfo" class="container"></span>
  <span id="notesInfo" class="container"></span>
  <span id="slideFilename" class="container"></span>
  <img id="disconnected" src=".//css/disconnected.png" />
</footer>

<div id="slides" class="offscreen" style="display:none;">
<div data-section="Python介绍" data-title="01_python" id="Python___01_python" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="Python介绍/01_python">
<h1>Python</h1>

<p><a href="https://www.python.org/">https://www.python.org</a></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>Python</h1>

<p>Python 属于解释型语言, 代码是在运行时候进行编译和执行的, 不同于编译型语言, 解释性语言最让人诟病的就是速度了. 但是既然是解释性语言, 就一定是跨平台的了, 只要是在不同的平台上安装同样的 Python 编译器即可.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="Python介绍" data-title="02_author" id="Python___02_author" class="slide" data-transition="none">
<div class="content " ref="Python介绍/02_author">
<h1>Python 作者</h1>

<p>Python 作者 <a href="https://en.wikipedia.org/wiki/Guido_van_Rossum">Guido van Rossum</a> 在 1991 年创建了第一个Python的编译器.</p>

<p><img src="./file//_images/introduction/Guido.png" alt="Alt text"></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>大部分人觉得对这些人的了解没有用, 但有些时候, 对他们有了一定的了解, 也会对我们有一些帮助的, 比如 C 语言和 UNIX 之父 丹尼斯·里奇, 他在 1970年创建了 C 语言, 并用C语言开发的 UNIX 操作系统, 如果知道这些, 你就会知道, 为什么现在所有计算机的起始时间是从 1970 年开始, 因为那一年创建的Unix操作系统,</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="Python介绍" data-title="03_whyPython" id="Python___03_whyPython" class="slide" data-transition="none">
<div class="content " ref="Python介绍/03_whyPython">
<h1>为什么选择 Python</h1>

<ul>
<li><p>语法简洁易懂<br>
Python 作者在设计之初就以 容易阅读，容易使用，容易记忆，容易学习为初衷来设计的, 以此来激发人们学习编程的兴趣</p></li>
<li><p>对操作系统友好<br>
Python既能够像 C 语言那样, 全面调用操作系统的接口(比如后面要将的关于文件系统, 信号, 进程等), 又可以像 shell那样轻松编程, 是 DevOps 的首选语言.</p></li>
<li>
<p>丰富的扩展库  </p>

<ul>
<li>迄今为止, 世界上已经包含了上千个 Python 库, 从web开发, 到操作系统级别的库, 再到机器学习的库. <a href="https://pypi.python.org/pypi/pip">Python 库列表</a>
</li>
<li>
<a href="https://github.com/vinta/awesome-python">awesome Python</a> 这是一个份 Python 库列表, 列举了最常用的一些库.</li>
</ul>
</li>
<li><p>应用领域广泛<br>
Python 应用的领域极为广泛, 从大的方面来说, 包括 web 开发, 桌面程序(包括命令行工具), 计算机科学领域开发(尤其是在机器学习领域, 虽然 R 语言也应用在该领域中, 但比起晦涩难懂的语法, 以及Python丰富的库, Python是当今世界上在该领域上应用最广泛的语言, 其中最著名的当属 Google 的 <a href="https://github.com/tensorflow/tensorflow">tensorflow</a>).</p></li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>为什么选择 Python</h1>

<h2>语法简洁易懂</h2>

<p>Python 的语法非常简洁, 有过其他编程经验的人, 即使没学过 Python, 只要看一眼 Pytho 的代码, 基本就可以识别出 Python 代码的含义了.</p>

<h2>对操作系统友好</h2>

<p>作为DevOps, 平时打交道最多的肯定是操作系统了, 比如调用各种各样的命令, 获取系统的一些信息等. Python 分装了几乎所有 Linux 系统的 API 接口, 可以让我们向 C 语言中那样调用系统中几乎所有的 API. 如果是开发很简单的小程序, <code>Shell</code> 可能会是我们的首选, 但是要是开发稍微比较复杂的程序, Python 还是我们的首选.</p>

<h2>应用领域广泛</h2>

<p>web 开发方面, Python 提供了很多功能强大的 web 框架, 比如 Django, Flask, Tornado, 但是在本次课程中, 不会讲解这些框架, 因为我们主要是针对 DevOps 的, DevOps 大部分工作都是在命令行上的, 而不是 web 开发.</p>

<p>桌面程序, 或是命令行程序, 现在最火的, 跟我们 DevOps 相关的, 肯定要属 Ansible 了.</p>

<p>同时 python 本身这门语言既可以 面向对象开发, 也可以是 面向过程</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="Python介绍" data-title="04_trend" id="Python___04_trend" class="slide" data-transition="none">
<div class="content " ref="Python介绍/04_trend">
<h1>Python 趋势</h1>

<p><img src="./file//_images/introduction/trend.png" alt="Alt text"></p>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="01_version" id="__Python_01_version" class="slide" data-transition="none">
<div class="content " ref="安装Python/01_version">
<h1>Python 中的版本</h1>

<p>Python当前有两个主要版本</p>

<ul>
<li>Python2 最新版本为 <code>2.7</code>, 这也是 Python2 中的最后一个版本, 也是大部分操作系统当前默认自带的 Python 版本.</li>
<li>
<strong>Python3</strong> 最新版本为 <code>3.6</code>
</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>版本选择</h1>

<p>如果是一个Python的初学者, 遇到的第一个比较纠结的问题就是选择 Python 版本的问题, 这个问题很少在其他语言中出现, 一般都是选择最新版本去学习, 而在 Python 中之所以会出现这个问题, 是因为 Python 当前有 2 个主要的版本, Python2 和 Python3, Python2 最新版本为 <code>2.7</code>, 这也是 Python2 的最后一个版本了, Python3 当前最新版本是 <code>3.6</code>, <code>3.7</code>还处于开发阶段. 并且Python2 和 3 之间是不兼容的, 这也就是说 在 Python2 下运行良好的程序, 到 Python 3 下就可能会崩溃, 反之亦然.</p>

<p>为什么会出现 Python3 呢? 其实可以简单地理解为 Python3 是 Python2 的一个升级版, Python3 对 Python2 做了很多重构和优化的工作, 也提升了很多性能问题等.<br>
并且, python3 是未来的趋势, 这一点是毋庸置疑的. 早在几年前, Python 就曾经放出过话来, 说将在 15 年停止对 Python2 的更新, 但是事与愿违, 因为现在 Python2 的应用程序实在太多太广泛了, 并且到目前为止, 所有的主流操作系统默认安装的全是 Python2, 所以就又推迟了这个计划.</p>

<p>既然这样, 肯定是直接选择 Python3 去学习啊. 但是另一个问题是: Python3 在 08 年才被引入, 而Python2 已经运行了二十几年了, 相对于 Python3 来说, Python2 的类库更为丰富, 虽然大部分类库已经迁移到了 Python3 中, 另外一个主要原因是, 当前所有主流操作系统, 默认使用的都是 Python2, 包括 AIX 系统, 如果开发了 Python3 的程序, 需要在这些机器上安装 python3 的解释器, 尤其是对于我们 DevOps 来说, 平时工作的主流操作系统上运行的都是 Python2 版本, 所以选择 Python2 是比较靠谱的选择. 这就导致了版本选择这个纠结的问题.</p>

<p>在我们的这次课程中, 主要还是以 Python3 为主, 因为必将这是未来的趋势么, 但是在讲解的过程中会对比 Python2 的不同之处. 尽量让大家知道 Python2 与 Python3 中的区别, 这样无论是写2 还是 3 的程序, 都没有问题了.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="02_pythonInstall" id="__Python_02_pythonInstall1" class="slide" data-transition="none">
<div class="content " ref="安装Python/02_pythonInstall:1">
<h1>从源码安装 Python</h1>

<h2>准备</h2>

<pre class="highlight"><code class="language-bash">yum install -y \
    zlib-devel \
    readline-devel \
    bzip2-devel \
    libsq3-devel \
    openssl-devel </code></pre>

<h2>下载源码</h2>

<pre class="highlight"><code class="language-bash">wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz</code></pre>

<h2>编译&amp;安装</h2>

<pre class="highlight"><code class="language-bash">./configure --prefix=/usr/local/python2.7 &amp;&amp; \
make &amp;&amp; \
make install</code></pre>

<p>查看 Python 版本</p>

<pre class="highlight"><code class="language-shell execute">/usr/local/python3.6/bin/python3 -V</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>当确定好 Python 版本后, 就可以安装 Python 了.</p>

<p>虽然一般大部分系统主流操作系统中都已经预先安装好了 Python, 但某些情况下, 比如说预安装的 Python 版本不符合我们的要求, 或在系统上运行的多个 Python 项目使用了不同的 Python 版本等, 我们就需要安装符合的 Python 版本了.</p>

<p>对于Windows和Mac上的Python非常简单, 一直下一步下一步就可以了. 这里就不介绍了. 这里主要说一下 linux 上的源码编译安装.</p>

<p>我们主要介绍一下从源码安装 Python, python的源码可以从官网下载到, 也可以从 github 上下载到.</p>

<p>在编译Python源码之前, 我们首先要安装一些库文件, 这些库是安装 Python 时所依赖的库, 但并不是必须的, 当编译 Python 时, 只有开启某些功能时, 才会需要相应的库, 或者说只有某些库存在时, 才会开启Python的某些功能. 比如要使用 ssl 功能, 系统就需要预先安装好 openssl 的 dev 库</p>

<p>编译之前首先是要下载源码, 到 Python 的官网上就可以找到所有版本的源代码.</p>

<p><code>wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz</code><br>
<code>tar -Jxvf Python-3.6.2.tar.xz</code></p>

<p>执行 <code>configure</code> 和 <code>make</code> 命令开始编译和安装 Python 源码  </p>

<h1>autotools</h1>

<p>在编译的时候, 我简单说一下 <code>configure</code> 和 <code>make</code> 命令, 在 Linux 下, 几乎所有的编译安装都会用到这套流程, <code>configure</code>-&gt;<code>make</code>-&gt;<code>make install</code>, 而不仅仅是安装 Python.<br>
<code>configure</code> 其实就是一个 shell 脚本, 这个脚本是由 <code>autotools</code> 系列工具生成出来的.</p>

<h1>查看 Python 版本信息</h1>

<p>当安装好python 后, 可以通过执行 <code>python -V</code> 查看 python 版本信息</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="02_pythonInstall" id="__Python_02_pythonInstall2" class="slide bullets incremental" data-transition="fade">
<div class="content bullets incremental" ref="安装Python/02_pythonInstall:2">
<h2>autotools</h2>

<p><em>configure 是由 autotools 系列工具生成出来的 SHELL 脚本文件, 该脚本最主要作用 检测安装环境(包括必要的库,头文件等是否存在); 软件的功能性的配置(打开/关闭 XXX功能) 以及生成 Makefile.</em></p>

<blockquote>
<p>autotools 由一系列工具组成, 包括:</p>
</blockquote>

<ul>
<li> - <code>autoconf</code> 用于生成 configure shell 脚本 执行 <code>./configure -h</code> 查看帮助信息.</li>
<li> - <code>automake</code> 由 autoconf 调用, 生成 Makefile 文件</li>
<li> - <code>libtool</code> 根据配置生成共享库文件</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>当确定好 Python 版本后, 就可以安装 Python 了.</p>

<p>虽然一般大部分系统主流操作系统中都已经预先安装好了 Python, 但某些情况下, 比如说预安装的 Python 版本不符合我们的要求, 或在系统上运行的多个 Python 项目使用了不同的 Python 版本等, 我们就需要安装符合的 Python 版本了.</p>

<p>对于Windows和Mac上的Python非常简单, 一直下一步下一步就可以了. 这里就不介绍了. 这里主要说一下 linux 上的源码编译安装.</p>

<p>我们主要介绍一下从源码安装 Python, python的源码可以从官网下载到, 也可以从 github 上下载到.</p>

<p>在编译Python源码之前, 我们首先要安装一些库文件, 这些库是安装 Python 时所依赖的库, 但并不是必须的, 当编译 Python 时, 只有开启某些功能时, 才会需要相应的库, 或者说只有某些库存在时, 才会开启Python的某些功能. 比如要使用 ssl 功能, 系统就需要预先安装好 openssl 的 dev 库</p>

<p>编译之前首先是要下载源码, 到 Python 的官网上就可以找到所有版本的源代码.</p>

<p><code>wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz</code><br>
<code>tar -Jxvf Python-3.6.2.tar.xz</code></p>

<p>执行 <code>configure</code> 和 <code>make</code> 命令开始编译和安装 Python 源码  </p>

<h1>autotools</h1>

<p>在编译的时候, 我简单说一下 <code>configure</code> 和 <code>make</code> 命令, 在 Linux 下, 几乎所有的编译安装都会用到这套流程, <code>configure</code>-&gt;<code>make</code>-&gt;<code>make install</code>, 而不仅仅是安装 Python.<br>
<code>configure</code> 其实就是一个 shell 脚本, 这个脚本是由 <code>autotools</code> 系列工具生成出来的.</p>

<h1>查看 Python 版本信息</h1>

<p>当安装好python 后, 可以通过执行 <code>python -V</code> 查看 python 版本信息</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="03_pyenv" id="__Python_03_pyenv1" class="slide" data-transition="turnUp">
<div class="content " ref="安装Python/03_pyenv:1">
<h1>pyenv 的安装与使用</h1>

<p>pyenv 是一个用 <code>SHELL</code> 编写的工具, 它可以让我们在系统中快速方便地安装多个 Python 版本, 并且在已安装的 Python 版本中随意地进行切换.</p>

<p>pyenv项目地址: <a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a></p>

<h2>安装 pyenv</h2>

<pre class="highlight"><code class="language-bash"># 获取源码
git clone https://github.com/pyenv/pyenv.git ~/.pyenv

# 设置 PVENV_ROOT 环境变量, 注意如果你使用的是其他shell, 如 ZSH, 请使用 .zshenv 代替 .bash_profile 文件.
echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.bash_profile
echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.bash_profile
echo 'eval "$(pyenv init -)"' &gt;&gt; ~/.bash_profile

# 使修改生效, 或重新登录shell
. ~/.bash_profile</code></pre>

<p class="callout warning">以上我们是将pyenv安装到了当前用户下, 所以仅对当前用户生效.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<pre class="highlight"><code class="language-bash">pyenv -v
pyenv -h
pyenv install -h

pyenv install -l

pyenv install 3.6.2

pyenv versions

pyenv global 3.6.2
pyenv global
# python -V
# command -v python

# /root/.pyenv/version
pyenv version

pyenv which python

pyenv local 2.7.13
cat .python-version

pyenv local --unset</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="03_pyenv" id="__Python_03_pyenv2" class="slide" data-transition="turnUp">
<div class="content " ref="安装Python/03_pyenv:2">
<h1>使用 pyenv</h1>

<pre class="highlight"><code class="language-bash"># 查看 pyenv 版本信息
pyenv -v

# 查看帮助信息
pyenv -h
pyenv install -h

# 列出所有可用的 python 版本
pyenv install -l

# 安装一个指定的 python 版本
pyenv install 3.6.2

# 查看当前系统中安装了哪些 Python 版本
pyenv versions

# 设置某个版本作为系统的默认版本
pyenv global 3.6.2
# 查看当前系统默认版本信息
pyenv global

# 查看当前使用的 Python 版本
pyenv version

# 查看当前所使用的 Python 的路径信息
pyenv which python

# 为某个目录设置单独的 Python 版本
pyenv local 3.6.2

# 取消当前目录设定
pyenv local --unset</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<pre class="highlight"><code class="language-bash">pyenv -v
pyenv -h
pyenv install -h

pyenv install -l

pyenv install 3.6.2

pyenv versions

pyenv global 3.6.2
pyenv global
# python -V
# command -v python

# /root/.pyenv/version
pyenv version

pyenv which python

pyenv local 2.7.13
cat .python-version

pyenv local --unset</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="04_pip" id="__Python_04_pip" class="slide" data-transition="none">
<div class="content " ref="安装Python/04_pip">
<h1>Python 包管理工具 pip</h1>

<p>Python 中存在成千上万个第三方库, 当我们的程序中需要这些第三方库的时候, 可以通过python的包管理工具 <a href="https://pypi.python.org/pypi/pip">Python Package Manager</a>, 很容易的安装和更新这些第三方库.</p>

<h2>pip命令</h2>

<pre class="highlight"><code class="language-bash"># 查看帮助信息
pip -h
pip install -h

# 查询某个库
pip search requests

# 安装库
pip install requests

# 卸载库
pip uninstall requests
# 卸载时不提示确认信息
pip uninstall -y requests

# 安装指定版本
pip install requests==2.0.0

# 安装某个库时指定最小版本
pip install requests&gt;=2.18.3

# 从文件安装
pip install -r requirements.txt

# 打印出当前系统中安装的库及其版本信息
pip freeze

# 查看那些库有更新.
pip list -o

# 更新库
pip install -U requests

# 列出当前已安装库信息
pip freeze

# 更新所有
pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U </code></pre>

<h2>pip requirments.txt</h2>

<pre class="highlight"><code class="language-bash">#
####### requirements.txt #######
#
###### 没有指定特定版本信息的第三方库 ######
nose
nose-cov
beautifulsoup4
#
###### 明确指定了要第三方库要使用的版本 ######
#   See https://www.python.org/dev/peps/pep-0440/#version-specifiers
docopt == 0.6.1             # Version Matching. Must be version 0.6.1
keyring &gt;= 4.1.1            # Minimum version 4.1.1
coverage != 3.5             # Version Exclusion. Anything except version 3.5
Mopidy-Dirble ~= 1.1        # Compatible release. Same as &gt;= 1.1, == 1.*
#
###### 引用其他 requirements.txt 文件 ######
-r other-requirements.txt</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pip</h1>

<p>@@@ bash
    pip -h
    pip install -h</p>

<pre><code>pip search requests
pip search requests | grep -i '^requests '

pip install requests

pip list

pip show requests
pip show -v/--verbose requests

# pip uninstall requests
pip uninstall -y requests

pip install requests==2.0.0
# 安装大于版本号大于 2.0.0 的版本
pip install requests&gt;=2.0.0

# 查看有更新的版本
pip list -o

pip install -U requests
</code></pre>

<h1>requirement file</h1>

<pre class="highlight"><code class="language-bash">pip freeze
pip freeze &gt; requirement.txt
pip install -r requirement.txt
pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="05_virtualenv" id="__Python_05_virtualenv1" class="slide" data-transition="none">
<div class="content " ref="安装Python/05_virtualenv:1">
<h1>virtualenv</h1>

<p><a href="https://virtualenv.pypa.io/en/stable">virtualenv</a> 可以让我们很方便的创建 Python 的虚拟开发环境.</p>

<h2>安装 <code>virtualenv</code>
</h2>

<p>使用 <code>pip</code> 安装 virtualenv</p>

<pre class="highlight"><code class="language-bash">pip install virtualenv</code></pre>

<h2>创建虚拟环境</h2>

<pre class="highlight"><code class="language-bash">virtualenv proj1</code></pre>

<p>该命令会在当前目录下创建一个新目录 proj1, 并包含以下子目录:</p>

<ul>
<li>
<code>include</code> 包含了 Python 的头文件</li>
<li>
<code>lib</code> 包含了 Python 中的库文件, 新安装的库将全部存放在 lib/pythonXX/site-packages/ 目录下</li>
<li>
<code>bin</code> 生成的一些可执行文件, 包括 Python, pip 等等</li>
</ul>

<h2>指定 Python 版本</h2>

<pre class="highlight"><code class="language-bash">virtualenv proj2 --python /root/.pyenv/versions/2.7.13/bin/python</code></pre>

<h2>激活环境</h2>

<pre class="highlight"><code class="language-bash">. proj1/bin/activate</code></pre>

<h2>取消激活</h2>

<pre class="highlight"><code class="language-bash">. proj1/bin/activate</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>virtualenv</h1>

<pre class="highlight"><code class="language-bash">virtualenv -h

virtualenv proj1

# proj1/lib/python2.7/site-packages/
pip install requests

. proje1/bin/activate
python -V

export

deactivate

virtualenv --python /root/.pyenv/versions/2.7.13/bin/python proj2
python -V</code></pre>

<h1>pyenv virtualenv</h1>

<pre class="highlight"><code class="language-bash">pyenv virtualenv 3.6.2 proj1
pyenv virtualenv 3.7.13 proj2

pyenv virtualenvs

pyenv uninstall proj1

pyenv activate proj2

pyenv deactivate

mkdir proj2
pyenv local proj2</code></pre>

<hr>

<p>最后在介绍一个更炫酷的工具 virtualenv</p>

<p>现在大家想象一下, 你当前维护了多个不同的 Python 项目, 而这些项目中既有 Python2 开发的, 又有 Python3 开发的, 即使是使用相同 Python 版本开发的, 这些 Python 项目不可能会使用完全一样的库, 甚至会出现不同的项目使用同一个库的不同版本.</p>

<p>这时我们就需要为每个项目创建一个相对独立的开发环境, 而 virtualenv 就是为我们提供一个虚拟的开发环境, 它能在同一台电脑上创建多个 Python 的虚拟开发环境, 每个虚拟环境都是相互独立的,(说到虚拟环境, 大家一定要与虚拟机的那个虚拟区别开来, virtualenv中的虚拟仅仅是作用在文件夹层级的, 说白了就是每个虚拟环境仅仅是一个目录罢了. 它只是通过设定一些环境变量指向这个目录). 当启用一个虚拟环境时, 执行 python 的所有命令都将来自于这个虚拟环境, 并且所安装的所有扩展库也都将安装到这个虚拟环境中, 这样就达到了多个虚拟环境以及和系统之间相互隔离的目的.</p>

<p>安装 <code>virtualenv</code> 非常简单, 使用 <code>pip</code> 命令就可以直接安装了.</p>

<p>安装好以后, <code>pip show --verbose virtualenv</code> 查看详细信息</p>

<p>安装好 <code>virtualenv</code> 后就可以使用了, 首先第一个命令就是创建一个虚拟的环境, 格式为 <code>virtual proj1</code>, 该命令会在当前目录下创建一个名为 <code>proj1</code> 的子目录, 也可以加上 <code>-v</code> 参数显示详细信息.</p>

<p>该命令会在当前目录下创建一个新目录 proj1, 并包含以下子目录:</p>

<ul>
<li>
<code>include</code> 包含了 Python 的头文件</li>
<li>
<code>lib</code> 包含了 Python 中的库文件, 新安装的库将全部存放在 lib/pythonXX/site-packages/ 目录下</li>
<li>
<code>bin</code> 生成的一些可执行文件, 包括 Python, pip 等等</li>
</ul>

<h2>激活环境</h2>

<p>在初始化好一个虚拟环境后, 要想使用这个虚拟环境, 首先需要进行激活. 使用 <code>. proj1/bin/activate</code>. 在激活前, 先让我们看一下当前系统中安装了哪些库: <code>pip list</code>. 激活后在看一下, 发现系统中的那些库并没有显示被安装, 这正是我们需要的.</p>

<p>激活 proj1 项目, 可以看到 shell 提示符已经发生了变化, 查看当前使用了那个 Python: <code>command -v python</code> 和 <code>pip</code> 命令.<br>
在我们的虚拟环境中安装一些第三方库: <code>pip install psutil</code>, 安装完以后, <code>pip show psutil</code> 查看详细信息, 可以发现安装位置在 proj1 目录下.</p>

<p>使用 <code>export</code> 可以看到 <code>PATH</code>, <code>PS1</code> 都被修改了, 并增加了一个新的环境变量 <code>VIRTUAL_ENV</code>, 指向了当前项目目录<br>
当激活了一个环境以后, 通过 <code>pip</code> 安装的新库文件将全部被安装到 <code>lib/pythonXX/site-packages/</code> 路径下.</p>

<blockquote>
<p><code>PS4</code> 简单介绍一下</p>
</blockquote>

<h2>取消激活</h2>

<p>我们还可以使用 <code>deactivate</code> 命令来取消当前 Python 虚拟环境的激活.</p>

<p>在刚才的例子中, 我们创建 proj1 项目时, 直接使用了系统当前默认的 Python 版本, 有时候我们需要使用一个特定的 python 版本, 在初始化项目时, 通过指定 <code>--python</code> 选项, 来指定一个明确的 python 版本信息.</p>

<pre class="highlight"><code class="language-bash">virtualenv proj2 --python/-p /root/.pyenv/versions/2.7.13/bin/python
# 激活 proj2 项目
. proj2/bin/activate
# 查看 python 版本
python -V
# 可以看到已经是我们指定的 python 版本了</code></pre>

<h1>pyenv 中的 virtualenv 插件</h1>

<p>我们还可以将 <code>virtualenv</code> 以插件的形式集成到 <code>pyenv</code> 中, 这样我们就可以使用 <code>pyenv</code> 命令方便的使用 <code>virtualenv</code> 了.</p>

<p>安装 <code>virtualenv</code> 插件非常简单, 安装完插件以后, 需要重新激活shell.</p>

<p>在安装完插件以后, 首先需要通过 pyenv 提前创建好我们需要的 virtualenv 环境:<br>
<code>pyenv virtualenv 2.7.13 proj-2.7.13</code></p>

<p>查看当前系统中预设了哪些 virtualenv:<br>
<code>pyenv virtualenvs</code></p>

<p>激活 virtualenv:<br>
<code>pyenv activate proj-2.7.13</code></p>

<p>取消激活:<br>
<code>pyenv deactivate</code></p>

<p>为某个路径设定特定的 virtualenv
    @@@ bash
    mkdir proj1
    pyenv local proj-2.7.13
    # 这样, 当我们每次进入到 proj1 目录后
    # 就会自动激活 proj-2.7.13
    # 退出这个目录后, 就会取消自动激活</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="05_virtualenv" id="__Python_05_virtualenv2" class="slide bullets incremental" data-transition="fade">
<div class="content bullets incremental" ref="安装Python/05_virtualenv:2">
<h1>
<code>pyenv</code> 与 <code>virtualenv</code>
</h1>

<p>通过使用 <code>pyenv</code> 提供 <code>virtualenv</code> 插件, 能够让我们更方便的使用 <code>virtualenv</code>.</p>

<h2>安装 <code>virtualenv</code> 插件</h2>

<pre class="highlight"><code class="language-bash"># 下载插件到 pyenv 的 plugin 目录中
git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv
# 使 virtualenv 支持 pyenv 中类似 local 的功能
echo 'eval "$(pyenv virtualenv-init -)"' &gt;&gt; ~/.bash_profile</code></pre>

<h2>使用 <code>virtualenv</code> 插件</h2>

<p>在安装完插件以后, 首先需要通过 pyenv 提前创建好我们需要的 virtualenv 环境:<br>
<code>pyenv virtualenv 2.7.13 proj-2.7.13</code></p>

<p>查看当前系统中预设了哪些 virtualenv:<br>
<code>pyenv virtualenvs</code></p>

<p>激活 virtualenv:<br>
<code>pyenv activate proj-2.7.13</code></p>

<p>取消激活:<br>
<code>pyenv deactivate</code></p>

<p>为某个路径设定特定的 virtualenv
<code>pyenv local proj-2.7.13</code></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>virtualenv</h1>

<pre class="highlight"><code class="language-bash">virtualenv -h

virtualenv proj1

# proj1/lib/python2.7/site-packages/
pip install requests

. proje1/bin/activate
python -V

export

deactivate

virtualenv --python /root/.pyenv/versions/2.7.13/bin/python proj2
python -V</code></pre>

<h1>pyenv virtualenv</h1>

<pre class="highlight"><code class="language-bash">pyenv virtualenv 3.6.2 proj1
pyenv virtualenv 3.7.13 proj2

pyenv virtualenvs

pyenv uninstall proj1

pyenv activate proj2

pyenv deactivate

mkdir proj2
pyenv local proj2</code></pre>

<hr>

<p>最后在介绍一个更炫酷的工具 virtualenv</p>

<p>现在大家想象一下, 你当前维护了多个不同的 Python 项目, 而这些项目中既有 Python2 开发的, 又有 Python3 开发的, 即使是使用相同 Python 版本开发的, 这些 Python 项目不可能会使用完全一样的库, 甚至会出现不同的项目使用同一个库的不同版本.</p>

<p>这时我们就需要为每个项目创建一个相对独立的开发环境, 而 virtualenv 就是为我们提供一个虚拟的开发环境, 它能在同一台电脑上创建多个 Python 的虚拟开发环境, 每个虚拟环境都是相互独立的,(说到虚拟环境, 大家一定要与虚拟机的那个虚拟区别开来, virtualenv中的虚拟仅仅是作用在文件夹层级的, 说白了就是每个虚拟环境仅仅是一个目录罢了. 它只是通过设定一些环境变量指向这个目录). 当启用一个虚拟环境时, 执行 python 的所有命令都将来自于这个虚拟环境, 并且所安装的所有扩展库也都将安装到这个虚拟环境中, 这样就达到了多个虚拟环境以及和系统之间相互隔离的目的.</p>

<p>安装 <code>virtualenv</code> 非常简单, 使用 <code>pip</code> 命令就可以直接安装了.</p>

<p>安装好以后, <code>pip show --verbose virtualenv</code> 查看详细信息</p>

<p>安装好 <code>virtualenv</code> 后就可以使用了, 首先第一个命令就是创建一个虚拟的环境, 格式为 <code>virtual proj1</code>, 该命令会在当前目录下创建一个名为 <code>proj1</code> 的子目录, 也可以加上 <code>-v</code> 参数显示详细信息.</p>

<p>该命令会在当前目录下创建一个新目录 proj1, 并包含以下子目录:</p>

<ul>
<li>
<code>include</code> 包含了 Python 的头文件</li>
<li>
<code>lib</code> 包含了 Python 中的库文件, 新安装的库将全部存放在 lib/pythonXX/site-packages/ 目录下</li>
<li>
<code>bin</code> 生成的一些可执行文件, 包括 Python, pip 等等</li>
</ul>

<h2>激活环境</h2>

<p>在初始化好一个虚拟环境后, 要想使用这个虚拟环境, 首先需要进行激活. 使用 <code>. proj1/bin/activate</code>. 在激活前, 先让我们看一下当前系统中安装了哪些库: <code>pip list</code>. 激活后在看一下, 发现系统中的那些库并没有显示被安装, 这正是我们需要的.</p>

<p>激活 proj1 项目, 可以看到 shell 提示符已经发生了变化, 查看当前使用了那个 Python: <code>command -v python</code> 和 <code>pip</code> 命令.<br>
在我们的虚拟环境中安装一些第三方库: <code>pip install psutil</code>, 安装完以后, <code>pip show psutil</code> 查看详细信息, 可以发现安装位置在 proj1 目录下.</p>

<p>使用 <code>export</code> 可以看到 <code>PATH</code>, <code>PS1</code> 都被修改了, 并增加了一个新的环境变量 <code>VIRTUAL_ENV</code>, 指向了当前项目目录<br>
当激活了一个环境以后, 通过 <code>pip</code> 安装的新库文件将全部被安装到 <code>lib/pythonXX/site-packages/</code> 路径下.</p>

<blockquote>
<p><code>PS4</code> 简单介绍一下</p>
</blockquote>

<h2>取消激活</h2>

<p>我们还可以使用 <code>deactivate</code> 命令来取消当前 Python 虚拟环境的激活.</p>

<p>在刚才的例子中, 我们创建 proj1 项目时, 直接使用了系统当前默认的 Python 版本, 有时候我们需要使用一个特定的 python 版本, 在初始化项目时, 通过指定 <code>--python</code> 选项, 来指定一个明确的 python 版本信息.</p>

<pre class="highlight"><code class="language-bash">virtualenv proj2 --python/-p /root/.pyenv/versions/2.7.13/bin/python
# 激活 proj2 项目
. proj2/bin/activate
# 查看 python 版本
python -V
# 可以看到已经是我们指定的 python 版本了</code></pre>

<h1>pyenv 中的 virtualenv 插件</h1>

<p>我们还可以将 <code>virtualenv</code> 以插件的形式集成到 <code>pyenv</code> 中, 这样我们就可以使用 <code>pyenv</code> 命令方便的使用 <code>virtualenv</code> 了.</p>

<p>安装 <code>virtualenv</code> 插件非常简单, 安装完插件以后, 需要重新激活shell.</p>

<p>在安装完插件以后, 首先需要通过 pyenv 提前创建好我们需要的 virtualenv 环境:<br>
<code>pyenv virtualenv 2.7.13 proj-2.7.13</code></p>

<p>查看当前系统中预设了哪些 virtualenv:<br>
<code>pyenv virtualenvs</code></p>

<p>激活 virtualenv:<br>
<code>pyenv activate proj-2.7.13</code></p>

<p>取消激活:<br>
<code>pyenv deactivate</code></p>

<p>为某个路径设定特定的 virtualenv
    @@@ bash
    mkdir proj1
    pyenv local proj-2.7.13
    # 这样, 当我们每次进入到 proj1 目录后
    # 就会自动激活 proj-2.7.13
    # 退出这个目录后, 就会取消自动激活</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="进入Python" data-title="00_execute_python" id="__Python_00_execute_python" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="进入Python/00_execute_python">
<h1>执行 Python</h1>

<p>执行 Python 代码, 有两种方式:</p>

<ul>
<li>通过运行 Python 的交互式终端 iPython, 可以让我们直接在里面执行 Python 代码.</li>
<li>将 Python 代码保存到一个以 <code>.py</code> 为后缀的文件中, 在通过 Python 命令来执行这个文件.</li>
</ul>

<p><a href="https://www.tutorialspoint.com/codingground.htm">web 版终端程序</a></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>执行 Python</h1>

<pre class="highlight"><code class="language-bash">python

&gt;&gt;&gt; print("Hi, Python")
&gt;&gt;&gt; exit() # CTRL-D CTRL-C: SIGINT</code></pre>

<hr>

<p>想要执行一个 Python 代码, 可以有两种方式, 一种是通过使用Python shell, 一种交互模式的 Python 解释器, 被称作 iPython, 在里面我们可以直接运行 Python 代码.<br>
直接执行 python 命令, 不使用任何参数, 就打开了一个交互式的 python 解释器, 输入 <code>print('hi Python')</code> 执行 Python 代码. 要想退出 iPython, 可以调用 <code>exit()</code>['ɛɡzɪt] 函数, 或是直接使用 <code>CTRL-D</code> 命令.<br>
<code>CTRL-D</code> 代表的是文件结束符(end of file) <code>EOF</code>, 它跟 <code>CTRL-C</code> 并不一样, <code>CTRL-C</code> 是一个信号.</p>

<p>另一种方式就是将 Python 代码保存到一个以 <code>.py</code> 结尾的文件中, 通过 python 命令来运行这个脚本. 我们应该都知道, 在 Linux 下, 文件的后缀与文件的类型没有任何关系, 我们可以使用任何名字作为后缀, 但是为了便于阅读和维护, 一般都会选择 <code>.py</code> 作为 Python 代码的后缀.</p>

<p><a href="http://blog.csdn.net/coder80/article/details/38510991">http://blog.csdn.net/coder80/article/details/38510991</a></p>

<p><a href="http://img.blog.csdn.net/20160630234148703">http://img.blog.csdn.net/20160630234148703</a></p>

<p>2 和 3 的不同: <a href="http://python3porting.com/differences.html">http://python3porting.com/differences.html</a>, <a href="https://docs.python.org/3.1/whatsnew/3.0.html">https://docs.python.org/3.1/whatsnew/3.0.html</a></p>

<p><a href="https://www.tutorialspoint.com/codingground.htm">web 终端</a></p>

<p><a href="http://www.pythonabc.com/iterable-and-iterator/">iterable</a></p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="进入Python" data-title="01_python_code" id="__Python_01_python_code" class="slide" data-transition="none">
<div class="content " ref="进入Python/01_python_code">
<h1>Python 代码</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/

"""Implementation of the abstract factory pattern"""
import six
import abc
import random


class PetShop(object):

    """A pet shop"""

    def __init__(self, animal_factory=None):
        """pet_factory is our abstract factory.  We can set it at will."""

        self.pet_factory = animal_factory

    def show_pet(self):
        """Creates and shows a pet using the abstract factory"""

        pet = self.pet_factory.get_pet()
        print("We have a lovely {}".format(pet))
        print("It says {}".format(pet.speak()))
        print("We also have {}".format(self.pet_factory.get_food()))


# Stuff that our factory makes

class Dog(object):

    def speak(self):
        return "woof"

    def __str__(self):
        return "Dog"


class Cat(object):

    def speak(self):
        return "meow"

    def __str__(self):
        return "Cat"</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>Python 代码结构</h1>

<p>这是一段简单的 Python 源码文件, 我是从网上拷下来的一部分代码. 在正式学习 Python 之前, 我们先看一下 Python 的源码文件, 对 Python 有个大致的了解.</p>

<p>第一行是脚本解释器的路径, 这个跟编程语言无关, 写过 Shell 脚本的应该最熟悉了, 这行代码告诉 Unix 如何解释这个文件. 以 #! 开头, 后跟一个解释器的绝对路径, 因为系统在解释这个路径的时候不会使用环境变量, 所以后面要使用绝对路径, 这里的 <code>env</code> 是一个命令, 直接执行这个命令可以打印出系统中的环境变量, 其实这句话的意思就是使用系统环境变量中的 Python 来执行这个脚本.</p>

<p>第二行指定 Python 代码的编码格式, 使用 utf-8 编码, 至于为什么需要这行代码, 我们会在后面讲 <code>字符串</code> 的时候讲到</p>

<p>下面以井号 <code>#</code> 开头的是注释代码, Python 中使用 # 号作为注释.</p>

<p>紧接着的用三个双引号括起来的, 是 Python 代码文件的说明文档, 也可以使用三个单引号, 或者单引号, 双引号都可以, 使用三个引号可以让我们随意的分行, 在后面讲 字符串 的时候也会讲到</p>

<p>接着是 3 个 <code>import</code> 语句, 用来导入 Python 中的库供当前文件使用.</p>

<p>接着下一行是使用 <code>class</code> 关键字定义一个类, 这个类继承自 <code>object</code> 类.<br>
如果学过其他的变成语言, 在学 Python 的时候, 这应该是第一个遇到的感觉有点不适的地方, 就是 Python 中的语句块.<br>
首先 Python 中不使用 大括号<code>{}</code> 来表示一个语句块, 而是使用相同的代码缩进来表示, 可以使用 4 个空格, 也可以使用 2 个空格, 但是不管是几个空格, 同一块代码块的缩进必须相同, 比如这个类中定义的代码, 所有代码都至少缩进4个空格, 在看方法中的定义, 同样也都是用相同的缩进. 空格也能使用 <code>tab</code> 代替, 效果是一样的 (但是绝对不能将 tab 和 空格一起使用, 可能会导致意想不到的结果). 从古至今, 写程序的时候到底是用 4个空格, 还是用一个 tab 一直都是争论的焦点, 有人说使用 tab 代替4个空格, 文件在编译之后会少很多字节, 节省一点空间, 不清楚, 没做过实验. 不知道你们看没看过一个美国情景喜剧, &lt;&lt;硅谷&gt;&gt;, 里面就有一集, 讲的是那个屌丝男主角处了一个女朋友, 是 facebook 的一个女程序员, 他们那一集就分手了, 就是因为男主角使用 tab, 那个女的使用 4个空格, 男主角就觉得他俩根本不适合在一起, 其实那个女程序员是个真人, 真是 facebook 的开发工程师.<br>
而且注意代码块开始的地方, 在最后要使用一个 <code>冒号 :</code></p>

<p>接着是类中方法的定义, Python 中定义函数和方法时, 使用 <code>def</code> 关键字, 接着是一个冒号, 下面这个三引号是方法的说明, 同样也可以用三个单引号, 或是单引号, 双引号替换.</p>

<p>接着是一个变量的赋值过程. 跟其它语言一样, 使用等号, 只不过不需要任何关键字, 也不用指定变量的类型. 在 Python 中, 每行语的末尾不需要使用 <code>分号</code>, 当然写上也不报错. 如果一行中写了多个语句的话, 那么语句之间必须使用分号分割, 但是为了代码的可读性, 最好别这么写.</p>

<p>定义另一个方法, 因为这个方法的缩进和上面这个方法的缩进一样, 所以它是第二个方法. 下面是一个 if 判断语句, 判断语句同样需要使用缩进, 注意这里的冒号</p>

<p>这就是 Python 代码的大致结构.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="00_varaibles" id="_______00_varaibles1" class="slide center bullets incremental" data-transition="none">
<div class="content center bullets incremental" ref="基本数据类型/00_varaibles:1">
<h1>变量</h1>

<p>Python 中变量的特点:</p>

<ul>
<li>Python 属于动态类型语言, Python 解释器在解释变量时会根据变量的值自动分配合适的内存空间给变量, 因此无需在声明变量时指定变量的类型.</li>
<li>Python 属于强类型语言, 因此在不同类型的变量之间做操作时不会做自动转换处理.</li>
<li>在使用一个变量前, 必须先定义好这个变量.</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>特点</h1>

<ul>
<li>C/C++不同, 定义变量时不需要指明变量类型, 并不代表变量没有类型, 只是 Python 自动帮我们确定了变量的类型.</li>
<li>Python 强类型: <code>php -r "echo 'abc' + 3;"</code>
</li>
</ul>

<p><img src="./file//_images/datatype/language_type.png" alt="language type"></p>

<h1>变量命名规则</h1>

<pre class="highlight"><code class="language-python"># 获取Python中的所有关键字
import keyword
print(keyword.kwlist)</code></pre>

<h1>约定俗成</h1>

<pre class="highlight"><code class="language-python"># 可用来查看对象内的属性和方法
dir()
dir(__builtins__)

id(5)
id = 5
id(5)</code></pre>

<h1>语法</h1>

<p>动态类型语言</p>

<pre class="highlight"><code class="language-python"># 字符串`
language = 'Python'

# 查看变量类型
type(language)

# 整数
major_version = 3

# 浮点数型
minor_version = 36.1

# 列表
python_versions = [3, 36, 1]

# 同时为多个变量赋值
a = b = c = 1

# 同时赋值多个变量
val1, val2, val3 = 1, 'str1', 'zzl'

# 删除变量
del language</code></pre>

<hr>

<h1>Python 变量</h1>

<p>无论是那种编程语言, 都离不开变量.</p>

<p>Python 中的变量有几个特点:</p>

<p>Python 属于动态类型语言, Python 解释器在解释变量时会根据变量的值自动分配合适的内存空间给变量, 因此我们不需要在声明变量时指定变量的类型, 并且一个变量可以被多次赋给不同类型的值. 比如说给一个变量赋值一个整数后, 还可以重新给这个变量赋一个字符串类型的值. 像 Java 这种属于静态类型语言.<br>
Python 属于强类型语言, 因此在不同类型的变量之间做操作时不会做自动转换处理, 比如把一个字符串和一个数字相加, 就会直接提示错误了. 像 PHP, JS 属于弱类型语言. <code>php -r "echo 'abc' + 3;"</code></p>

<p>定义变量时不需要指明变量类型, 并不代表变量没有类型, 只是 Python 自动帮我们确定了变量的类型.</p>

<p><img src="./file//_images/datatype/language_type.png" alt="language type"></p>

<h1>变量命名规则</h1>

<p>差不多跟所有编程语言的变量命名差不多, 都是由一个不包含空格的任意个数的字符序列组成, 包括数字, 字母和下划线, 但是, 不管是哪种编程语言, 变量名都不是可以随便定义的, 需要符合一些标准, Python 也不例外, 定义一个 Python 变量名, 必须要符合下面这2点要求:</p>

<ul>
<li>变量名必须以字母或下划线开头</li>
<li>不能使用 Python 中的关键字作为变量的名字.</li>
</ul>

<p>要是违背了这两条中的任意一条, Python 都会报错退出程序. 比如定义一个以数字开头的变量: <code>9a = 5</code></p>

<p>我忘记在哪听过一句话了, 说只要是不起脑残的变量名, 就没事. 说的其实也挺有道理的, 话糙理不糙.</p>

<p>这里还有一点要注意一下, 就是 Python 中的变量是区分大小写的.</p>

<h2>约定俗成</h2>

<p>这里还有两条定义变量时约定俗成的规定, 虽然不像上面那两条硬性规定那样, 如果不符合规则, Python 会报出语法错误. 但为了代码的健壮性, 在定义变量时, 最好还要符合以下两条规则:</p>

<ul>
<li>不要使用 Python 中预定义好的变量名做为自己的变量名</li>
</ul>

<p>在 Python 中, 有很多的 内置变量 和 函数, 这些内置变量和函数可以方便我们使用 Python. 我们可以用 <code>dir()</code> 函数查看 Python 中的所有内置变量和函数. <code>dir(__builtins__)</code></p>

<p>可以看见这里有一个内置函数 <code>id()</code>, 这个函数的作用是打印出一个对象的 ID 号, 这个 ID 号在整个 Python 脚本的生命周期内是唯一的, 有点类似于 C 语言中指针地址的意思, 但是这个 id 与内存地址不是同一个东西.</p>

<pre class="highlight"><code class="language-python"># 我们可以先通过使用Python的内置函数 type() 来查看 id 的类型
type(id)
# 提示我们是一个内置方法或函数
# 查看整数 1 的 id
id(1)
# 查看字符串 abc 的 id
id('abc')

# 这时候, 如果我们重新定义了一个变量, 变量名就叫 id
id = 500
# 没有出现任何错误信息
# 打印出这个变量的值
id
# 可以看到能够正确打印出我们付给它的值
# 这是在看 id 的类型, 发现 id 已经变成 int 类型了
type(id)
# 再次获取数值 1 的 ID
id(1)
# 这时候就已经报错了, 提示我们int类型不可以被调用
# 说明内置的 id() 函数已经被我们覆盖掉了.</code></pre>

<ul>
<li>还有一点是不要定义以双下划线dunder(__)开头和结尾的变量, 这是因为 Python 中定义一系列有特殊作用的变量和函数, 都是以双下划线开头和结尾的. 为了防止将来Python新增加的特殊作用的变量或函数与自己定义的变量或方法发生冲突, 尽量不要在变量名的前后都加上双下划线.</li>
</ul>

<p>虽然不遵守以上两点规则, Python 并不会给出任何错误提示, 但我们应当尽量避免这种事情发生.</p>

<h1>定义变量</h1>

<p>在 Python 中定义一个变量非常简单, 使用等号来为一个变量赋值, 刚才我们已经提到过了, Python 属于动态类型语言, 所以我们不需要为变量指定任何类型, Python 解释器会自动解释出变量的类型来的. 也不需要像 PHP 或 JS 那样使用特定的一个关键字来告诉 Python 解释器这是一个变量定义语句, 直接使用等号就可以声明一个变量了.</p>

<p>可以使用 <code>type()</code> 查看一个变量的类型.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="00_varaibles" id="_______00_varaibles2" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/00_varaibles:2">
<h1>变量命名规则</h1>

<p>与大部分其他编程语言类似, 变量名是由一个不包含空格的任意个数的字符序列组成, 包括字母, 数字和下划线, 并且符合以下两个规则:</p>

<ul><li><p>变量名必须以字母 [a-zA-Z] 或下划线(_)开头.</p></li></ul>

<ul><li><p>不能使用 Python 中的关键字作为变量的名字.</p></li></ul>

<pre class="highlight"><code class="language-python execute">import keyword
print(keyword.kwlist)</code></pre>

<p class="callout warning">Python 中的变量名是区分大小写的, 例如 <code>city = 'dl'</code> 和 <code>City = 'DL'</code> 是两个变量.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>特点</h1>

<ul>
<li>C/C++不同, 定义变量时不需要指明变量类型, 并不代表变量没有类型, 只是 Python 自动帮我们确定了变量的类型.</li>
<li>Python 强类型: <code>php -r "echo 'abc' + 3;"</code>
</li>
</ul>

<p><img src="./file//_images/datatype/language_type.png" alt="language type"></p>

<h1>变量命名规则</h1>

<pre class="highlight"><code class="language-python"># 获取Python中的所有关键字
import keyword
print(keyword.kwlist)</code></pre>

<h1>约定俗成</h1>

<pre class="highlight"><code class="language-python"># 可用来查看对象内的属性和方法
dir()
dir(__builtins__)

id(5)
id = 5
id(5)</code></pre>

<h1>语法</h1>

<p>动态类型语言</p>

<pre class="highlight"><code class="language-python"># 字符串`
language = 'Python'

# 查看变量类型
type(language)

# 整数
major_version = 3

# 浮点数型
minor_version = 36.1

# 列表
python_versions = [3, 36, 1]

# 同时为多个变量赋值
a = b = c = 1

# 同时赋值多个变量
val1, val2, val3 = 1, 'str1', 'zzl'

# 删除变量
del language</code></pre>

<hr>

<h1>Python 变量</h1>

<p>无论是那种编程语言, 都离不开变量.</p>

<p>Python 中的变量有几个特点:</p>

<p>Python 属于动态类型语言, Python 解释器在解释变量时会根据变量的值自动分配合适的内存空间给变量, 因此我们不需要在声明变量时指定变量的类型, 并且一个变量可以被多次赋给不同类型的值. 比如说给一个变量赋值一个整数后, 还可以重新给这个变量赋一个字符串类型的值. 像 Java 这种属于静态类型语言.<br>
Python 属于强类型语言, 因此在不同类型的变量之间做操作时不会做自动转换处理, 比如把一个字符串和一个数字相加, 就会直接提示错误了. 像 PHP, JS 属于弱类型语言. <code>php -r "echo 'abc' + 3;"</code></p>

<p>定义变量时不需要指明变量类型, 并不代表变量没有类型, 只是 Python 自动帮我们确定了变量的类型.</p>

<p><img src="./file//_images/datatype/language_type.png" alt="language type"></p>

<h1>变量命名规则</h1>

<p>差不多跟所有编程语言的变量命名差不多, 都是由一个不包含空格的任意个数的字符序列组成, 包括数字, 字母和下划线, 但是, 不管是哪种编程语言, 变量名都不是可以随便定义的, 需要符合一些标准, Python 也不例外, 定义一个 Python 变量名, 必须要符合下面这2点要求:</p>

<ul>
<li>变量名必须以字母或下划线开头</li>
<li>不能使用 Python 中的关键字作为变量的名字.</li>
</ul>

<p>要是违背了这两条中的任意一条, Python 都会报错退出程序. 比如定义一个以数字开头的变量: <code>9a = 5</code></p>

<p>我忘记在哪听过一句话了, 说只要是不起脑残的变量名, 就没事. 说的其实也挺有道理的, 话糙理不糙.</p>

<p>这里还有一点要注意一下, 就是 Python 中的变量是区分大小写的.</p>

<h2>约定俗成</h2>

<p>这里还有两条定义变量时约定俗成的规定, 虽然不像上面那两条硬性规定那样, 如果不符合规则, Python 会报出语法错误. 但为了代码的健壮性, 在定义变量时, 最好还要符合以下两条规则:</p>

<ul>
<li>不要使用 Python 中预定义好的变量名做为自己的变量名</li>
</ul>

<p>在 Python 中, 有很多的 内置变量 和 函数, 这些内置变量和函数可以方便我们使用 Python. 我们可以用 <code>dir()</code> 函数查看 Python 中的所有内置变量和函数. <code>dir(__builtins__)</code></p>

<p>可以看见这里有一个内置函数 <code>id()</code>, 这个函数的作用是打印出一个对象的 ID 号, 这个 ID 号在整个 Python 脚本的生命周期内是唯一的, 有点类似于 C 语言中指针地址的意思, 但是这个 id 与内存地址不是同一个东西.</p>

<pre class="highlight"><code class="language-python"># 我们可以先通过使用Python的内置函数 type() 来查看 id 的类型
type(id)
# 提示我们是一个内置方法或函数
# 查看整数 1 的 id
id(1)
# 查看字符串 abc 的 id
id('abc')

# 这时候, 如果我们重新定义了一个变量, 变量名就叫 id
id = 500
# 没有出现任何错误信息
# 打印出这个变量的值
id
# 可以看到能够正确打印出我们付给它的值
# 这是在看 id 的类型, 发现 id 已经变成 int 类型了
type(id)
# 再次获取数值 1 的 ID
id(1)
# 这时候就已经报错了, 提示我们int类型不可以被调用
# 说明内置的 id() 函数已经被我们覆盖掉了.</code></pre>

<ul>
<li>还有一点是不要定义以双下划线dunder(__)开头和结尾的变量, 这是因为 Python 中定义一系列有特殊作用的变量和函数, 都是以双下划线开头和结尾的. 为了防止将来Python新增加的特殊作用的变量或函数与自己定义的变量或方法发生冲突, 尽量不要在变量名的前后都加上双下划线.</li>
</ul>

<p>虽然不遵守以上两点规则, Python 并不会给出任何错误提示, 但我们应当尽量避免这种事情发生.</p>

<h1>定义变量</h1>

<p>在 Python 中定义一个变量非常简单, 使用等号来为一个变量赋值, 刚才我们已经提到过了, Python 属于动态类型语言, 所以我们不需要为变量指定任何类型, Python 解释器会自动解释出变量的类型来的. 也不需要像 PHP 或 JS 那样使用特定的一个关键字来告诉 Python 解释器这是一个变量定义语句, 直接使用等号就可以声明一个变量了.</p>

<p>可以使用 <code>type()</code> 查看一个变量的类型.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="00_varaibles" id="_______00_varaibles3" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/00_varaibles:3">
<h1>约定俗成</h1>

<p>以上两条是定于变量名的硬性规定, 如果不符合以上两条规则中的任意一条, 都会导致语法错误.</p>

<p>但定义一个变量一般还需要遵守以下两点约定俗成的规则, 虽然不符合以下两点的变量名不会有任何错误, 但是为了保证代码的健壮性, 尽量都要符合这两点规则:</p>

<ul><li><p>不要使用 Python 中预定义好的变量名或是方法名做为自己的变量名或方法名.</p></li></ul>

<pre class="highlight"><code class="language-python execute"># 查看 Python 中的内置变量和函数
print(dir(__builtins__))</code></pre>

<ul><li><p>不要定义以双下划线dunder(__)开头和结尾的变量.</p></li></ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>特点</h1>

<ul>
<li>C/C++不同, 定义变量时不需要指明变量类型, 并不代表变量没有类型, 只是 Python 自动帮我们确定了变量的类型.</li>
<li>Python 强类型: <code>php -r "echo 'abc' + 3;"</code>
</li>
</ul>

<p><img src="./file//_images/datatype/language_type.png" alt="language type"></p>

<h1>变量命名规则</h1>

<pre class="highlight"><code class="language-python"># 获取Python中的所有关键字
import keyword
print(keyword.kwlist)</code></pre>

<h1>约定俗成</h1>

<pre class="highlight"><code class="language-python"># 可用来查看对象内的属性和方法
dir()
dir(__builtins__)

id(5)
id = 5
id(5)</code></pre>

<h1>语法</h1>

<p>动态类型语言</p>

<pre class="highlight"><code class="language-python"># 字符串`
language = 'Python'

# 查看变量类型
type(language)

# 整数
major_version = 3

# 浮点数型
minor_version = 36.1

# 列表
python_versions = [3, 36, 1]

# 同时为多个变量赋值
a = b = c = 1

# 同时赋值多个变量
val1, val2, val3 = 1, 'str1', 'zzl'

# 删除变量
del language</code></pre>

<hr>

<h1>Python 变量</h1>

<p>无论是那种编程语言, 都离不开变量.</p>

<p>Python 中的变量有几个特点:</p>

<p>Python 属于动态类型语言, Python 解释器在解释变量时会根据变量的值自动分配合适的内存空间给变量, 因此我们不需要在声明变量时指定变量的类型, 并且一个变量可以被多次赋给不同类型的值. 比如说给一个变量赋值一个整数后, 还可以重新给这个变量赋一个字符串类型的值. 像 Java 这种属于静态类型语言.<br>
Python 属于强类型语言, 因此在不同类型的变量之间做操作时不会做自动转换处理, 比如把一个字符串和一个数字相加, 就会直接提示错误了. 像 PHP, JS 属于弱类型语言. <code>php -r "echo 'abc' + 3;"</code></p>

<p>定义变量时不需要指明变量类型, 并不代表变量没有类型, 只是 Python 自动帮我们确定了变量的类型.</p>

<p><img src="./file//_images/datatype/language_type.png" alt="language type"></p>

<h1>变量命名规则</h1>

<p>差不多跟所有编程语言的变量命名差不多, 都是由一个不包含空格的任意个数的字符序列组成, 包括数字, 字母和下划线, 但是, 不管是哪种编程语言, 变量名都不是可以随便定义的, 需要符合一些标准, Python 也不例外, 定义一个 Python 变量名, 必须要符合下面这2点要求:</p>

<ul>
<li>变量名必须以字母或下划线开头</li>
<li>不能使用 Python 中的关键字作为变量的名字.</li>
</ul>

<p>要是违背了这两条中的任意一条, Python 都会报错退出程序. 比如定义一个以数字开头的变量: <code>9a = 5</code></p>

<p>我忘记在哪听过一句话了, 说只要是不起脑残的变量名, 就没事. 说的其实也挺有道理的, 话糙理不糙.</p>

<p>这里还有一点要注意一下, 就是 Python 中的变量是区分大小写的.</p>

<h2>约定俗成</h2>

<p>这里还有两条定义变量时约定俗成的规定, 虽然不像上面那两条硬性规定那样, 如果不符合规则, Python 会报出语法错误. 但为了代码的健壮性, 在定义变量时, 最好还要符合以下两条规则:</p>

<ul>
<li>不要使用 Python 中预定义好的变量名做为自己的变量名</li>
</ul>

<p>在 Python 中, 有很多的 内置变量 和 函数, 这些内置变量和函数可以方便我们使用 Python. 我们可以用 <code>dir()</code> 函数查看 Python 中的所有内置变量和函数. <code>dir(__builtins__)</code></p>

<p>可以看见这里有一个内置函数 <code>id()</code>, 这个函数的作用是打印出一个对象的 ID 号, 这个 ID 号在整个 Python 脚本的生命周期内是唯一的, 有点类似于 C 语言中指针地址的意思, 但是这个 id 与内存地址不是同一个东西.</p>

<pre class="highlight"><code class="language-python"># 我们可以先通过使用Python的内置函数 type() 来查看 id 的类型
type(id)
# 提示我们是一个内置方法或函数
# 查看整数 1 的 id
id(1)
# 查看字符串 abc 的 id
id('abc')

# 这时候, 如果我们重新定义了一个变量, 变量名就叫 id
id = 500
# 没有出现任何错误信息
# 打印出这个变量的值
id
# 可以看到能够正确打印出我们付给它的值
# 这是在看 id 的类型, 发现 id 已经变成 int 类型了
type(id)
# 再次获取数值 1 的 ID
id(1)
# 这时候就已经报错了, 提示我们int类型不可以被调用
# 说明内置的 id() 函数已经被我们覆盖掉了.</code></pre>

<ul>
<li>还有一点是不要定义以双下划线dunder(__)开头和结尾的变量, 这是因为 Python 中定义一系列有特殊作用的变量和函数, 都是以双下划线开头和结尾的. 为了防止将来Python新增加的特殊作用的变量或函数与自己定义的变量或方法发生冲突, 尽量不要在变量名的前后都加上双下划线.</li>
</ul>

<p>虽然不遵守以上两点规则, Python 并不会给出任何错误提示, 但我们应当尽量避免这种事情发生.</p>

<h1>定义变量</h1>

<p>在 Python 中定义一个变量非常简单, 使用等号来为一个变量赋值, 刚才我们已经提到过了, Python 属于动态类型语言, 所以我们不需要为变量指定任何类型, Python 解释器会自动解释出变量的类型来的. 也不需要像 PHP 或 JS 那样使用特定的一个关键字来告诉 Python 解释器这是一个变量定义语句, 直接使用等号就可以声明一个变量了.</p>

<p>可以使用 <code>type()</code> 查看一个变量的类型.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="00_varaibles" id="_______00_varaibles4" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/00_varaibles:4">
<h1>定义变量</h1>

<pre class="highlight"><code class="language-python"># 字符串`
language = 'Python'

# 查看变量类型
type(language)

# 整数
major_version = 3

# 浮点数型
minor_version = 36.1

# 列表
python_versions = [3, 36, 1]

# 同时为多个变量赋值
a = b = c = 1

# 同时赋值多个变量
val1, val2, val3 = 1, 'str1', 'zzl'

# 删除变量
del language</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>特点</h1>

<ul>
<li>C/C++不同, 定义变量时不需要指明变量类型, 并不代表变量没有类型, 只是 Python 自动帮我们确定了变量的类型.</li>
<li>Python 强类型: <code>php -r "echo 'abc' + 3;"</code>
</li>
</ul>

<p><img src="./file//_images/datatype/language_type.png" alt="language type"></p>

<h1>变量命名规则</h1>

<pre class="highlight"><code class="language-python"># 获取Python中的所有关键字
import keyword
print(keyword.kwlist)</code></pre>

<h1>约定俗成</h1>

<pre class="highlight"><code class="language-python"># 可用来查看对象内的属性和方法
dir()
dir(__builtins__)

id(5)
id = 5
id(5)</code></pre>

<h1>语法</h1>

<p>动态类型语言</p>

<pre class="highlight"><code class="language-python"># 字符串`
language = 'Python'

# 查看变量类型
type(language)

# 整数
major_version = 3

# 浮点数型
minor_version = 36.1

# 列表
python_versions = [3, 36, 1]

# 同时为多个变量赋值
a = b = c = 1

# 同时赋值多个变量
val1, val2, val3 = 1, 'str1', 'zzl'

# 删除变量
del language</code></pre>

<hr>

<h1>Python 变量</h1>

<p>无论是那种编程语言, 都离不开变量.</p>

<p>Python 中的变量有几个特点:</p>

<p>Python 属于动态类型语言, Python 解释器在解释变量时会根据变量的值自动分配合适的内存空间给变量, 因此我们不需要在声明变量时指定变量的类型, 并且一个变量可以被多次赋给不同类型的值. 比如说给一个变量赋值一个整数后, 还可以重新给这个变量赋一个字符串类型的值. 像 Java 这种属于静态类型语言.<br>
Python 属于强类型语言, 因此在不同类型的变量之间做操作时不会做自动转换处理, 比如把一个字符串和一个数字相加, 就会直接提示错误了. 像 PHP, JS 属于弱类型语言. <code>php -r "echo 'abc' + 3;"</code></p>

<p>定义变量时不需要指明变量类型, 并不代表变量没有类型, 只是 Python 自动帮我们确定了变量的类型.</p>

<p><img src="./file//_images/datatype/language_type.png" alt="language type"></p>

<h1>变量命名规则</h1>

<p>差不多跟所有编程语言的变量命名差不多, 都是由一个不包含空格的任意个数的字符序列组成, 包括数字, 字母和下划线, 但是, 不管是哪种编程语言, 变量名都不是可以随便定义的, 需要符合一些标准, Python 也不例外, 定义一个 Python 变量名, 必须要符合下面这2点要求:</p>

<ul>
<li>变量名必须以字母或下划线开头</li>
<li>不能使用 Python 中的关键字作为变量的名字.</li>
</ul>

<p>要是违背了这两条中的任意一条, Python 都会报错退出程序. 比如定义一个以数字开头的变量: <code>9a = 5</code></p>

<p>我忘记在哪听过一句话了, 说只要是不起脑残的变量名, 就没事. 说的其实也挺有道理的, 话糙理不糙.</p>

<p>这里还有一点要注意一下, 就是 Python 中的变量是区分大小写的.</p>

<h2>约定俗成</h2>

<p>这里还有两条定义变量时约定俗成的规定, 虽然不像上面那两条硬性规定那样, 如果不符合规则, Python 会报出语法错误. 但为了代码的健壮性, 在定义变量时, 最好还要符合以下两条规则:</p>

<ul>
<li>不要使用 Python 中预定义好的变量名做为自己的变量名</li>
</ul>

<p>在 Python 中, 有很多的 内置变量 和 函数, 这些内置变量和函数可以方便我们使用 Python. 我们可以用 <code>dir()</code> 函数查看 Python 中的所有内置变量和函数. <code>dir(__builtins__)</code></p>

<p>可以看见这里有一个内置函数 <code>id()</code>, 这个函数的作用是打印出一个对象的 ID 号, 这个 ID 号在整个 Python 脚本的生命周期内是唯一的, 有点类似于 C 语言中指针地址的意思, 但是这个 id 与内存地址不是同一个东西.</p>

<pre class="highlight"><code class="language-python"># 我们可以先通过使用Python的内置函数 type() 来查看 id 的类型
type(id)
# 提示我们是一个内置方法或函数
# 查看整数 1 的 id
id(1)
# 查看字符串 abc 的 id
id('abc')

# 这时候, 如果我们重新定义了一个变量, 变量名就叫 id
id = 500
# 没有出现任何错误信息
# 打印出这个变量的值
id
# 可以看到能够正确打印出我们付给它的值
# 这是在看 id 的类型, 发现 id 已经变成 int 类型了
type(id)
# 再次获取数值 1 的 ID
id(1)
# 这时候就已经报错了, 提示我们int类型不可以被调用
# 说明内置的 id() 函数已经被我们覆盖掉了.</code></pre>

<ul>
<li>还有一点是不要定义以双下划线dunder(__)开头和结尾的变量, 这是因为 Python 中定义一系列有特殊作用的变量和函数, 都是以双下划线开头和结尾的. 为了防止将来Python新增加的特殊作用的变量或函数与自己定义的变量或方法发生冲突, 尽量不要在变量名的前后都加上双下划线.</li>
</ul>

<p>虽然不遵守以上两点规则, Python 并不会给出任何错误提示, 但我们应当尽量避免这种事情发生.</p>

<h1>定义变量</h1>

<p>在 Python 中定义一个变量非常简单, 使用等号来为一个变量赋值, 刚才我们已经提到过了, Python 属于动态类型语言, 所以我们不需要为变量指定任何类型, Python 解释器会自动解释出变量的类型来的. 也不需要像 PHP 或 JS 那样使用特定的一个关键字来告诉 Python 解释器这是一个变量定义语句, 直接使用等号就可以声明一个变量了.</p>

<p>可以使用 <code>type()</code> 查看一个变量的类型.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/01_number:1">
<h1>数字类型</h1>

<p>在 Python 中, 数字类型可划分为两类:</p>

<ul>
<li>整型类型

<ul>
<li>布尔类型</li>
</ul>
</li>
<li>浮点数</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number2" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:2">
<h1>整型类型</h1>

<p>在Python中, 整型大小的限制取决于宿主计算机的内存大小. 当数值过大时, Python 会自动分配一块内存来存放该值, 因此在Python中, 很少能出现整型溢出的情况.</p>

<pre class="highlight"><code class="language-python execute">print(100 ** 100)</code></pre>

<h1>定义整型变量</h1>

<ul><li><p>使用数字字面量定义整型类型变量</p></li></ul>

<pre class="highlight"><code class="language-python">int1 = 95</code></pre>

<ul><li><p>使用内置函数 int()</p></li></ul>

<pre class="highlight"><code class="language-python">int2 = int(95)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number3" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:3">
<h1>整型运算</h1>

<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th style="text-align: center">简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>x + y</td>
<td>加</td>
<td style="text-align: center">+=</td>
</tr>
<tr>
<td>x - y</td>
<td>减</td>
<td style="text-align: center">-=</td>
</tr>
<tr>
<td>x * y</td>
<td>乘</td>
<td style="text-align: center">*=</td>
</tr>
<tr>
<td>x / y</td>
<td>除(*)</td>
<td style="text-align: center">/=</td>
</tr>
<tr>
<td>x // y</td>
<td>地板除</td>
<td style="text-align: center">//=</td>
</tr>
<tr>
<td>x % y</td>
<td>模运算</td>
<td style="text-align: center">%=</td>
</tr>
<tr>
<td>x ** y</td>
<td>幂运算</td>
<td style="text-align: center">**=</td>
</tr>
<tr>
<td>-x</td>
<td>负数</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td>+x</td>
<td>正数</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td>abs(x)</td>
<td>绝对值</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td>divmod(x, y)</td>
<td>返回一个元组, 包含 x/y 的商和余数</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td>pow(x, y)</td>
<td>x 的 y 次幂</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>

<p class="callout warning">Python2 中的除法运算为 整数除(地板除), Python3 中的除法默认为 小数除</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number4" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:4">
<h1>Python2 中的 long 整型</h1>

<p>在 Python2 中, 除了 <code>int</code> 类型之外, 还存在 <code>long</code> 类型, 在整数值后面追加 <code>L</code> 或 <code>l</code>(推荐使用大写L, 显示直观), 即可定义一个 <code>long int</code> 类型的变量</p>

<pre class="highlight"><code class="language-python">int_l = 2L
type(int_l)</code></pre>

<p>使用内置函数 <code>long()</code> 创建长整型变量</p>

<pre class="highlight"><code class="language-python">int_l = long()</code></pre>

<p>如果一个 <code>int</code> 类型的值大小超出最大限制, 将会被自动转换成 <code>long</code> 类型</p>

<pre class="highlight"><code class="language-python">import sys
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<p class="callout info">在 Python3 中, 摒弃了 <code>long</code> 类型, 因此在 Python3 中后缀 <code>L</code> 将会导致语法错误, 并且内置函数 <code>long()</code> 也已经不复存在了. 取而代之, 全部使用 <code>int</code> 类型.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number5" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:5">
<h1>整型类型的本质</h1>

<p>在 Python 中, <strong>一切皆对象</strong>, 包括一个整数或一个整数变量</p>

<pre class="highlight"><code class="language-python execute">print(dir(5))</code></pre>

<p>在 Python 中, 数值类型的值为 <strong>只读</strong> 的. 可以通过内置函数 <code>id()</code> 可以获取到 Python 对象的唯一ID.</p>

<p><img src="./file//_images/datatype/val.png" alt="Alt text">
<img src="./file//_images/datatype/val1-2.png" alt="Alt text"></p>

<p class="callout warning">数值类型中 <code>-5 ~ 256</code> 内的数值 Python 会自动为其提前分配好对象.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number6" class="slide" data-transition="none">
<div class="content " ref="基本数据类型/01_number:6">
<h1>整型进制转换</h1>

<p>Python 同样支持数字的不同进制表示形式:
  - 十进制 <code>18</code>, 对应的转换函数 <code>int(N)</code></p>

<ul>
<li><p>二进制 <code>0b10010</code>, 对应的转换函数 <code>bin(N)</code></p></li>
<li><p>八进制 <code>022</code>, 对应的转换函数 <code>oct(N)</code></p></li>
<li><p>十六进制 <code>0x12</code>, 对应的转换函数 <code>hex(N)</code></p></li>
</ul>

<p><img src="./file//_images/datatype/hex.png" alt="Alt text"></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number7" class="slide" data-transition="none">
<div class="content " ref="基本数据类型/01_number:7">
<h1>位运算</h1>

<p>位运算符</p>

<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th style="text-align: center">简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>i | j</td>
<td>或: 只要一个为1, 结果即为1</td>
<td style="text-align: center">|=</td>
</tr>
<tr>
<td><code>i ^ j</code></td>
<td>异或: 相同为0, 不同为1</td>
<td style="text-align: center"><code>^=</code></td>
</tr>
<tr>
<td><code>i &amp; j</code></td>
<td>并且: 全部为1, 值为1, 否则为0</td>
<td style="text-align: center"><code>&amp;=</code></td>
</tr>
<tr>
<td><code>i &lt;&lt; j</code></td>
<td>向左移位:</td>
<td style="text-align: center"><code>&lt;&lt;=</code></td>
</tr>
<tr>
<td><code>i &gt;&gt; j</code></td>
<td>向右移位:</td>
<td style="text-align: center"><code>&gt;&gt;=</code></td>
</tr>
<tr>
<td><code>~i</code></td>
<td>取反: 1-&gt;0, 0-&gt;1</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number8" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:8">
<h1>位运算使用场景</h1>

<p>用途最多就是作为标志位, 如 Linux 权限位.</p>

<ul>
<li>
<code>1</code>: 执行权限</li>
<li>
<code>2</code>: 写权限</li>
<li>
<code>4</code>: 读权限</li>
</ul>

<p><img src="./file//_images/datatype/linux_permission.png" alt="Alt text"></p>

<h2>位运算示例</h2>

<p>打开/关闭 Linux 权限位</p>

<pre><code>  0 1 0 0              0 1 1 0 
| 0 0 1 0  = 4 | 2   &amp; 1 1 0 1  = 4 &amp; ~2
----------           ----------
  0 1 1 0              0 1 0 0
</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number9" class="slide subsection" data-transition="none">
<div class="content subsection" ref="基本数据类型/01_number:9">
<h1>bool型</h1>

<p>布尔类型属于整数类型的一种, 只存在两个值:</p>

<ul>
<li><p><code>True</code>: 一切非0值和非空值, 转换成整数是为 <code>1</code></p></li>
<li><p><code>False</code>: 0 和 空值, 转换成整数时为 <code>0</code></p></li>
</ul>

<p>可以像其它数据类型一样, 调用内置函数 <code>bool()</code> 返回一个布尔对象.</p>

<pre class="highlight"><code class="language-python">bool()       # False
bool(0)      # False
bool('')     # False
bool(-4)     # True
bool('str')  # True</code></pre>

<p>bool 的特殊作用</p>

<pre class="highlight"><code class="language-python">['DL', 'BJ'][True]
['DL', 'BJ'][False]
['DL', 'BJ'][1 &gt; 2]
['DL', 'BJ'][1 &gt; 2]</code></pre>

<p class="callout info">在 Python2 中, <code>True</code> 和 <code>False</code> 是两个内置变量, 可以被手动更改成其他值, 而在 Python3 中, 他们成为了关键字, 不可以在对其进行修改了.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number10" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:10">
<h1>比较关系运算符</h1>

<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>如果左操作数的值大于右操作数的值，则条件成为真.</td>
<td><code>a &gt; b</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>如果左操作数的值大于或等于右操作数的值，则条件成为真.</td>
<td><code>a &gt;= b</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>如果左操作数的值小于右操作数的值，则条件成为真.</td>
<td><code>a &lt; b</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>如果左操作数的值小于或等于右操作数的值，则条件成为真.</td>
<td><code>a &lt;= b</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td>如果两个操作数的值相等，则条件为真.</td>
<td><code>a == b</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>如果两个操作数的值不相等，则条件为真.</td>
<td><code>a != b</code></td>
</tr>
<tr>
<td><code>is</code></td>
<td>如果是同一个对象, 即对象 id 相同, 则条件为真</td>
<td><code>1 is 1</code></td>
</tr>
<tr>
<td><code>is not</code></td>
<td>如果不是同一个对象, 即对象 id 不相同, 则条件为真</td>
<td><code>1 is not 1</code></td>
</tr>
</tbody>
</table>

<p class="callout info">在 Python2 还支持 <code>&lt;&gt;</code> 代表不等于, 在 Python3 中已经取消了这个符号</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>整数类型</h1>

<p>C 不跨平台, 一个原因就是一个整数所能表示的大小在不同的平台上范围是不一样的: x64(8) -&gt; x32(4) 溢出.</p>

<pre class="highlight"><code class="language-python">100 ** 100

# 定义整数
i1 = 95
i2 = int(3)
i3 = int()</code></pre>

<h1>整型运算</h1>

<pre class="highlight"><code class="language-python"># 小数除
print(5 / 3)

# Python2
print(5.0 / 3)

# 地板除
print(5 // 3)

# 绝对值
print(abs(-8))

# 取整(舍掉小数位)
print(int(3.7))

from __future__ import division
print(5 / 3)</code></pre>

<h1>Python2 长整型</h1>

<pre class="highlight"><code class="language-python">l = 5L
type(l)

# 整型最大值
import sys
# 2 ** 63 - 1
sys.maxsize
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<h1>本质</h1>

<pre class="highlight"><code class="language-python">i = -8
dir(i)
dir(-8)

# abs(i)
i.__abs__()</code></pre>

<p>定义一个变量时, Python 创建了一个整型对象, 这个对象的值为 15, 不可变指的是这个对象中的值不可变, 并不是变量的指向.</p>

<pre class="highlight"><code class="language-python">val1 = 15
val2 = 15
val3 = val1
id(val1)
id(val2)
id(val3)
id(15)

val1 = 16
id(val1)
id(16)
id(val2)
id(val3)</code></pre>

<p>这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>进制转换</h1>

<pre class="highlight"><code class="language-python">bin(91) # 0b
oct(91) # 0
hex(91) # 0x: 5 * 16 + 11
int(0b101) # 十进制</code></pre>

<h1>bool</h1>

<pre class="highlight"><code class="language-python">True
False
type(True)
bool(1)
bool()
bool('')
int(True)
int(False)

['dl', 'bj'][0]
['dl', 'bj'][True]</code></pre>

<h1>关系运算符</h1>

<pre class="highlight"><code class="language-python"># python2
1 &lt;&gt; 2
# python3
1 &lt;&gt; 2</code></pre>

<hr>

<h1>整数类型</h1>

<p>我们先介绍一下 Python 中的整数类型, 在 Python 中, 数值类型可以分为两大类, 整数类型和浮点型, 整数类型下面又包括布尔型.</p>

<p>我们先从第一个整数类型开始看.</p>

<p>如果熟悉 C 语言开发的人都知道, C 语言不是跨平台的, 其中一个原因就是: 一个整数所能表示的大小在不同的平台上范围是不一样的, 比如 int 型吧, 在 32 位机器上可能占4个字节, 在64位机器上就占8个字节. 这就有可能导致在 64 位机器上表现正常的数值, 到 32 位的机器上就会溢出了.</p>

<p>但是在 Python 中绝对不会出现这种问题, Python 中存储数字时, 并不会明确指定用多少个字节来存储一个整数, 其实严格来说, Python 也会用默认的字节数来存储一个数值, 但是一旦这个数值过大, 超出默认字节数的范围后, Python 就会自动分配一块更大的内存来存储这个数, 所以在 Python 里, 能存储多大的数, 要取决于计算机里的内存有多大, 按照现在计算机配置来说, 一个正常的程序, 是不可能让 Python 出现整数溢出这种情况的.</p>

<h2>定义整数变量</h2>

<p>定义一个整数变量很简单, 直接使用数字字面量付给一个变量就可以了, 比如 <code>int1 = 95</code>, 或者是使用内置函数 <code>int()</code>, 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 那就一定要支持数学运算符.</p>

<p>地板除 就是取结果的 商 部分.</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 所有的除法都会被转换成浮点数.</p>

<p>通过引入 <code>division[də'vɪʒən]</code>, 自动使用浮点数运算 <code>from __future__ import division</code></p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<p>跟其它编程语言最大的不同就是, 在 Python 中, 一切皆对象, 包括数字和数字变量.<br>
这意味着, 当我们定义了一个整数变量时, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.<br>
首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<p>数值类型的值为只读的.
在 Python 里, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中的 指向整型常量的指针(使用const修饰一个指针: <code>const int * a;</code>) 的意思, 指针指向的地址可以发生变量, 但是指针内存中的内容不可变.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
而十六进制是为了更方便的表示位, 4个位最大可以表示 16(2**4), 所以2个十六进制数正好可以表示8个位, 为一个字节.</p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到底什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 权限位中7是最大的值, 表示读,写和执行的权限都有了. 这个 7 是怎么来的呢?
其实每个权限位都用一个数值来表示:</p>

<ul>
<li>
<code>1</code> 执行全新啊</li>
<li>
<code>2</code> 写权限</li>
<li>
<code>4</code> 读权限</li>
</ul>

<p>这3个权限位分别用一个字节来表示, 第一个字节标志执行权限位, 所以它的值是1, 第二个字节是写权限位, 所以它的值是2, 第三个字节是读权限, 所以它的值就是4了, 当这3个位全部为 1 时, 结果就是7, 就表示3个权限全都有了.</p>

<p>在这里, 其实每个位都表示为一个开关位, 用来表示特殊的含义, 那为啥要用这种方式呢?<br>
如果要是让我们自己开发 Linux 的权限位, 我们的做法估计就是设置3个 bool 型的变量, 如果为真就说明有权限, 否则就没有权限.  三个变量需要占用至少至少3个字节吧, 每个变量用一个字节. 而用这种方式的话, 一个字节就足够了, 所以节省了空间. 还有就是使用 位运算速度是最快的.</p>

<h1>bool 类型</h1>

<p><code>int((True)</code>, <code>int((False)</code></p>

<p><code>val1</code> 和 <code>val2</code> 可以是任何对象, 一个变量, 一个函数或者一个类</p>

<h1>比较关系运算符</h1>

<p>返回 bool 类型的值</p>

<p><code>is</code> 是判断两个对象是不是同一个对象, 判断的是对象的 ID, 我们可以用内置函数 <code>id()</code> 来获取一个对象的 ID.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_float" id="_______02_float1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/02_float:1">
<h1>浮点数</h1>

<p>在Python中, 浮点数用64位来表示的, 与 C 语言中的 double(双精度) 类型一样.</p>

<pre class="highlight"><code class="language-python">f1 = 1.234</code></pre>

<p>使用 <code>float()</code> 内置函数创建浮点数</p>

<pre class="highlight"><code class="language-python">f2 = float(1.234)

# 使用 int() 函数将一个浮点型数值转换成整型
int(3.81)    # 3 直接舍掉小数部分
round(3.81)  # 四舍五入</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>浮点数</h1>

<pre class="highlight"><code class="language-python">f = 1.0
f= 3.56
type(f)

f = float(1)
f = float()

int(3.89)</code></pre>

<h1>浮点数的本质</h1>

<p>我们都知道, 在计算机中, 小数都是不准确的, 都是用近似值表示的. 要理解为什么小数会不准确, 我们首先要知道, 无论是什么类型, 在计算机里都是用 <code>0</code> 跟 <code>1</code> 来表示的, 整数的表示很简单, 如果是带符号整数, 最高以为表示符号位, 因为计算机只能表示 0 和 1 2个数字, 所以底数是2, 指数就是位的位置. 此时每位代表的数值就是2的n次幂, 范围就是 <code>-128~127</code>, 如果是无符号, 范围就是 <code>0~255</code>.</p>

<p>浮点数都是以指数的形式存储的.</p>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>指数位同样有正负, 就是十进制一样, 可以乘以 10 的3次幂, 也可以乘以 10 的-3次幂.<br>
第一位作为符号位 , 除去第一位的指数符号位, 剩余10为用来表示指数大小, 范围为 -2*<em>10 ~ +2</em>*10 - 1</p>

<h1>match 库</h1>

<p>Python 还提供了强大的数学库, 里面提供了可用于各种数学计算公式的函数.</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_float" id="_______02_float2" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_float:2">
<h1>浮点数的本质</h1>

<p>整型在计算机中的存储</p>

<p><img src="./file//_images/datatype/int.png" alt="整型在计算中的存储"></p>

<p>浮点数内存结构图(定点数)</p>

<p><img src="./file//_images/datatype/float.png" alt="浮点数内存结构图"></p>

<p>十进制小数
</p>
<p><code>
123.456 = 1*10<sup>2</sup> + 2*10<sup>1</sup> + 3*10<sup>0</sup> + 4*10<sup>-1</sup> + 5*10<sup>-2</sup> + 6*10<sup>-3</sup> = 1.23456*10<sup>2</sup>
</code></p>


<p>二进制小数</p>

<p></p>
<p><code>
1.01101 = 1*2<sup>0</sup> + 0*2<sup>-1</sup> + 1*2<sup>-2</sup> + 1*2<sup>-3</sup> + 0*2<sup>-4</sup> + 1*2<sup>-5</sup> = 0.25 + 0.125 + 0.03125 = 0.40625
</code></p>

<hr>

<p>指数位示意图</p>

<p><img src="./file//_images/datatype/exponent.png" alt="浮点数内存结构图"></p>

<p>指数(e)转换规则: <code>指数 + 基数</code><br>
其中基数(bias)为: <code>2<sup>k-1</sup> - 1</code><br>
<code>k</code> 为指数位的字节长度, 对于32位浮点数是 8 个字节, 对于 64 为浮点数来说, 是 11 位, 这是由 <code>IEEE</code> 标准规定的.</p>

<p>浮点数转换规则:
<code>
V = (-1)<sup>s</sup> × M × 2<sup>E</sup>
</code>, 
<code>
E = e - bias
</code></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>浮点数</h1>

<pre class="highlight"><code class="language-python">f = 1.0
f= 3.56
type(f)

f = float(1)
f = float()

int(3.89)</code></pre>

<h1>浮点数的本质</h1>

<p>我们都知道, 在计算机中, 小数都是不准确的, 都是用近似值表示的. 要理解为什么小数会不准确, 我们首先要知道, 无论是什么类型, 在计算机里都是用 <code>0</code> 跟 <code>1</code> 来表示的, 整数的表示很简单, 如果是带符号整数, 最高以为表示符号位, 因为计算机只能表示 0 和 1 2个数字, 所以底数是2, 指数就是位的位置. 此时每位代表的数值就是2的n次幂, 范围就是 <code>-128~127</code>, 如果是无符号, 范围就是 <code>0~255</code>.</p>

<p>浮点数都是以指数的形式存储的.</p>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>指数位同样有正负, 就是十进制一样, 可以乘以 10 的3次幂, 也可以乘以 10 的-3次幂.<br>
第一位作为符号位 , 除去第一位的指数符号位, 剩余10为用来表示指数大小, 范围为 -2*<em>10 ~ +2</em>*10 - 1</p>

<h1>match 库</h1>

<p>Python 还提供了强大的数学库, 里面提供了可用于各种数学计算公式的函数.</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_float" id="_______02_float3" class="slide" data-transition="none">
<div class="content " ref="基本数据类型/02_float:3">
<h1>match 库</h1>

<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>math.sin(x)</td>
<td>x 的正弦值</td>
</tr>
<tr>
<td>math.cos(x)</td>
<td>x 的余弦值</td>
</tr>
<tr>
<td>math.tan(x)</td>
<td>x 的正切值</td>
</tr>
<tr>
<td>math.sin(x)</td>
<td>x 的余切值</td>
</tr>
<tr>
<td>math.pi</td>
<td>圆周率 PI</td>
</tr>
<tr>
<td>math.fabs(x)</td>
<td>绝对值</td>
</tr>
<tr>
<td>math.floor(x)</td>
<td>小于 x 的最大整数</td>
</tr>
<tr>
<td>math.ceil(x)</td>
<td>大于 x 的最小整数</td>
</tr>
</tbody>
</table>

<pre class="highlight"><code class="language-python">import math
math.floor(3.81) # 小于3.81的最大整数
3
math.ceil(3.81)  # 大于3.81的最小整数
4</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>浮点数</h1>

<pre class="highlight"><code class="language-python">f = 1.0
f= 3.56
type(f)

f = float(1)
f = float()

int(3.89)</code></pre>

<h1>浮点数的本质</h1>

<p>我们都知道, 在计算机中, 小数都是不准确的, 都是用近似值表示的. 要理解为什么小数会不准确, 我们首先要知道, 无论是什么类型, 在计算机里都是用 <code>0</code> 跟 <code>1</code> 来表示的, 整数的表示很简单, 如果是带符号整数, 最高以为表示符号位, 因为计算机只能表示 0 和 1 2个数字, 所以底数是2, 指数就是位的位置. 此时每位代表的数值就是2的n次幂, 范围就是 <code>-128~127</code>, 如果是无符号, 范围就是 <code>0~255</code>.</p>

<p>浮点数都是以指数的形式存储的.</p>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>指数位同样有正负, 就是十进制一样, 可以乘以 10 的3次幂, 也可以乘以 10 的-3次幂.<br>
第一位作为符号位 , 除去第一位的指数符号位, 剩余10为用来表示指数大小, 范围为 -2*<em>10 ~ +2</em>*10 - 1</p>

<h1>match 库</h1>

<p>Python 还提供了强大的数学库, 里面提供了可用于各种数学计算公式的函数.</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/03_string:1">
<h1>字符串类型</h1>

<p>和数字类型一样, 字符串同样是不可变对象. 为一个变量重新赋值一个新字符串值时, 实际上是创建了一个新的字符串对象, 并将该变量指向这个新创建的字符串对象.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string2" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:2">
<h1>创建字符串对象</h1>

<p>使用字符串字面量值</p>

<pre class="highlight"><code class="language-python execute">s1 = 'string1'
print(s1)</code></pre>

<p>多行字符串</p>

<pre class="highlight"><code class="language-python execute">s2 = 'this \
is \
one \
line'
print(s2)</code></pre>

<p>三引号(triple quoted string)</p>

<pre class="highlight"><code class="language-python execute">s3 = '''This is a multiple lines string.
line2
    line3
'''
print(s3)</code></pre>

<p>括号中的字符串</p>

<pre class="highlight"><code class="language-python execute">s4 = ("This is the nice way to join two long string "
"togeter; it relies on string literal concatenation.")
print(s4)</code></pre>

<p><code>str()</code> 内置函数</p>

<pre class="highlight"><code class="language-python execute">print(str('string'))</code></pre>

<p class="callout info">在 Python 中, 单引号与双引号意义完全相同, 因此上面的示例都可以使用双引号来代替</p>

<h1>字符串相加</h1>

<p>我们可以使用 <code>+</code> 将多个字符串拼接到一起, 形成一个新的字符串.</p>

<pre class="highlight"><code class="language-python execute">a = 's'
b = 'tr'
c = 'ing'
print(a + b + c)</code></pre>

<p class="callout warning">字符串对象与数字对象一样, 属于不可变类型, 当使用 <code>+</code> 拼接多个字符串时, 每遇到一个 <code>+</code> 都将生成一个新的字符串对象, 效率低下.</p>

<p>对字符串做 <code>*</code> 操作</p>

<pre class="highlight"><code class="language-python execute">a = '='
print(a * 10)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string3" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:3">
<h1>Python2 与 Python3 中的字符串</h1>

<p>分别在 Python2 和 Python3 中执行以下代码片段</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

print("你好, 拍森")</code></pre>

<p><a href="http://www.ltg.ed.ac.uk/%7Erichard/utf-8.cgi">utf-8 编码查询</a></p>

<p class="callout info">Python2 默认使用 ASCII 编码, 而 Python3 中使用 UNICODE 作为默认的编码值.</p>

<p>解决办法:</p>

<ul>
<li><code># -*- coding:utf-8 -*-</code></li>
<li><code># -*- coding=utf-8 -*-</code></li>
<li><code># coding=utf-8</code></li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string4" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:4">
<h1>转义字符</h1>

<table>
<thead>
<tr>
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code></td>
<td>转义 \</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>转义 '</td>
</tr>
<tr>
<td><code>\"</code></td>
<td>转义 "</td>
</tr>
<tr>
<td><code>\a</code></td>
<td>ASCII 铃音字符</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>回退字符</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页*</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表(VT)</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车(CR) ，将当前位置移到本行开头(输入的字符会覆盖当前字符)</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
</tr>
<tr>
<td><code>\uhhhh</code></td>
<td>16位的十六进制值</td>
</tr>
<tr>
<td><code>\Uhhhhhhhh</code></td>
<td>32位的十六进制值</td>
</tr>
</tbody>
</table>

<p>引号转义</p>

<pre class="highlight"><code class="language-python">a = "Single 'quotes' are fine; \"doubles\" must be escaped."
b = 'Single quotes must be escaped; "doubles" are fine.'
c = '''both single 'quotes' and double "quotes" are fine.'''</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string5" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:5">
<h1>原始字符串(raw)</h1>

<p>有时候一个字符串中包含了大量需要转义的字符(正则表达式), 可以通过在字符串前加上 <code>r</code> 字符, 来表示这是一个原始字符串, 不要做任何转义.</p>

<pre class="highlight"><code class="language-python execute">print(r"123456\rab")</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string6" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:6">
<h1>字符串比较</h1>

<p>字符串支持像整数类型那样的比较运算符操作, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>, 和 <code>&gt;=</code>.</p>

<p>对比两个字符串时, 字符串将被拆分成一个一个的字符, 字符会被转正对应的数字, 然后对两个字符串中的每个字符进行对比.</p>

<p><img src="./file//_images/datatype/string_com1.png" alt="string_com1.png">
<img src="./file//_images/datatype/string_com2.png" alt="string_com2.png"></p>

<p>Python 中的字符串还支持使用 <code>in</code> 和 <code>not in</code> 关键字判断某一个字符串是否存在指定的字符串中.</p>

<pre class="highlight"><code class="language-python execute">print('ing' in 'string')
print('others' in 'string')
print('others' not in 'string')</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string7" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:7">
<h1>字符串索引</h1>

<p>在 Python 中, 我们可以通过下标索引的方式访问字符串中的某一个字符, 格式为: <code>s[N]</code>, 其中 <code>N</code> 为字符索引位置, 其取值范围 <code>0 &lt;= N &lt; len(s)</code> 或 <code>-1 &lt;= N &lt;= -(len(s))</code>.</p>

<p class="callout info"><code>len() 为Python的内置函数, 可用来获取字符串的长度</code></p>

<p><img src="./file//_images/datatype/string_index.png" alt="string_com2.png"></p>

<pre class="highlight"><code class="language-python execute">s = 'Light ray'
print(s[0])
print(s[-2])</code></pre>

<p class="callout info">如果索引超出字符串范围, 将抛出 <code>IndexError</code> 异常.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string8" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:8">
<h1>字符切片</h1>

<p>切片: 从字符串中提取子字符串片段, 格式为:</p>

<p><code>seq[start:stop:step]</code>, 其中:</p>

<ul>
<li>
<code>start</code>: 表示字符串起始索引位置, 其值可为正, 也可为负, 忽略不写表示从 0 开始</li>
<li>
<code>stop</code> 字符串终止索引位置, 其值可为正, 也可为负, 忽略不写表示到字符串结尾</li>
<li>
<code>step</code> 步长, 其值可为正, 也可为负, 默认为 1</li>
</ul>

<p>最终截取到的字符串为: <code>start &lt;= 片段 &lt; stop</code></p>

<p class="callout info"><code>seq</code> 可以是任何序列对象, 包括后面要讲到的 <code>tuple</code>, <code>list</code> 等等.</p>

<p>切片操作可以作用到字符串的任意一端:</p>

<ul>
<li><p><code>步长为正</code>: 从左至右, <code>start &lt; stop</code></p></li>
<li><p><code>步长为负</code>: 从右至左, <code>start &gt; stop</code></p></li>
</ul>

<h2>字符切片示意图</h2>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string9" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:9">
<h1>字符串方法</h1>

<p>字符串中包含了大量的方法, 熟悉这些方法将有助于我们操作字符串.</p>

<p><code>dir(str)</code> 可以让我们获取到字符串对象中的所有属性和方法.<br>
<code>help(str)</code> 查看字符串类中各个函数的帮助文档.</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.capitalize()</code></td>
<td>返回一个 <code>s</code> 的拷贝字符串对象, 其首字母为大写</td>
</tr>
<tr>
<td><code>s.center(width[, char])</code></td>
<td>返回一个 <code>s</code> 的拷贝字符串, 原字符串居中, 并使用 <code>char</code> (默认空格)填充至长度 <code>width</code>
</td>
</tr>
<tr>
<td><code>s.zfill(w)</code></td>
<td>返回一个 <code>s</code> 的拷贝字符串对象, 如果字符串长度小于 <code>w</code>, 则在字符串前用 <code>0</code> 将其填充至长度 <code>w</code>
</td>
</tr>
<tr>
<td><code>s.ljust(width[, char])</code></td>
<td>返回一个 <code>s</code> 的拷贝字符串对象, 如果字符串长度小于 <code>width</code>, 则在字符串后面用字符 <code>char</code>(默认空格) 将其填充至长度 <code>width</code>
</td>
</tr>
<tr>
<td><code>s.rjust(width[, char])</code></td>
<td>返回一个 <code>s</code> 的拷贝字符串对象, 如果字符串长度小于 <code>width</code>, 则在字符串前面用字符 <code>char</code>(默认空格) 将其填充至长度 <code>width</code>
</td>
</tr>
<tr>
<td><code>s.startswith(x[, start[, end]])</code></td>
<td>如果字符串 <code>s</code> 以 <code>x</code> 开始(或在 <code>start:end</code> 区间, 如果指定这2个参数), 则返回 <code>True</code>
</td>
</tr>
<tr>
<td><code>s.endswith(x[, start[, end]])</code></td>
<td>如果字符串 <code>s</code> 以 <code>x</code> 结尾(或在 <code>start:end</code> 区间, 如果指定这2个参数), 则返回 <code>True</code>
</td>
</tr>
<tr>
<td><code>s.find(t[, start[, end]])</code></td>
<td>按照从左至又的顺序在字符串 <code>s</code> 中搜索 <code>t</code>(或在 <code>start:end</code> 区间, 如果指定这2个参数), 返回找到的第一个字符串的索引位置, 或者返回 <code>-1</code> 如果没找到.</td>
</tr>
<tr>
<td><code>s.rfind(t[, start[, end]])</code></td>
<td>与 <code>find</code> 类似, 只是从最字符串的最右侧开始查找</td>
</tr>
<tr>
<td><code>s.index(t[, start[, end]])</code></td>
<td>与 <code>find</code> 功能类似, 只是如果没有找到 <code>t</code>, 该函数将抛出 <code>ValueError</code> 异常</td>
</tr>
<tr>
<td><code>s.rindex(t[, start[, end]])</code></td>
<td>与 <code>rfind</code> 功能类似, 只是如果没找找到 <code>t</code> , 该函数将抛出 <code>ValueError</code> 异常</td>
</tr>
<tr>
<td><code>s.count(t[, start[, end]])</code></td>
<td>返回字符 <code>t</code> 在字符串 <code>s</code> 中出现的次数, 并且搜索范围在 <code>start:end</code> 之间, 如果指定了这2个参数.</td>
</tr>
<tr>
<td><code>s.isalnum()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 不为空, 并且每个字符都是数字或字母, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.isalpha()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 不为空, 并且每个字符都是字母, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.isidentifier()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 不为空, 并且 <code>s</code> 可以做为一个合法的标识符, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.isspace()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 是由空白字符组成, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.isdigit()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 不为空, 并且每个字符都是 ASCILL 的数值, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.isdecimal()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 不为空, 并且每个字符都是十进制的 unicode 数字字符, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.isnumeric()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 不为空, 并且每个字符都是 Unicode 编码的数值, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.islower()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 中至少包含一个有大小写规则字符, 并且所有有大小写规则的字符全部为小写, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.isupper()</code></td>
<td>返回 <code>True</code> 如果字符串 <code>s</code> 中至少包含一个有大小写规则字符, 并且所有有大小写规则的字符全部为大写, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>s.lower()</code></td>
<td>返回字符串的小写形式</td>
</tr>
<tr>
<td><code>s.upper()</code></td>
<td>返回字符串的小写形式</td>
</tr>
<tr>
<td><code>s.swapcase()</code></td>
<td>将字符串中的小写字母转换成大写, 大写字母转换成小写</td>
</tr>
<tr>
<td><code>s.format(...)</code></td>
<td>格式化</td>
</tr>
<tr>
<td><code>s.join(seq)</code></td>
<td>将序列 <code>seq</code> 里的所有元素都拼接到一起, 并在每个字符串的拼接处添加 <code>s</code>
</td>
</tr>
<tr>
<td><code>s.replace(t, u[, n])</code></td>
<td>将字符串中出现的所有字符 <code>t</code> 替换成字符 <code>u</code>, 最多替换 <code>n</code> 次, 如果指定了 <code>n</code> 参数, 否则全部替换</td>
</tr>
<tr>
<td><code>s.split(t[, n])</code></td>
<td>将字符串按照字符 <code>t</code> 作为分割点切分字符串, 返回一个列表, 最多切割 <code>n</code> 次, 如果指定了 <code>n</code> 参数</td>
</tr>
<tr>
<td><code>s.rsplit(t[, n])</code></td>
<td>与 <code>split()</code> 类似, 但是从右侧开始切割</td>
</tr>
<tr>
<td><code>s.splitlines(f)</code></td>
<td>以换行符为切割点切割字符串</td>
</tr>
<tr>
<td><code>s.lstrip(chars)</code></td>
<td>将字符串左边的空格去掉并返回</td>
</tr>
<tr>
<td><code>s.rstrip(chars)</code></td>
<td>将字符串右边的空格去掉并返回</td>
</tr>
<tr>
<td><code>s.strip(chars)</code></td>
<td>将字符串两边的空格去掉并返回</td>
</tr>
</tbody>
</table>

<p class="callout info">由于字符串是非可变类型, 以上所有涉及修改字符串的函数都将返回一个新的字符串对象.</p>

<p class="callout info"><code>isdecimal()</code> 和 <code>isnumeric()</code> Unicode 类型的字符串才有的方法, Python3 中创建的字符串默认是 Unicode, 而在 Python2 中, 字符串默认是 ASCILL 的, 可以通过在字符串前使用 <code>u</code> 将一个字符串转换成 Unicode, 如: <code>u'abc'</code></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="03_string" id="_______03_string10" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/03_string:10">
<h1>
<code>format()</code> 方法</h1>

<p>format() 方法将字符串中出现的 <code>{}</code> 替换成递给他的参数, 以此来返回一个新的字符串对象.</p>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用索引
data = [4, 8, 15, 16, 23, 42]
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
'{first} {last}'.format(**data)
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math
'math.pi = {0.pi}'.format(math)

element = 'Silver'
number = 47
"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '

# 指定填充字符
'{:_&gt;10}'.format('test')
'______test'
'{:*&lt;10}'.format('test')
# 'test******'

# 居中
'{:^10}'.format('test')
# '   test   '

# 对于填充字符不能正好平均分布到字符串两边的情况, 多出的那个字符将填充在右边
'{:^6}'.format('zip')
# ' zip  '

# 填充数字
'{:4d}'.format(42)
# '  42'

'{:04d}'.format(42)
# '0042'

# 指定填充字符串
'{:*&gt;10d}'.format(3)
# '*********3'</code></pre>

<p>截取</p>

<pre class="highlight"><code class="language-python">'{:.5}'.format('xylophone')
# 'xylop'

# 截取+填充
'{:10.5}'.format('xylophone')
# 'xylop     '

# 使用四舍五入的方式截取小数位数
'{:.9f}'.format(3.141592653589793)
'3.141592654'

'{:06.2f}'.format(3.141592653589793)
# '003.14'</code></pre>

<p>日期时间</p>

<pre class="highlight"><code class="language-python">from datetime import datetime
'{:%Y-%m-%d %H:%M}'.format(datetime(2001, 2, 3, 4, 5))
# '2001-02-03 04:05'</code></pre>

<p>参数形式格式化</p>

<pre class="highlight"><code class="language-python">'{:{align}{width}}'.format('test', align='^', width='10')
# '   test   '
'{:.{prec}} = {:.{prec}f}'.format('Gibberish', 2.7182, prec=3)
# 'Gib = 2.718'

'{:.{prec}} = {:.{prec}f}'.format('Gibberish', 2.7182, prec=3)
'Gib = 2.718'

'{:{width}.{prec}f}'.format(2.7182, width=5, prec=2)
# ' 2.72'

'{:{prec}} = {:{prec}}'.format('Gibberish', 2.7182, prec='.3')
# 'Gib = 2.72'</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>字符串类型</h1>

<pre class="highlight"><code class="language-python">s1 = 'string'
s2 = 'this \
is \
one \
line'
s3 = ''' This is a mutilple lines string.
    Line2
line3

s4 = ('this '
'is '
'one '
'line')

# 注意, 多个字符串相加效率慢
# 没相加一次, 都会生成一个新的对象
's' + 'tr' + 'ing'

'=' * 5</code></pre>

<h1>转义字符, 进度条实现</h1>

<pre class="highlight"><code class="language-python">print('\a') # 铃音
print('abc\b1') # 回退
print('123\rabc') # 回车
print('123\nabc') # 换行</code></pre>

<p>最熟悉的可能就是 <code>\r</code> 和 <code>\n</code> 了, 因为 Linux 和 Windows 下用这两个字符表示换行符.<br>
但是仔细看 \r 描述</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    # -n 进制输出换行符
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''</code></pre>

<p>Python 实现:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<pre class="highlight"><code class="language-python">s = 'Light ray'
s[0]
s[4]
s[-1]
s[15]</code></pre>

<h1>切片</h1>

<p>字符串的切片操作可以让我们获取字符串中的某一段子字符串.</p>

<p>步长为正, 起始位置要小于结束位置, 表示从左到右截取</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he 步长默认为 1
s[:2]     # he
s[13:]    # food
s[::]     # he ate camel food
s[-9:14]  # 'amel f'
s[7:-5]   # camel
s[0:-5:3] # ha m
s[::3]    # ha m d

# 步长为负, 起始位置大于结束位置
# 表示从右向左截取
# 注意, 截取的结构是反顺的.
s[5:2:-1]  # eta
s[-1:2:-2] # do ea t
s[::-1]    # doof lemac eta eh 反转</code></pre>

<h1>字符串方法</h1>

<pre class="highlight"><code class="language-python">s = 'strings are represented by the immutable str data type which holds a sequence of Unicode characters'
s.startswith('string') # True
s.startswith('are', 8) # True 还可以指定要搜索的起始位置
s.endswith('characters') # 判断是否以某个特定的字符串结尾
s.find('data') # 45 查找某个字符串出现的第一个位置
s.find('datas') # 返回 -1 如果没有找到结果
# 还可以使用 in 和 not in 来判断某个字符或字符串是否在一个字符串中
'are' in s
s.upper() # 返回大写形式
s.lower() # 返回小写形式
' '.join('city') # 'c i t y' 每个字符之间使用空格分割, 这可能不是我们想要的结果
' '.join(('city', 'DL')) # 可以传递一个元组, 元组在后面会降到
s.replace('imutabel', 'mutable') # 替换字符串
s.split(' ') # 用空格拆分字符串
' str   '.strip() # 去除两边的空格</code></pre>

<h1>format</h1>

<p>基本用法</p>

<pre class="highlight"><code class="language-python">'{} {}'.format('one', 'two')
# 'one two'
'{} {}'.format(1, 2)
# '1 2'

# 数字
'{:d}'.format(42)
# '42'

# 字符串
'{:s} {:d}'.format('one', 2)
# one 2

# 浮点数
'{:f}'.format(3.141592653589793)
# '3.141593'

# 使用 {{ 输出 一个 {, }} 输出一个 }
"{{{0}}} {1} ;-}}".format("I'm in braces", "I'm not")
# "{I'm in braces} I'm not ;-}"

# 带符号数字 通过前面使用 +, 使输出结果总是打印符号
'{:+d}'.format(42)
# '+42'
'{:+d}'.format(42)
# '-42'</code></pre>

<p>位置参数</p>

<pre class="highlight"><code class="language-python">'{0} {1} {0}'.format('one', 'two')
# 'one two one'

# 同时指定类型
'{0:s} {1:s} {0:s} {2:d}'.format('one', 'two', 3)
# 'one two one 3'</code></pre>

<p>字段名</p>

<pre class="highlight"><code class="language-python">'{who} turned {age} this year'.format(who='She', age=88)
# 'She turned 88 this year'

'The {who} was {0} last week'.format(12, who='boy')
# 'The boy was 12 last week'

# 使用集合数据类型的索引
# 这里的变量data属于Python中的集合类型之一, 列表, 虽然现在还没有讲到, 但是这里所用到的知识非常简单
# 可以把它想象成一个数组, 通过索引的方式来获取其中的元素.
data = [4, 8, 15, 16, 23, 42]
# 分别使用集合 data 中下标索引为4 和 5 的元素替换
'{d[4]} {d[5]}'.format(d=data)
# '23 42'

# 使用键值
# person 是另一种 python 的数据类型, 叫做字典, 存在字典中的每个元素都是以键值对的形式出现的
# 取代前面我们使用的下表索引, 我们可以通过访问字典中的键来获取它对应的值.
person = {'first': 'Jean-Luc', 'last': 'Picard'}
'{p[first]} {p[last]}'.format(p=person)
# 'Jean-Luc Picard'

# 名称占位符
data = {'first': 'Hodor', 'last': 'Hodor!'}
# 在这个例子中, 我们在format的参数前使用了双星号, 它的意思是将字典data中的元素拆分出来, 每个元素的键作为参数名, 值作为参数的值传递给函数, 我们将在后面讲解 函数 的时候在详细讲解.
'{first} {last}'.format(**data) == '{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'
'{first} {last}'.format(first='Hodor', last='Hodor!')
# 'Hodor Hodor!'

# 使用对象的属性
import math # 第一句话, import math 的意思是引入 math 模块, 关于模块的详细信息我们也将在后面讲解.
# 我们可以通过 对象.属性 的方式来访问一个对象中的属性.
# 在这里, 我们将访问 math 对象中的 pi 属性.
# 因为 math 的位置是0, 所以这里我们使用 0.math.
'math.pi = {0.pi}'.format(math)


# 这里用到了 python 的 locals() 内置函数, 
# locals() 中以字典的方式保存了当前所有的局部变量信息, 也就是说这些值将以 键值对 的方式存在.
# 再在前面使用双星号来解压
element = 'Silver'
number = 47
locals() 返回字典

"Element {number} is {element}".format(**locals())
'Element 47 is Silver'</code></pre>

<p>填充</p>

<pre class="highlight"><code class="language-python"># 填充指的是最小长度, 只有字符串的长度小于指定的长时, 才会填充.
# 左填充
'{:&gt;10}'.format('test')
# '      test'

# 右填充
'{:10}'.format('test')
'{:&lt;10}'.format('test')
# 'test      '</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple1" class="slide center incremental subsection" data-transition="none">
<div class="content center incremental subsection" ref="集合类型/00_tuple:1">
<h1>序列</h1>

<p>序列类型是指包含了0个或多个元素的组合, 所有的序列类型都支持以下的功能:</p>

<ul>
<li><p>支持使用成员关系操作符 <code>in</code> 判断是否某个特定成员存在于序列中.</p></li>
<li><p>支持使用 Python 的内置函数 <code>len()</code> 获取序列的长度</p></li>
<li><p>支持使用元素下标索引的方式访问序列中的某一个元素, 如果索引超出序列范围, 则抛出 <code>IndexError</code> 异常</p></li>
<li><p>支持切片操作</p></li>
<li><p>支持使用 <code>+</code> 拼接多个序列, <code>*</code> 重复一个序列</p></li>
</ul>

<p>Python一共提供了五种内置的序列类型: <code>str</code>, <code>tuple</code>, <code>list</code>, <code>bytes</code> 以及 <code>bytearray</code>.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple2" class="slide" data-transition="none">
<div class="content " ref="集合类型/00_tuple:2">
<h1>元组(tuple)</h1>

<p>元组是一个包含0个或多个元素的 <strong>有序</strong> 的不可变组合, 各个元素之间使用逗号( <code>,</code>) 分隔, 其中元组中的元素类型可以是任意的组合. 元组使用 <code>圆括号()</code> 来表示.</p>

<p class="callout warning">元组是一种不可变序列类型, 一旦定义好一个元组后, 任何对其元素进行增加, 修改 或 删除的操作, 都将抛出 <code>TypeError</code> 异常.</p>

<p>示例</p>

<pre class="highlight"><code class="language-python">(1, 2, 3)
('one', 'two', 'three')
(1, 'two', (3, 4))</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple3" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/00_tuple:3">
<h1>创建元组</h1>

<h2>使用内建函数 <code>tuple()</code>
</h2>

<p>可以使用 <code>tuple()</code> 关键字创建一个元组对象. 如果不指定参数, 则创建一个包含 0 个元素的元组.</p>

<pre class="highlight"><code class="language-python execute">t = tuple()
print(t)</code></pre>

<p><code>tuple()</code> 也支持传递一个可迭代的对象作为参数.(所有序列类型都是可迭代对象)</p>

<pre class="highlight"><code class="language-python execute">t = tuple('abc')
print(t)</code></pre>

<h2>直接创建元组对象</h2>

<p>使用 <code>()</code> 直接创建一个元组对象.</p>

<pre class="highlight"><code class="language-python execute"># 在定义元组时, 这里的括号可以忽略不写, 但为了便于阅读, 推荐使用括号.
t = ('venus', -28, 'green', '21', -28, 19.75)
print(t)</code></pre>

<p>因为元组中的元素是任意的, 所以元组中可以包含其他的元组</p>

<pre class="highlight"><code class="language-python execute">t1 = ('venus', -28, 'green', '21', -28, 19.75)
t2 = (1, t1)
print(t2)</code></pre>

<p>当我们使用括号来创建包含多个元素的元组时, 最后一个元素后面的逗号 <code>,</code> 可以忽略不写<br>
但是当元组中只有一个元素时, 元素后面的逗号 <code>,</code> 则不可以忽略</p>

<p>不使用 <code>,</code> 结尾</p>

<pre class="highlight"><code class="language-python execute">t = ('a')
print(t)</code></pre>

<p>使用 <code>,</code> 结尾</p>

<pre class="highlight"><code class="language-python execute">t = ('a',)  # 结尾逗号不能少
print(t)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple4" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/00_tuple:4">
<h1>访问元组中的元素及切片</h1>

<p>与 <code>str</code> 对象一样, 使用 <code>[下标索引]</code> 的方式来访问元组中的元素</p>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]</code></pre>

<p class="callout info">如果索引超出范围, 则抛出 <code>ValueError</code> 异常.</p>

<h1>元组切片</h1>

<p>元组中的切片操作与字符串中的切片操作完全一致</p>

<p><img src="./file//_images/collectiontype/tuple_slicing.png" alt="string_com2.png"></p>

<pre class="highlight"><code class="language-python">t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<p>输出结果</p>

<pre class="highlight"><code class="language-console">('green', '21', -28, 19.75)
('venus', -28)
('venus', -28, 'green', 21, -28, 19.75)
(19.75, -28, '21', 'green', -28, 'venus')</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple5" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/00_tuple:5">
<h1>元组中的函数</h1>

<p>tuple 只有2个函数:</p>

<ul>
<li>
<code>t.count(x)</code> 返回对象 <code>x</code> 在元组中出现的次数</li>
<li>
<code>t.index(x)</code> 返回对象 <code>x</code> 在元组中第一次出现的下标索引.</li>
</ul>

<h2>元组的其他操作</h2>

<p>使用 <code>len()</code> 获取元组的长度</p>

<pre class="highlight"><code class="language-python">len(t)</code></pre>

<p>使用 <code>+</code> 来拼接多个元组来生成一个新的元组对象(只能是元组相加)</p>

<pre class="highlight"><code class="language-python execute">hair = "black", "brown", "blonde", "red"
# 返回一个包含了 `yellow` 元素的新元组, 注意逗号
print(hair + ('yellow',))</code></pre>

<p>使用 <code>*</code> 来重复元组多次</p>

<pre class="highlight"><code class="language-python execute">t = (1, 2) * 3
print(t)</code></pre>

<p>使用 <code>in</code> 或 <code>not in</code> 检测某个元素是否存在元组中</p>

<pre class="highlight"><code class="language-python execute">hair = ("black", "brown", "blonde", "red")
print('black' in hair)
print('yellow' in hair)
print('yellow' not in hair)</code></pre>

<p>使用 for in 迭代序列对象</p>

<pre class="highlight"><code class="language-python execute">hair = ("black", "brown", "blonde", "red")
for col in hair:
    print(col)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple6" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/00_tuple:6">
<h1>解压元组</h1>

<p>将元组中的元素一次解压到变量中</p>

<pre class="highlight"><code class="language-python execute">first, last = ('Jims', 'Smith')
print(first)
print(last)</code></pre>

<p>与 <code>for...in</code> 合用</p>

<pre class="highlight"><code class="language-python execute">for x, y in ((1,1), (2,4), (3,9)):
    print(x, y)</code></pre>

<p>Python3中的新功能</p>

<pre class="highlight"><code class="language-python">tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple7" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="集合类型/00_tuple:7">
<h1>命名元组</h1>

<p>命名元组与元组一样, 也是元组, 唯一不同的是: 我们可以通过为元组中的每个元素定义一个唯一的名字, 通过这些名字来访问元组中的元素.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple8" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/00_tuple:8">
<h1>定义命名元组</h1>

<p>要使用一个命名元组, 必须要先引入 <code>collections</code> 库中的 <code>namedtuple()</code> 方法, 通过调用该方法创建一个新的命名元组对象(类).</p>

<p><code>collections.namedtuple()</code> 方法接收两个参数:</p>

<ul>
<li>第一个参数 Sale 是我们想要创建的自定义命名元组类型的名字</li>
<li>第二个参数是使用空格或逗号分隔的一个字符串, 代表了每个元素对应的名字</li>
</ul>

<p>创建一个自定义的命名元组类对象</p>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>一旦我们创建好了一个新的命名元组对象, 就可以通过实例化该类来创建一个新的实例. 实例中才是存放真正数据的地方.</p>

<pre class="highlight"><code class="language-python">s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_tuple" id="_____00_tuple9" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/00_tuple:9">
<h1>访问命名元组中的属性</h1>

<p>因为命名元组是一个类对象, 我们需要使用 <code>.</code> 来访问类中的属性.</p>

<pre class="highlight"><code class="language-python">s1.productid
s2.date</code></pre>

<p><code>_fields</code> 命名元组中的特殊属性, 一个包含了所有自定义元素名字的元组.</p>

<pre class="highlight"><code class="language-python">print(s1._fields)</code></pre>

<p><code>_asdict()</code> 返回一个字典对象, 以键值对的形式返回对应的值</p>

<pre class="highlight"><code class="language-python">dir_val = s1._asdict()
print(dir_val['customerid'])</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>序列</h1>

<p>整型, 浮点型, 布尔型都只有一个值, 不属于.<br>
但是字符串是, 包含了多个字符. <code>s = 'str'</code> 由 3 个字符组成.</p>

<ul>
<li>向前面提到过, 可以用 <code>in</code> 和 <code>not in</code> 判断字符串</li>
<li>
<code>len(str)</code>, 注意调用方式, 跟之前使用string方法不太一样, 内置函数. string 方法是string类的方法</li>
</ul>

<h1>元组</h1>

<pre class="highlight"><code class="language-python">()
type(())
(1, 2, 3)
(1, 'two', 3)
# 包含另一个元组的元组
(1, 'two', (3, 'three'))

# 最后一个元素可以加逗号, 也可以不加
# 只有一个元素时, 必须加
type((1))
type((1,))

# 也可以不使用括号
a = 1, 2, 'three'
type(a)
# 只有一个元素时, 后面必须有逗号
a = 1,</code></pre>

<h1>访问元素</h1>

<pre class="highlight"><code class="language-python">t = (1, 2, ('venus', -28, 'green', '21', -28, 19.75), 'STG', 'SWG')
t[1]
t[-2]
t[2][2]

t = ('venus', -28, 'green', '21', -28, 19.75)
t[2:]
t[:2]
t[::]
t[::-1]</code></pre>

<h1>元组中的函数</h1>

<pre class="highlight"><code class="language-python">help(tuple)

t = ('venus', -28, 'green', 21, -28, 19.75)
t.count(-28)
t.index('green')

# 获取长度
len(t)

# 相加
(1,) + (2, 3)

# 相乘
(1,) * 5

21 in t
21 not in t</code></pre>

<h1>解压元组</h1>

<pre class="highlight"><code class="language-python"># 还记得刚才讲变量时的一个赋值语句么
val1, val2, val3 = 1, 'str1', 'str2'
# 右边其实就是一个元组
val1, val2, val3 = (1, 'str1', 'str2')

first, last = ('Jims', 'Smith')
first
last
# 使用这种方式时, 左右必须一一对应

# 在Python3中的新增加了一项功能, 可以使用 `*` 来代替剩余元素.
tup_str = ('str1', 'str2', 'str3', 'str4')
str1, str2, *str3 = tup_str
str1, *str2, str3 = tup_str</code></pre>

<h1>命名元组</h1>

<p>元组只能通过索引来访问, 可以使用 Python 的扩展功能创建一个命名元组, 它可以让我们通过名字来访问元组中的元素. 访问数据库时, 将列明作为命名元组.</p>

<pre class="highlight"><code class="language-python"># 使用前先要定义一个命名元组类型
import collections
# 第一个参数类名
# 其实就是创建一个名字为 Sale 的类, 并把这个类赋值给了 Sale 变量
# 列名
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")
# 查看
dir()
dir(Sale)
help(Sale)
# namedtuple 实际上就是一个类工厂函数
# 通过我们传递的参数创建新类

# 创建命名元组实例
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(date='2017-01-01', productid=432, customerid=921, quantity=3, price=7.99)

# 访问
s1.productid
s2.date

# 返回一个元组, 包含了所有元素名
s1._fields

# 获取一个列表
s1._asdict()</code></pre>

<hr>

<h1>什么是可迭代对象</h1>

<p>简单来说, 在 Python 中, 所有可直接作用到 <code>for</code> 循环上的对象, 都是可迭代对象</p>

<p>在讲解字符串的时候, 我们提到了 <code>in</code> 关键字, 用 <code>for...in</code> 结构可以循环迭代一个可迭代对象, 如:</p>

<pre class="highlight"><code class="language-python">for c in a:
    print(c)</code></pre>

<p>所有的序列类型都是可迭代对象, 字符串也是可迭代对象.</p>

<pre class="highlight"><code class="language-python">t.count(-28)
t.index(-28)</code></pre>

<h1>切片</h1>

<pre class="highlight"><code class="language-python">eyes = ('brown', 'hazel', 'amber', 'green', 'blue', 'gray')
hair = ("black", "brown", "blonde", "red")
colors = (hair, eyes)
colors[1][3:-1]</code></pre>

<h1>解压元组</h1>

<p>解压元组中的元素时, 赋值左边的变量个数一定不能大于元组中元素的个数, 否则会报出错误, 如果变量数小于元组中的个数, 没有对应的元组中的元素将被忽略掉.</p>

<p>在Python3中的新增加了一项功能, 可以使用 <code>*</code> 来代替剩余元素.</p>

<h1>定义命名元组</h1>

<pre class="highlight"><code class="language-python">import collections
Sale = collections.namedtuple("Sale", "productid customerid date quantity price")</code></pre>

<p>在这个例子中, 我们创建了一个新的类 <code>Sale</code>, 它的类型为命名元组, 当我们通过 <code>type(Sale)</code> 来查看它的类型时, 会发现它是一个 <code>class</code>, 其实我们之前讲解的所有类型, 都是 class 对象. <code>type(1)</code>, <code>type(1,2)</code>, <code>type('abc')</code>, <code>type(())</code>, 并且可以使用 <code>help()</code> 查看他们的帮助文档.</p>

<p><code>help(Sale)</code> 获取帮助信息, 会发现它是一个类, 并且我们传递给 <code>namedtuple</code> 的第二个参数中的每个元素都成为了该类中的一个属性, 该类继承与 <code>tuple</code>, 所以也存在 <code>count()</code> 和 <code>index()</code> 两个方法</p>

<pre class="highlight"><code class="language-python"># 此处的 Sale 是上面赋值语句左边的变量 Sale
s1 = Sale(432, 921, "2017-01-01", 3, 7.99)
s2 = Sale(productid=432, customerid=921, date='2017-01-01', quantity=3, price=7.99)</code></pre>

<p>在查询数据库表时, 为每个表创建一个命名元组, 使用命名元组对应数据库表中的条目</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="01_list" id="_____01_list1" class="slide" data-transition="none">
<div class="content " ref="集合类型/01_list:1">
<h1>列表(list)</h1>

<p>列表是一个包含0个或多个元素的有序组合, 各个元素之间使用逗号<code>,</code> 分隔, 其中元组中的元素类型可以是任意的组合. 元组使用 <code>中括号[]</code> 来表示.</p>

<p>与元组不同, 列表中的元素是可以任意修改的.</p>

<h1>创建列表</h1>

<p>使用内置函数 list()</p>

<pre class="highlight"><code class="language-python">L = list()
L = list('abc')</code></pre>

<p>使用 [] 直接创建一个列表对象.</p>

<pre class="highlight"><code class="language-python">L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>列表赋值引用</h1>

<pre class="highlight"><code class="language-python"># 创建列表
# 跟元组类似, 只是使用中括号来表示
[]
[1, 2, 3, 'four']
list()
# 接收一个参数, 这个参数必须是一个序列类型的
# 将指定的序列类型转换成列表
list('abc')
list([1, 2, 3])

# 访问元素, 从 0 开始计算
L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]
L[0]
L[-2][1]

# 切片
L[2:4]
L[-3:]

# 修改元素
L[2] = 50
# 同时修改多个值
# 通过切片修改时, 值必须是一个序列
L[2:4] = 1, 2, 3 # 元组
# 删除
L[2:6] = []
# 通过切片插入单个值数据
# 在第一个元素位置前插入值
# 值同样需要是一个列表
L[:0] = [0]
# 在结尾追加值
# 注意最后的逗号
L[-1:-1] = 'latest',
L[2:2] = 49, # 在指定位置处插入值

# 获取长度
len(L)

# 相加
[1, 2] + [3]
# 乘法, 表示重复多少次
[1] * 5
# 跟元组不同,
# 在列表中, 如果只有一个元素, 最后元素的逗号是可以不写的</code></pre>

<h1>列表方法</h1>

<pre class="highlight"><code class="language-python"># 获取帮助文档
help(list)

l = [1, 2]
# 还可以使用 append 向末尾追加元素
# 等同于 l[-1:-1] = [3]
l.append(3)

# 接收一个序列类型作为参数
# 将序列中的元素全部追击到的 l 中
l.extend((4, 5, 6))
l.extend('abc')

# 在指定的元素 前 追加元素
l.insert(0, 0)

# 搜索第一次出现的索引位置
# 如果没有搜索到, 则抛出 ValueError 异常
l.index('a')

# 查找元素 a 出现的次数
l.count('a')

# 移除最后一个元素, 并返回它的值
l.pop()
# 删除指定的元素
l.pop(7)

# 删除第一个找到的元素并删除
# 抛出 ValueError 如果没有找到
l.remove('a')

# 清空, 等同于 l[:] = []
l.clear()</code></pre>

<h1>变量引用</h1>

<pre class="highlight"><code class="language-python"># 看一个例子
l1 = [1, 2, 3]
l2 = l1
l1[0] = 'a'

查看 l1 和 l2
l1
l2

# 解决方案
# 使用 copy
l2 = l1.copy()
# 或
l2 = l1[:]
# 或
l2 = list(l1)</code></pre>

<h2>列表中的 <code>+</code> 和 <code>+=</code>
</h2>

<pre class="highlight"><code class="language-python">l1 = [1, 2, 3]
l2 = l1
# 1: 使用 +
l1 = l1 + [4, 5]
# l2 并没有发生任何变化
l1
l2
id(l1)
id(l2)
# 说明重新创建了一个对象

# 2: 使用 +=
l1 = [1, 2, 3]
l2 = l1
id(l1)
id(l2)</code></pre>

<h1>迭代</h1>

<p>循环序列是最常用的操作之一了. 循环一个序列特别简单, 我们可以使用 <code>for...in</code> 格式来循环一个序列. 固定格式.</p>

<pre class="highlight"><code class="language-python">for i in 'abc':
    print(i)</code></pre>

<p>循环时同时获取索引</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for i in range(len(l)):
    print('{} -&gt; {}'.format(i, l[i]))</code></pre>

<h1>enumerate</h1>

<p>所有序列都是可迭代对象</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for idx, item in enumerate(l):
    print('{} -&gt; {}'.format(idx, item))</code></pre>

<p>迭代同时删除元素</p>

<pre class="highlight"><code class="language-python">list = [1, 2, 3, 4]
for idx, item in enumerate(list):
    list.remove(item)

list # [2, 4]
# 删除第一个元素 1 时, list 结果为 [2, 3, 4]
# 删除第二个元素, 此时第二个元素为 3</code></pre>

<h1>range()</h1>

<pre class="highlight"><code class="language-python"># 2 是列表
# 3 是迭代器
# 列表与迭代器的区别就是
# 列表在定义时将所有元素都保存到了内存中
# 如果生成一个包含有大量元素的列表
# 将浪费很多内存空间
# 而迭代器每次只会将当前处理的元素保存到内存中
# 所以它的空间复杂度永远是 1
l = range(5)

# 2 提供的 xrange 函数
l = xrange(5)

# 还可以通过索引访问里面的元素
l[0]
l[-1]

# 最常用的用法就是和循环一起使用
for i in range(5):
    print(i)</code></pre>

<h1>列表推导式</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们需要创建包含大量元素, 或是需要动态生成列表时, 一般的选择是使用 for 循环语句
# 使用 for 循环创建列表
temp = []
for item in range(0, 100):
    temp.append(item)

print(temp)

# 但是使用列表推导式, 只需要一行即可. 注意是中括号 []
temp2 = [item for item in range(0, 100)]
print(temp2)

# 还可以使用条件表达式
temp3 = [item for item in range(0, 100) if item % 2 == 0]
print(temp3)</code></pre>

<p>9*9 乘法表</p>

<pre class="highlight"><code class="language-python">for i in range(1, 10):
    for j in range(1, i+1):
        print('{} '.format(i * j), end='')
    print()

# 嵌套循环
[i * j for i in range(1, 10) for j in range(1, i + 1)]</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="01_list" id="_____01_list2" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/01_list:2">
<h1>列表常用操作</h1>

<p>可以像元组那样通过下表索引访问元组中的元素</p>

<pre class="highlight"><code class="language-python">print(L[2])
print(L[4][1])</code></pre>

<p>列表切片</p>

<p><img src="./file//_images/collectiontype/list_slicing.png" alt="string_com2.png"></p>

<pre class="highlight"><code class="language-python">L[0] == L[-6] == -17.5
L[1] == L[-5] == 'kilo'
L[1][0] == L[-5][0] == 'k'
L[4][2] == L[4][-1] == L[-2][2] == L[-2][-1] == 'echo'
L[4][2][1] == L[4][2][-3] == L[-2][-1][1] == L[-2][-1][-3] == 'C'</code></pre>

<p>修改列表元素</p>

<pre class="highlight"><code class="language-python">L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]

L[1] = 15.4

L[2:4] = 1, 2, 3, 4

L[2:4] = []

L[:0] = [0]

L[-1:-1] = 'latest',

l[1:1] = 'secondly',</code></pre>

<p>使用 <code>len()</code> 获取列表的长度</p>

<pre class="highlight"><code class="language-python execute">L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]
print(len(L))</code></pre>

<p>使用 <code>+</code> 来拼接多个列表来生成一个新的列表对象</p>

<pre class="highlight"><code class="language-python execute">print(['a', 'b', 'c'] + ['d'])</code></pre>

<p>使用 <code>*</code> 来重复列表多次</p>

<pre class="highlight"><code class="language-python execute">t = [1, 2] * 3
print(t)</code></pre>

<p>使用 <code>in</code> 或 <code>not in</code> 检测某个元素是否存在元组中</p>

<pre class="highlight"><code class="language-python execute">hair = ["black", "brown", "blonde", "red"]
print('black' in hair)
print('yellow' in hair)
print('yellow' not in hair)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>列表赋值引用</h1>

<pre class="highlight"><code class="language-python"># 创建列表
# 跟元组类似, 只是使用中括号来表示
[]
[1, 2, 3, 'four']
list()
# 接收一个参数, 这个参数必须是一个序列类型的
# 将指定的序列类型转换成列表
list('abc')
list([1, 2, 3])

# 访问元素, 从 0 开始计算
L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]
L[0]
L[-2][1]

# 切片
L[2:4]
L[-3:]

# 修改元素
L[2] = 50
# 同时修改多个值
# 通过切片修改时, 值必须是一个序列
L[2:4] = 1, 2, 3 # 元组
# 删除
L[2:6] = []
# 通过切片插入单个值数据
# 在第一个元素位置前插入值
# 值同样需要是一个列表
L[:0] = [0]
# 在结尾追加值
# 注意最后的逗号
L[-1:-1] = 'latest',
L[2:2] = 49, # 在指定位置处插入值

# 获取长度
len(L)

# 相加
[1, 2] + [3]
# 乘法, 表示重复多少次
[1] * 5
# 跟元组不同,
# 在列表中, 如果只有一个元素, 最后元素的逗号是可以不写的</code></pre>

<h1>列表方法</h1>

<pre class="highlight"><code class="language-python"># 获取帮助文档
help(list)

l = [1, 2]
# 还可以使用 append 向末尾追加元素
# 等同于 l[-1:-1] = [3]
l.append(3)

# 接收一个序列类型作为参数
# 将序列中的元素全部追击到的 l 中
l.extend((4, 5, 6))
l.extend('abc')

# 在指定的元素 前 追加元素
l.insert(0, 0)

# 搜索第一次出现的索引位置
# 如果没有搜索到, 则抛出 ValueError 异常
l.index('a')

# 查找元素 a 出现的次数
l.count('a')

# 移除最后一个元素, 并返回它的值
l.pop()
# 删除指定的元素
l.pop(7)

# 删除第一个找到的元素并删除
# 抛出 ValueError 如果没有找到
l.remove('a')

# 清空, 等同于 l[:] = []
l.clear()</code></pre>

<h1>变量引用</h1>

<pre class="highlight"><code class="language-python"># 看一个例子
l1 = [1, 2, 3]
l2 = l1
l1[0] = 'a'

查看 l1 和 l2
l1
l2

# 解决方案
# 使用 copy
l2 = l1.copy()
# 或
l2 = l1[:]
# 或
l2 = list(l1)</code></pre>

<h2>列表中的 <code>+</code> 和 <code>+=</code>
</h2>

<pre class="highlight"><code class="language-python">l1 = [1, 2, 3]
l2 = l1
# 1: 使用 +
l1 = l1 + [4, 5]
# l2 并没有发生任何变化
l1
l2
id(l1)
id(l2)
# 说明重新创建了一个对象

# 2: 使用 +=
l1 = [1, 2, 3]
l2 = l1
id(l1)
id(l2)</code></pre>

<h1>迭代</h1>

<p>循环序列是最常用的操作之一了. 循环一个序列特别简单, 我们可以使用 <code>for...in</code> 格式来循环一个序列. 固定格式.</p>

<pre class="highlight"><code class="language-python">for i in 'abc':
    print(i)</code></pre>

<p>循环时同时获取索引</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for i in range(len(l)):
    print('{} -&gt; {}'.format(i, l[i]))</code></pre>

<h1>enumerate</h1>

<p>所有序列都是可迭代对象</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for idx, item in enumerate(l):
    print('{} -&gt; {}'.format(idx, item))</code></pre>

<p>迭代同时删除元素</p>

<pre class="highlight"><code class="language-python">list = [1, 2, 3, 4]
for idx, item in enumerate(list):
    list.remove(item)

list # [2, 4]
# 删除第一个元素 1 时, list 结果为 [2, 3, 4]
# 删除第二个元素, 此时第二个元素为 3</code></pre>

<h1>range()</h1>

<pre class="highlight"><code class="language-python"># 2 是列表
# 3 是迭代器
# 列表与迭代器的区别就是
# 列表在定义时将所有元素都保存到了内存中
# 如果生成一个包含有大量元素的列表
# 将浪费很多内存空间
# 而迭代器每次只会将当前处理的元素保存到内存中
# 所以它的空间复杂度永远是 1
l = range(5)

# 2 提供的 xrange 函数
l = xrange(5)

# 还可以通过索引访问里面的元素
l[0]
l[-1]

# 最常用的用法就是和循环一起使用
for i in range(5):
    print(i)</code></pre>

<h1>列表推导式</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们需要创建包含大量元素, 或是需要动态生成列表时, 一般的选择是使用 for 循环语句
# 使用 for 循环创建列表
temp = []
for item in range(0, 100):
    temp.append(item)

print(temp)

# 但是使用列表推导式, 只需要一行即可. 注意是中括号 []
temp2 = [item for item in range(0, 100)]
print(temp2)

# 还可以使用条件表达式
temp3 = [item for item in range(0, 100) if item % 2 == 0]
print(temp3)</code></pre>

<p>9*9 乘法表</p>

<pre class="highlight"><code class="language-python">for i in range(1, 10):
    for j in range(1, i+1):
        print('{} '.format(i * j), end='')
    print()

# 嵌套循环
[i * j for i in range(1, 10) for j in range(1, i + 1)]</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="01_list" id="_____01_list3" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/01_list:3">
<h1>列表方法</h1>

<p>Python 的列表提供了多个方法</p>

<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>L.append(x)</code></td>
<td>将元素 <code>x</code> 追加到列表尾部</td>
</tr>
<tr>
<td><code>L.extend(m)</code></td>
<td>将可迭代对象 <code>m</code> 中的所有元素追加到列表的尾部, 与 <code>+=</code> 效果相同</td>
</tr>
<tr>
<td><code>L.index(x[, start[, end]])</code></td>
<td>从列表的左侧开始搜索元素 <code>X</code> 出现的第一次的索引位置, 如果没有找到, 则抛出 <code>ValueError</code> 异常</td>
</tr>
<tr>
<td><code>L.insert(i, x)</code></td>
<td>将对象 <code>x</code> 插入到索引 <code>i</code> 之前</td>
</tr>
<tr>
<td><code>L.pop()</code></td>
<td>移除最右边的一个元素, 并返回移除的元素</td>
</tr>
<tr>
<td><code>L.pop(i)</code></td>
<td>移除并返回下标所有为 <code>i</code> 的元素</td>
</tr>
<tr>
<td><code>L.remove(x)</code></td>
<td>从列表的最左侧开始移除第一个 <code>x</code> 元素, 如果元素 <code>x</code> 不存在, 则抛出 <code>ValueError</code> 异常</td>
</tr>
<tr>
<td><code>L.clear()</code></td>
<td>移除所有元素</td>
</tr>
<tr>
<td><code>L.count(x)</code></td>
<td>返回元素 <code>x</code> 在列表中出现的次数</td>
</tr>
<tr>
<td><code>L.copy()</code></td>
<td></td>
</tr>
<tr>
<td><code>L.reverse()</code></td>
<td>反转列表中的所有元素(子列表并不会被翻转)</td>
</tr>
<tr>
<td><code>L.sort()</code></td>
<td></td>
</tr>
</tbody>
</table>

<p class="callout warning">列表里的所有方法都直接作用于列表本身.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>列表赋值引用</h1>

<pre class="highlight"><code class="language-python"># 创建列表
# 跟元组类似, 只是使用中括号来表示
[]
[1, 2, 3, 'four']
list()
# 接收一个参数, 这个参数必须是一个序列类型的
# 将指定的序列类型转换成列表
list('abc')
list([1, 2, 3])

# 访问元素, 从 0 开始计算
L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]
L[0]
L[-2][1]

# 切片
L[2:4]
L[-3:]

# 修改元素
L[2] = 50
# 同时修改多个值
# 通过切片修改时, 值必须是一个序列
L[2:4] = 1, 2, 3 # 元组
# 删除
L[2:6] = []
# 通过切片插入单个值数据
# 在第一个元素位置前插入值
# 值同样需要是一个列表
L[:0] = [0]
# 在结尾追加值
# 注意最后的逗号
L[-1:-1] = 'latest',
L[2:2] = 49, # 在指定位置处插入值

# 获取长度
len(L)

# 相加
[1, 2] + [3]
# 乘法, 表示重复多少次
[1] * 5
# 跟元组不同,
# 在列表中, 如果只有一个元素, 最后元素的逗号是可以不写的</code></pre>

<h1>列表方法</h1>

<pre class="highlight"><code class="language-python"># 获取帮助文档
help(list)

l = [1, 2]
# 还可以使用 append 向末尾追加元素
# 等同于 l[-1:-1] = [3]
l.append(3)

# 接收一个序列类型作为参数
# 将序列中的元素全部追击到的 l 中
l.extend((4, 5, 6))
l.extend('abc')

# 在指定的元素 前 追加元素
l.insert(0, 0)

# 搜索第一次出现的索引位置
# 如果没有搜索到, 则抛出 ValueError 异常
l.index('a')

# 查找元素 a 出现的次数
l.count('a')

# 移除最后一个元素, 并返回它的值
l.pop()
# 删除指定的元素
l.pop(7)

# 删除第一个找到的元素并删除
# 抛出 ValueError 如果没有找到
l.remove('a')

# 清空, 等同于 l[:] = []
l.clear()</code></pre>

<h1>变量引用</h1>

<pre class="highlight"><code class="language-python"># 看一个例子
l1 = [1, 2, 3]
l2 = l1
l1[0] = 'a'

查看 l1 和 l2
l1
l2

# 解决方案
# 使用 copy
l2 = l1.copy()
# 或
l2 = l1[:]
# 或
l2 = list(l1)</code></pre>

<h2>列表中的 <code>+</code> 和 <code>+=</code>
</h2>

<pre class="highlight"><code class="language-python">l1 = [1, 2, 3]
l2 = l1
# 1: 使用 +
l1 = l1 + [4, 5]
# l2 并没有发生任何变化
l1
l2
id(l1)
id(l2)
# 说明重新创建了一个对象

# 2: 使用 +=
l1 = [1, 2, 3]
l2 = l1
id(l1)
id(l2)</code></pre>

<h1>迭代</h1>

<p>循环序列是最常用的操作之一了. 循环一个序列特别简单, 我们可以使用 <code>for...in</code> 格式来循环一个序列. 固定格式.</p>

<pre class="highlight"><code class="language-python">for i in 'abc':
    print(i)</code></pre>

<p>循环时同时获取索引</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for i in range(len(l)):
    print('{} -&gt; {}'.format(i, l[i]))</code></pre>

<h1>enumerate</h1>

<p>所有序列都是可迭代对象</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for idx, item in enumerate(l):
    print('{} -&gt; {}'.format(idx, item))</code></pre>

<p>迭代同时删除元素</p>

<pre class="highlight"><code class="language-python">list = [1, 2, 3, 4]
for idx, item in enumerate(list):
    list.remove(item)

list # [2, 4]
# 删除第一个元素 1 时, list 结果为 [2, 3, 4]
# 删除第二个元素, 此时第二个元素为 3</code></pre>

<h1>range()</h1>

<pre class="highlight"><code class="language-python"># 2 是列表
# 3 是迭代器
# 列表与迭代器的区别就是
# 列表在定义时将所有元素都保存到了内存中
# 如果生成一个包含有大量元素的列表
# 将浪费很多内存空间
# 而迭代器每次只会将当前处理的元素保存到内存中
# 所以它的空间复杂度永远是 1
l = range(5)

# 2 提供的 xrange 函数
l = xrange(5)

# 还可以通过索引访问里面的元素
l[0]
l[-1]

# 最常用的用法就是和循环一起使用
for i in range(5):
    print(i)</code></pre>

<h1>列表推导式</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们需要创建包含大量元素, 或是需要动态生成列表时, 一般的选择是使用 for 循环语句
# 使用 for 循环创建列表
temp = []
for item in range(0, 100):
    temp.append(item)

print(temp)

# 但是使用列表推导式, 只需要一行即可. 注意是中括号 []
temp2 = [item for item in range(0, 100)]
print(temp2)

# 还可以使用条件表达式
temp3 = [item for item in range(0, 100) if item % 2 == 0]
print(temp3)</code></pre>

<p>9*9 乘法表</p>

<pre class="highlight"><code class="language-python">for i in range(1, 10):
    for j in range(1, i+1):
        print('{} '.format(i * j), end='')
    print()

# 嵌套循环
[i * j for i in range(1, 10) for j in range(1, i + 1)]</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="01_list" id="_____01_list4" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/01_list:4">
<h1>列表变量的引用</h1>

<p><img src="./file//_images/collectiontype/list_reference.png" alt="list_reference.png"></p>

<p>L1 与 L2 引用同一个列表对象, 通过任何一个变量对这个列表对象作出的修改, 都会反映到另一个变量上.</p>

<h2>创建新对象</h2>

<ul>
<li>
<code>[:]</code> 通过使用切片形式, 将会创建一个新的一模一样的列表对象.</li>
<li>
<code>copy()</code> 通过使用列表的 <code>copy</code> 函数创建一个新的列表对象</li>
<li>
<code>list()</code> 通过使用 <code>list</code> 函数创建一个新的列表</li>
</ul>

<p><img src="./file//_images/collectiontype/list_reference_copy.png" alt="list_reference.png"></p>

<h2>列表中的 <code>+</code> 和 <code>+=</code>
</h2>

<ul>
<li>对列表使用 <code>+</code> 会重新定义一个新对象</li>
<li>对列表使用 <code>+=</code> 则直接修改源里表</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>列表赋值引用</h1>

<pre class="highlight"><code class="language-python"># 创建列表
# 跟元组类似, 只是使用中括号来表示
[]
[1, 2, 3, 'four']
list()
# 接收一个参数, 这个参数必须是一个序列类型的
# 将指定的序列类型转换成列表
list('abc')
list([1, 2, 3])

# 访问元素, 从 0 开始计算
L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]
L[0]
L[-2][1]

# 切片
L[2:4]
L[-3:]

# 修改元素
L[2] = 50
# 同时修改多个值
# 通过切片修改时, 值必须是一个序列
L[2:4] = 1, 2, 3 # 元组
# 删除
L[2:6] = []
# 通过切片插入单个值数据
# 在第一个元素位置前插入值
# 值同样需要是一个列表
L[:0] = [0]
# 在结尾追加值
# 注意最后的逗号
L[-1:-1] = 'latest',
L[2:2] = 49, # 在指定位置处插入值

# 获取长度
len(L)

# 相加
[1, 2] + [3]
# 乘法, 表示重复多少次
[1] * 5
# 跟元组不同,
# 在列表中, 如果只有一个元素, 最后元素的逗号是可以不写的</code></pre>

<h1>列表方法</h1>

<pre class="highlight"><code class="language-python"># 获取帮助文档
help(list)

l = [1, 2]
# 还可以使用 append 向末尾追加元素
# 等同于 l[-1:-1] = [3]
l.append(3)

# 接收一个序列类型作为参数
# 将序列中的元素全部追击到的 l 中
l.extend((4, 5, 6))
l.extend('abc')

# 在指定的元素 前 追加元素
l.insert(0, 0)

# 搜索第一次出现的索引位置
# 如果没有搜索到, 则抛出 ValueError 异常
l.index('a')

# 查找元素 a 出现的次数
l.count('a')

# 移除最后一个元素, 并返回它的值
l.pop()
# 删除指定的元素
l.pop(7)

# 删除第一个找到的元素并删除
# 抛出 ValueError 如果没有找到
l.remove('a')

# 清空, 等同于 l[:] = []
l.clear()</code></pre>

<h1>变量引用</h1>

<pre class="highlight"><code class="language-python"># 看一个例子
l1 = [1, 2, 3]
l2 = l1
l1[0] = 'a'

查看 l1 和 l2
l1
l2

# 解决方案
# 使用 copy
l2 = l1.copy()
# 或
l2 = l1[:]
# 或
l2 = list(l1)</code></pre>

<h2>列表中的 <code>+</code> 和 <code>+=</code>
</h2>

<pre class="highlight"><code class="language-python">l1 = [1, 2, 3]
l2 = l1
# 1: 使用 +
l1 = l1 + [4, 5]
# l2 并没有发生任何变化
l1
l2
id(l1)
id(l2)
# 说明重新创建了一个对象

# 2: 使用 +=
l1 = [1, 2, 3]
l2 = l1
id(l1)
id(l2)</code></pre>

<h1>迭代</h1>

<p>循环序列是最常用的操作之一了. 循环一个序列特别简单, 我们可以使用 <code>for...in</code> 格式来循环一个序列. 固定格式.</p>

<pre class="highlight"><code class="language-python">for i in 'abc':
    print(i)</code></pre>

<p>循环时同时获取索引</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for i in range(len(l)):
    print('{} -&gt; {}'.format(i, l[i]))</code></pre>

<h1>enumerate</h1>

<p>所有序列都是可迭代对象</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for idx, item in enumerate(l):
    print('{} -&gt; {}'.format(idx, item))</code></pre>

<p>迭代同时删除元素</p>

<pre class="highlight"><code class="language-python">list = [1, 2, 3, 4]
for idx, item in enumerate(list):
    list.remove(item)

list # [2, 4]
# 删除第一个元素 1 时, list 结果为 [2, 3, 4]
# 删除第二个元素, 此时第二个元素为 3</code></pre>

<h1>range()</h1>

<pre class="highlight"><code class="language-python"># 2 是列表
# 3 是迭代器
# 列表与迭代器的区别就是
# 列表在定义时将所有元素都保存到了内存中
# 如果生成一个包含有大量元素的列表
# 将浪费很多内存空间
# 而迭代器每次只会将当前处理的元素保存到内存中
# 所以它的空间复杂度永远是 1
l = range(5)

# 2 提供的 xrange 函数
l = xrange(5)

# 还可以通过索引访问里面的元素
l[0]
l[-1]

# 最常用的用法就是和循环一起使用
for i in range(5):
    print(i)</code></pre>

<h1>列表推导式</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们需要创建包含大量元素, 或是需要动态生成列表时, 一般的选择是使用 for 循环语句
# 使用 for 循环创建列表
temp = []
for item in range(0, 100):
    temp.append(item)

print(temp)

# 但是使用列表推导式, 只需要一行即可. 注意是中括号 []
temp2 = [item for item in range(0, 100)]
print(temp2)

# 还可以使用条件表达式
temp3 = [item for item in range(0, 100) if item % 2 == 0]
print(temp3)</code></pre>

<p>9*9 乘法表</p>

<pre class="highlight"><code class="language-python">for i in range(1, 10):
    for j in range(1, i+1):
        print('{} '.format(i * j), end='')
    print()

# 嵌套循环
[i * j for i in range(1, 10) for j in range(1, i + 1)]</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="01_list" id="_____01_list5" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/01_list:5">
<h1>迭代序列类型</h1>

<p>使用 <code>for...in</code> 迭代序列对象</p>

<pre class="highlight"><code class="language-python execute">hair = ["black", "brown", "blonde", "red"]
for col in hair:
    print(col)</code></pre>

<h2><code>enumerate</code></h2>

<p>通过对一个可迭代对象使用内置函数 <code>enumerate()</code>, 可返回一个 <code>enumerate</code> 对象, 通过迭代 <code>enumerate</code> 对象, 可以直接获取迭代序列的索引和元素.</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for idx, item in enumerate(l):
    print('{} -&gt; {}'.format(idx, item))</code></pre>

<p class="callout warning">不要再迭代序列的同时尝试删除其中的元素.</p>

<h1><code>range()</code></h1>

<p><code>range()</code> 函数返回一个由整数组成的 列表(Python2) 或是一个 迭代器(Python3)</p>

<p>在 Python2 中我们也可以使用 <code>xrange()</code> 返回一个迭代器</p>

<p>格式:</p>

<p><code>range([start], stop[, step])</code></p>

<p>示例:</p>

<pre class="highlight"><code class="language-python">for i in range(5):
    print(i)</code></pre>

<p class="callout waning">Python3 中移除了 <code>xrang()</code>, 而 <code>rang()</code> 被修改成了返回一个可迭代对象, 而在不是一个元组了.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>列表赋值引用</h1>

<pre class="highlight"><code class="language-python"># 创建列表
# 跟元组类似, 只是使用中括号来表示
[]
[1, 2, 3, 'four']
list()
# 接收一个参数, 这个参数必须是一个序列类型的
# 将指定的序列类型转换成列表
list('abc')
list([1, 2, 3])

# 访问元素, 从 0 开始计算
L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]
L[0]
L[-2][1]

# 切片
L[2:4]
L[-3:]

# 修改元素
L[2] = 50
# 同时修改多个值
# 通过切片修改时, 值必须是一个序列
L[2:4] = 1, 2, 3 # 元组
# 删除
L[2:6] = []
# 通过切片插入单个值数据
# 在第一个元素位置前插入值
# 值同样需要是一个列表
L[:0] = [0]
# 在结尾追加值
# 注意最后的逗号
L[-1:-1] = 'latest',
L[2:2] = 49, # 在指定位置处插入值

# 获取长度
len(L)

# 相加
[1, 2] + [3]
# 乘法, 表示重复多少次
[1] * 5
# 跟元组不同,
# 在列表中, 如果只有一个元素, 最后元素的逗号是可以不写的</code></pre>

<h1>列表方法</h1>

<pre class="highlight"><code class="language-python"># 获取帮助文档
help(list)

l = [1, 2]
# 还可以使用 append 向末尾追加元素
# 等同于 l[-1:-1] = [3]
l.append(3)

# 接收一个序列类型作为参数
# 将序列中的元素全部追击到的 l 中
l.extend((4, 5, 6))
l.extend('abc')

# 在指定的元素 前 追加元素
l.insert(0, 0)

# 搜索第一次出现的索引位置
# 如果没有搜索到, 则抛出 ValueError 异常
l.index('a')

# 查找元素 a 出现的次数
l.count('a')

# 移除最后一个元素, 并返回它的值
l.pop()
# 删除指定的元素
l.pop(7)

# 删除第一个找到的元素并删除
# 抛出 ValueError 如果没有找到
l.remove('a')

# 清空, 等同于 l[:] = []
l.clear()</code></pre>

<h1>变量引用</h1>

<pre class="highlight"><code class="language-python"># 看一个例子
l1 = [1, 2, 3]
l2 = l1
l1[0] = 'a'

查看 l1 和 l2
l1
l2

# 解决方案
# 使用 copy
l2 = l1.copy()
# 或
l2 = l1[:]
# 或
l2 = list(l1)</code></pre>

<h2>列表中的 <code>+</code> 和 <code>+=</code>
</h2>

<pre class="highlight"><code class="language-python">l1 = [1, 2, 3]
l2 = l1
# 1: 使用 +
l1 = l1 + [4, 5]
# l2 并没有发生任何变化
l1
l2
id(l1)
id(l2)
# 说明重新创建了一个对象

# 2: 使用 +=
l1 = [1, 2, 3]
l2 = l1
id(l1)
id(l2)</code></pre>

<h1>迭代</h1>

<p>循环序列是最常用的操作之一了. 循环一个序列特别简单, 我们可以使用 <code>for...in</code> 格式来循环一个序列. 固定格式.</p>

<pre class="highlight"><code class="language-python">for i in 'abc':
    print(i)</code></pre>

<p>循环时同时获取索引</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for i in range(len(l)):
    print('{} -&gt; {}'.format(i, l[i]))</code></pre>

<h1>enumerate</h1>

<p>所有序列都是可迭代对象</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for idx, item in enumerate(l):
    print('{} -&gt; {}'.format(idx, item))</code></pre>

<p>迭代同时删除元素</p>

<pre class="highlight"><code class="language-python">list = [1, 2, 3, 4]
for idx, item in enumerate(list):
    list.remove(item)

list # [2, 4]
# 删除第一个元素 1 时, list 结果为 [2, 3, 4]
# 删除第二个元素, 此时第二个元素为 3</code></pre>

<h1>range()</h1>

<pre class="highlight"><code class="language-python"># 2 是列表
# 3 是迭代器
# 列表与迭代器的区别就是
# 列表在定义时将所有元素都保存到了内存中
# 如果生成一个包含有大量元素的列表
# 将浪费很多内存空间
# 而迭代器每次只会将当前处理的元素保存到内存中
# 所以它的空间复杂度永远是 1
l = range(5)

# 2 提供的 xrange 函数
l = xrange(5)

# 还可以通过索引访问里面的元素
l[0]
l[-1]

# 最常用的用法就是和循环一起使用
for i in range(5):
    print(i)</code></pre>

<h1>列表推导式</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们需要创建包含大量元素, 或是需要动态生成列表时, 一般的选择是使用 for 循环语句
# 使用 for 循环创建列表
temp = []
for item in range(0, 100):
    temp.append(item)

print(temp)

# 但是使用列表推导式, 只需要一行即可. 注意是中括号 []
temp2 = [item for item in range(0, 100)]
print(temp2)

# 还可以使用条件表达式
temp3 = [item for item in range(0, 100) if item % 2 == 0]
print(temp3)</code></pre>

<p>9*9 乘法表</p>

<pre class="highlight"><code class="language-python">for i in range(1, 10):
    for j in range(1, i+1):
        print('{} '.format(i * j), end='')
    print()

# 嵌套循环
[i * j for i in range(1, 10) for j in range(1, i + 1)]</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="01_list" id="_____01_list6" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/01_list:6">
<h1>列表推导式</h1>

<p>列表推导式是另一种可以快速生成列表的方式, 其语法简洁易懂.</p>

<p>列表推导式支持两种格式:</p>

<ul>
<li><code>[expression for item in iterable]</code></li>
<li><code>[expression for item in iterable if condition]</code></li>
</ul>

<p>示例:</p>

<pre class="highlight"><code class="language-python">temp = [i for i in range(100)]

temp = [i for i in range(100) if i % 2 == 0]</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>列表赋值引用</h1>

<pre class="highlight"><code class="language-python"># 创建列表
# 跟元组类似, 只是使用中括号来表示
[]
[1, 2, 3, 'four']
list()
# 接收一个参数, 这个参数必须是一个序列类型的
# 将指定的序列类型转换成列表
list('abc')
list([1, 2, 3])

# 访问元素, 从 0 开始计算
L = [-17.5, "kilo", 49, "V", ["ram", 5, "echo"], 7]
L[0]
L[-2][1]

# 切片
L[2:4]
L[-3:]

# 修改元素
L[2] = 50
# 同时修改多个值
# 通过切片修改时, 值必须是一个序列
L[2:4] = 1, 2, 3 # 元组
# 删除
L[2:6] = []
# 通过切片插入单个值数据
# 在第一个元素位置前插入值
# 值同样需要是一个列表
L[:0] = [0]
# 在结尾追加值
# 注意最后的逗号
L[-1:-1] = 'latest',
L[2:2] = 49, # 在指定位置处插入值

# 获取长度
len(L)

# 相加
[1, 2] + [3]
# 乘法, 表示重复多少次
[1] * 5
# 跟元组不同,
# 在列表中, 如果只有一个元素, 最后元素的逗号是可以不写的</code></pre>

<h1>列表方法</h1>

<pre class="highlight"><code class="language-python"># 获取帮助文档
help(list)

l = [1, 2]
# 还可以使用 append 向末尾追加元素
# 等同于 l[-1:-1] = [3]
l.append(3)

# 接收一个序列类型作为参数
# 将序列中的元素全部追击到的 l 中
l.extend((4, 5, 6))
l.extend('abc')

# 在指定的元素 前 追加元素
l.insert(0, 0)

# 搜索第一次出现的索引位置
# 如果没有搜索到, 则抛出 ValueError 异常
l.index('a')

# 查找元素 a 出现的次数
l.count('a')

# 移除最后一个元素, 并返回它的值
l.pop()
# 删除指定的元素
l.pop(7)

# 删除第一个找到的元素并删除
# 抛出 ValueError 如果没有找到
l.remove('a')

# 清空, 等同于 l[:] = []
l.clear()</code></pre>

<h1>变量引用</h1>

<pre class="highlight"><code class="language-python"># 看一个例子
l1 = [1, 2, 3]
l2 = l1
l1[0] = 'a'

查看 l1 和 l2
l1
l2

# 解决方案
# 使用 copy
l2 = l1.copy()
# 或
l2 = l1[:]
# 或
l2 = list(l1)</code></pre>

<h2>列表中的 <code>+</code> 和 <code>+=</code>
</h2>

<pre class="highlight"><code class="language-python">l1 = [1, 2, 3]
l2 = l1
# 1: 使用 +
l1 = l1 + [4, 5]
# l2 并没有发生任何变化
l1
l2
id(l1)
id(l2)
# 说明重新创建了一个对象

# 2: 使用 +=
l1 = [1, 2, 3]
l2 = l1
id(l1)
id(l2)</code></pre>

<h1>迭代</h1>

<p>循环序列是最常用的操作之一了. 循环一个序列特别简单, 我们可以使用 <code>for...in</code> 格式来循环一个序列. 固定格式.</p>

<pre class="highlight"><code class="language-python">for i in 'abc':
    print(i)</code></pre>

<p>循环时同时获取索引</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for i in range(len(l)):
    print('{} -&gt; {}'.format(i, l[i]))</code></pre>

<h1>enumerate</h1>

<p>所有序列都是可迭代对象</p>

<pre class="highlight"><code class="language-python">l = [1, 2, 3, 4]
for idx, item in enumerate(l):
    print('{} -&gt; {}'.format(idx, item))</code></pre>

<p>迭代同时删除元素</p>

<pre class="highlight"><code class="language-python">list = [1, 2, 3, 4]
for idx, item in enumerate(list):
    list.remove(item)

list # [2, 4]
# 删除第一个元素 1 时, list 结果为 [2, 3, 4]
# 删除第二个元素, 此时第二个元素为 3</code></pre>

<h1>range()</h1>

<pre class="highlight"><code class="language-python"># 2 是列表
# 3 是迭代器
# 列表与迭代器的区别就是
# 列表在定义时将所有元素都保存到了内存中
# 如果生成一个包含有大量元素的列表
# 将浪费很多内存空间
# 而迭代器每次只会将当前处理的元素保存到内存中
# 所以它的空间复杂度永远是 1
l = range(5)

# 2 提供的 xrange 函数
l = xrange(5)

# 还可以通过索引访问里面的元素
l[0]
l[-1]

# 最常用的用法就是和循环一起使用
for i in range(5):
    print(i)</code></pre>

<h1>列表推导式</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们需要创建包含大量元素, 或是需要动态生成列表时, 一般的选择是使用 for 循环语句
# 使用 for 循环创建列表
temp = []
for item in range(0, 100):
    temp.append(item)

print(temp)

# 但是使用列表推导式, 只需要一行即可. 注意是中括号 []
temp2 = [item for item in range(0, 100)]
print(temp2)

# 还可以使用条件表达式
temp3 = [item for item in range(0, 100) if item % 2 == 0]
print(temp3)</code></pre>

<p>9*9 乘法表</p>

<pre class="highlight"><code class="language-python">for i in range(1, 10):
    for j in range(1, i+1):
        print('{} '.format(i * j), end='')
    print()

# 嵌套循环
[i * j for i in range(1, 10) for j in range(1, i + 1)]</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="03_dictionary" id="_____03_dictionary1" class="slide" data-transition="none">
<div class="content " ref="集合类型/03_dictionary:1">
<h1>字典(dict)</h1>

<p>字典的定义使用大括号 <code>{}</code>, 其中元素以 <code>键:值</code> 的形式存在.</p>

<p>与元组和列表不同, 字典是非顺序的, 这意味着字典中元素的位置是不可确定的, 可能与我们创建字典是指定的顺序或插入的顺序不符.</p>

<p>字典中的键可以是任何可序列化的对象, 可序列可以化简单理解为任何其值为不可变的对象, 比如: 数字, 字符串, 元组等都是可序列化对象.</p>

<p>字典对应的内置函数为 <code>dict()</code></p>

<pre class="highlight"><code class="language-python">d1 = dict()

d2 = dict(id=1948, name="Washer", size=3)

d3 = dict(d2)

d4 = dict([['id', 1948], ('name', 'Washer'), ('size', 3)])

d5 = {"root": 17, 'blue': [75, 'R', 2], 21:'venus', -14:None, 'mars':'rover', (4,11):18, 0:45}</code></pre>

<h2><code>zip()</code></h2>

<p>可将传递给他的可迭代对象参数按顺序依次解压, 将每个参数中相同位置的元组合并成一个元组, 最终返回一个可迭代的 <code>zip</code> 类, 通过 循环 或内置函数 <code>next</code> 依次读取这些元组.</p>

<pre class="highlight"><code class="language-python">z = zip(('id', 'name', 'size'), (1948, 'Washer', 3))
next(z)

for i in z:
    print(z)

# 通过 zip 创建字典对象
d4 = dict(zip(('id', 'name', 'size'), (1948, 'Washer', 3)))</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>创建</h1>

<p>前面讲的都是通过索引获取元素中的值, 虽然使用命名元组可以为元素定义名字, 但它并不是元组特有的属性, 而且不是很方便</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 返回一个空字典
d1 = dict()
print("d1", d1)

# 传递参数
d2 = dict(id=1948, name="Washer", size=3)
# 这里注意字典打印的顺序, 与我们给定的顺序是不同的
print("d2", d2)

# 传递另一个字典作为参数
d3 = dict(d2)
print("d3", d3)

# 传递一个可迭代对象, 可以是一个元组, 也可以是一个列表
# 迭代对象中每个元素又是另一个包含2个元素的可迭代对象, 元素0-&gt;key, 元素 1-&gt;value
d5 = dict([['id', 1948], ('name', 'Washer'), ('size', 3)])
print("d5:", d5)

# 也可以直接通过 大括号 创建字典
d = {'a': 1, 'b': 2}
# 在看一个例子
d = {"root": 17, 'blue': [75, 'R', 2], 21:'venus', -14:None, 'mars':'rover', (4,11):18, 0:45}
# 字典中的键可以是任何可哈希(hash)的对象, 可哈希对象简单理解就是其值不可改变的对象, 数字, 字符串, 元组就是可可哈希的对象
# 可以使用内置函数 `hash()` 判断一个对象是否是可哈希的
# hash((1, 2, 3))
# hash((1, 2, [3, 4])) 包含列表, 不可哈希
# 字典中的键值要保证是唯一的, 否则后面出现的键将会覆盖前面先出现的键

# 迭代字典中的元素
for i in d:
    # 每次迭代返回是键
    print(i)
    # 同时获取 键 和 值
    print('{}-&gt;{}'.format(i, d[i]))</code></pre>

<h2>zip</h2>

<pre class="highlight"><code class="language-python"># 使用 zip
# zip 是Python的一个内置函数
# 他接收任意个可迭代对象作为参数
# 它返回一个迭代器
z = zip('abc', (1, 2, 3))
for i in z:
    print(i)

d4 = dict(zip(('id', 'name', 'size'), (1948, 'Washer', 3)))
print("d4:", d4)

a1 = (1, 2, 3)
a2 = (4, 5, 6)
a3 = ('a', 'b', 'c')
# 增加2个元素的元组, 结果每个元组中都包含2个元素
a4 = ('x', 'y')
a = zip(a1, a2, a3, a4)
print(a)

# 生成字典
d = {}
b1 = ('a', 'b', 'c')
b2 = (1, 2, 3)
for key, val in zip(b1, b2):
    d[key] = val
print(d)</code></pre>

<h2>访问字典元素</h2>

<pre class="highlight"><code class="language-python"># 通过键值获取元素
d['root']
d['blue']
d[-14]
d[(4,11)]
# 当访问一个不存在的键时, 会抛出 KeyError 异常
#  d['x']

# 新曾元素, 因为字典是非顺序的, 所以新增的元素不一定会被追加到字典的结尾
d['x'] = 59
d

# 可以像之前讲解变量时那样, 使用 del 删除字典中的一个元素
del d['x']
d

# 我们可以使用内置函数 len() 来获取字典的长度
len(d)</code></pre>

<h1>字典方法</h1>

<pre class="highlight"><code class="language-python">d = {'user': 'Smith', 'address': ['USA', 'Littleton'], 'Level': 10, 'size': 15}

################ get() ################
# 上面提到我们可以通过键名直接获取字典中的元素
# 还可以使用 字典的 get() 方法获取
d.get('user')
# 上面提到了, 当访问一个不存在的键时, 会抛出 KeyError 异常.
# 但是返回 None ,如果 xxx 不存在
d['users'] # 报错 KeyError 异常
d.get('users', 'NULL') # 返回 NULL 字符串

# 还可以指定第二个参数
# 返回给定的值 `XXX` 如果 key `xxx` 不存在
d.get('users', 'users')

################ pop() ################
# 返回字典中键k对应的值, 并将该键从字典中移除
# 如果字典中不存在键 k, 则抛出 KeyError 异常
d.pop('user')
d.pop('user') # 报错
d.pop('user', 'NULL') # 返回 NULL 字符串

################ popitem() ################
# 从字典中删除随意一个键值对, 并返回被删除的键值对
d.popitem()
# 当对一个空的字典进行 popitem() 操作时, 将会抛出 `KeyError` 异常
d.popitem()

################ setdefault() ################
# 它的作用首先是返回指定键的值
# 如果不存在该键, 则向该字典中插入值为 `v` 的键 `k`, 并返回值 `v`
d.setdefault('user', 'Smith')
d.setdefault('address', ['USA', 'Littleton'])
d
# 如果没有指定第二个参数, 则默认插入 None

################ update() ################
# 更新字典, 该方法接收三种形式的参数:
# 传递另一个字典
d.update({'size': 18, 'age': 36})
print(d)

# 或是一个可迭代对象
# 每次迭代返回的都是一个包含两个元素的对象分别作为 key 和 value; 或是向该函数传递关键字参数
# 传递一个元组
d.update((('first', 'Smith'), ('last', 'Keven')))
# 也可以将参数保存到一个变量中
t = (('first', 'Smith'), ('last', 'Keven'), ('id', 1234567))
d.update(t)

# 或是通过指定一个参数名字和值的方式
d.update(company='IBM', department='BTIT')

################ clear() ################
# 清空字典
d.clear()

################ copy() ################
d1 = {'a':1, 'b':2}
d2 = d1
d1['a'] = 0
d1
d2

d2 = d1.copy()
id(d1)
id(d2)
# 或
d2 = dict(d1)</code></pre>

<h1>字典视图</h1>

<pre class="highlight"><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}

d_k = d.keys()
d_v = d.values()
d_i = d.items()
d_k
d_v
d_i

d.setdefault('d', 4)
d
d_k
d_v
d_i

# 因为 items 返回的是一个列表
# 并且每个元素都是一个有 key 和 value 组成的元组
# 索引我们可以直接循环它来获取 key 和 value
for item, val in d.items():
    print('{} : {}'.format(item, val))

# `items()`, `keys()` 与 `values()` 函数返回的结构都是从源字典中的拷贝出来的, 如果被操作的字典包含大量元素, 这将会导致内存的大量浪费, 相应的, 我们可以使用 `iteritems()`, `iterkeys()` 和 `itervalues()`, 这些函数返回一个可迭代对象, 可以对这些可迭代对象进行 `for` 循环获取其中的内容, 在循环可迭代对象时, 之后当前被处理的元素才会被保存到内存当中, 当处理完成以后, 就会从内存当中删除.
# 在 Python3 中, 对 `items()`, `keys()` 与 `values()` 这3个函数进行了重新处理, 他们全部返回 字典视图(directory view) 对象, 并且移除了 `iteritems()`, `iterkeys()` 和 `itervalues()` 函数.</code></pre>

<h1>字典推导式</h1>

<p>前面讲解列表时, 我们讲过了 列表推导式, 字典同样也存在推导式-&gt; 字典推导式</p>

<pre class="highlight"><code class="language-python">import os

# 列出当前文件所在目录下的所有文件的大小
# os.listdir() 返回指定目录下的文件列表
# os.path.isfile 判断是否是文件
file_size = {name: os.path.getsize(name) for name in os.listdir('.') if os.path.isfile(name)}
print(file_size)</code></pre>

<h1>default dictionary</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们访问一个字典中不存在的 键 时, 会抛出 KeyError 异常.
# 这是正确的行为, 因为我们需要知道这个键不存在某个字典中

# 但有些时候我们希望当键不存在时, 可以自动将这个键添加进去, 虽然上面我们提及了字典的 `setdefault()` 方法可以帮助我们达到这一目的.
# 但使用 default dictionaies 将会更加方便.

import collections

# defaultdict 接收一个工厂函数. 一个工厂函数就是当我们调用一个函数时, 这个函数能够返回给我们一个特定类型的对象.
# 所有 Python 内置的数据类型都可以被当做一个工厂函数来使用
# 比如前面我们讲解到的 `str()`, 能够返回一个字符串, `int()`, `float()`, `tuple()`, `set()`, `dict()` 都是工厂函数.
words = collections.defaultdict(int)
print(words['a'])
print(words)

sentences = collections.defaultdict(tuple)
print(sentences['word'])
print(sentences)

# 自定义默认值
cus_type = collections.defaultdict(lambda: [0, 0, 0])
print(cus_type['a'])
print(cus_type)</code></pre>

<h1>ordereddict</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections

d = collections.OrderedDict([('z', -4), ('e', 19), ('k', 7)])
print(d)

# 注意, 如果传递给 OrderedDict 的参数是一个无法保证顺序的对象, 比如另一个字典, 则生成出来的字典的顺序是随机的.
# 但是向上面那样传递一个 list, 或是 元组 则不会出现这种情况, 因为他们都是能够保证元素顺序的对象
plain_dict = {'a':1, 'b':2, 'c':3}
d2 = collections.OrderedDict(plain_dict)
print(d2)
# 包括使用 update()
d3 = collections.OrderedDict()
d3.update(plain_dict)
print(d3)
# 因此我们应当避免使用一个元素顺序不保证的对象作为参数传递给 OrderedDict()

# 通过向字典中追加新元素的方式, 将会严格保证键值的顺序
tasks = collections.OrderedDict()
tasks[8031] = 'Backup'
tasks[4027] = 'Scan Email'
tasks[5733] = 'Build System'
print(tasks)
# 输出字典的键, 其顺序一定是按照上面的顺序下来的.
print(tasks.keys())

# 如果我们想要将一个元素移动到字典的结尾, 必须先要删除这个元素, 在将这个元素追加进字典中才能实现
tasks[4027] = tasks.pop(4027)
print(tasks)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="03_dictionary" id="_____03_dictionary2" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/03_dictionary:2">
<h1>字典中的方法</h1>

<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>d.clear()</td>
<td>清空字典中的所有元素</td>
</tr>
<tr>
<td>d.copy()</td>
<td>返回一个新的字典对象 <code>d</code> 的拷贝对象</td>
</tr>
<tr>
<td>d.fromkeys(s, v)</td>
<td>返回一个新的字典对象, 字典的 key 为可迭代对象 <code>s</code> 中的所有元素, 如果指定了参数 <code>v</code>, 则所有 <code>key</code> 的值为 <code>v</code>, 否则所有 <code>key</code> 的值为 <code>None</code>
</td>
</tr>
<tr>
<td>d.get(k)</td>
<td>返回字典中键 <code>k</code> 对应的值, 如果不存在 <code>k</code>, 则返回 <code>None</code>
</td>
</tr>
<tr>
<td>d.get(k, v)</td>
<td>同上, 但是如果不存在 <code>k</code> 键, 则返回给定的值 <code>v</code>
</td>
</tr>
<tr>
<td>d.items()</td>
<td>将字典中所有的元素以 (key, value) 的形式保存到 字典视图 中, 并返回这个视图</td>
</tr>
<tr>
<td>d.keys()</td>
<td>返回一个字典视图, 包含了字典中所有的键</td>
</tr>
<tr>
<td>d.values()</td>
<td>返回一个字典视图, 包含了字典中所有的值</td>
</tr>
<tr>
<td>d.pop(k)</td>
<td>返回字典中键 <code>k</code> 对应的值, 并将该键从字典中移除, 如果字典中不存在键 <code>k</code>, 则抛出 KeyError 异常</td>
</tr>
<tr>
<td>d.pop(k, v)</td>
<td>返回字典中键 <code>k</code> 对应的值, 并将该键从字典中移除, 如果字典中不存在键 <code>k</code>, 则返回 <code>v</code>
</td>
</tr>
<tr>
<td>d.popitem()</td>
<td>从字典中删除随意一个键值对, 并返回被删除的键值对, 当对一个空的字典进行 popitem() 操作时, 将会抛出 <code>KeyError</code> 异常</td>
</tr>
<tr>
<td>d.setdefault(k, v)</td>
<td>如果字典中存在键 <code>k</code>, 则返回它在字典中对应的值, 如果不存在该键, 则向该字典中插入值为 <code>v</code> 的键 <code>k</code>, 并返回值 <code>v</code>
</td>
</tr>
<tr>
<td>d.update(a)</td>
<td>更新字典, 该方法接收三种形式的参数: 一个字典; 或是一个可迭代对象, 每次迭代返回的都是一个包含两个元素的对象分别作为 key 和 value; 或是向该函数传递关键字参数</td>
</tr>
</tbody>
</table>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>创建</h1>

<p>前面讲的都是通过索引获取元素中的值, 虽然使用命名元组可以为元素定义名字, 但它并不是元组特有的属性, 而且不是很方便</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 返回一个空字典
d1 = dict()
print("d1", d1)

# 传递参数
d2 = dict(id=1948, name="Washer", size=3)
# 这里注意字典打印的顺序, 与我们给定的顺序是不同的
print("d2", d2)

# 传递另一个字典作为参数
d3 = dict(d2)
print("d3", d3)

# 传递一个可迭代对象, 可以是一个元组, 也可以是一个列表
# 迭代对象中每个元素又是另一个包含2个元素的可迭代对象, 元素0-&gt;key, 元素 1-&gt;value
d5 = dict([['id', 1948], ('name', 'Washer'), ('size', 3)])
print("d5:", d5)

# 也可以直接通过 大括号 创建字典
d = {'a': 1, 'b': 2}
# 在看一个例子
d = {"root": 17, 'blue': [75, 'R', 2], 21:'venus', -14:None, 'mars':'rover', (4,11):18, 0:45}
# 字典中的键可以是任何可哈希(hash)的对象, 可哈希对象简单理解就是其值不可改变的对象, 数字, 字符串, 元组就是可可哈希的对象
# 可以使用内置函数 `hash()` 判断一个对象是否是可哈希的
# hash((1, 2, 3))
# hash((1, 2, [3, 4])) 包含列表, 不可哈希
# 字典中的键值要保证是唯一的, 否则后面出现的键将会覆盖前面先出现的键

# 迭代字典中的元素
for i in d:
    # 每次迭代返回是键
    print(i)
    # 同时获取 键 和 值
    print('{}-&gt;{}'.format(i, d[i]))</code></pre>

<h2>zip</h2>

<pre class="highlight"><code class="language-python"># 使用 zip
# zip 是Python的一个内置函数
# 他接收任意个可迭代对象作为参数
# 它返回一个迭代器
z = zip('abc', (1, 2, 3))
for i in z:
    print(i)

d4 = dict(zip(('id', 'name', 'size'), (1948, 'Washer', 3)))
print("d4:", d4)

a1 = (1, 2, 3)
a2 = (4, 5, 6)
a3 = ('a', 'b', 'c')
# 增加2个元素的元组, 结果每个元组中都包含2个元素
a4 = ('x', 'y')
a = zip(a1, a2, a3, a4)
print(a)

# 生成字典
d = {}
b1 = ('a', 'b', 'c')
b2 = (1, 2, 3)
for key, val in zip(b1, b2):
    d[key] = val
print(d)</code></pre>

<h2>访问字典元素</h2>

<pre class="highlight"><code class="language-python"># 通过键值获取元素
d['root']
d['blue']
d[-14]
d[(4,11)]
# 当访问一个不存在的键时, 会抛出 KeyError 异常
#  d['x']

# 新曾元素, 因为字典是非顺序的, 所以新增的元素不一定会被追加到字典的结尾
d['x'] = 59
d

# 可以像之前讲解变量时那样, 使用 del 删除字典中的一个元素
del d['x']
d

# 我们可以使用内置函数 len() 来获取字典的长度
len(d)</code></pre>

<h1>字典方法</h1>

<pre class="highlight"><code class="language-python">d = {'user': 'Smith', 'address': ['USA', 'Littleton'], 'Level': 10, 'size': 15}

################ get() ################
# 上面提到我们可以通过键名直接获取字典中的元素
# 还可以使用 字典的 get() 方法获取
d.get('user')
# 上面提到了, 当访问一个不存在的键时, 会抛出 KeyError 异常.
# 但是返回 None ,如果 xxx 不存在
d['users'] # 报错 KeyError 异常
d.get('users', 'NULL') # 返回 NULL 字符串

# 还可以指定第二个参数
# 返回给定的值 `XXX` 如果 key `xxx` 不存在
d.get('users', 'users')

################ pop() ################
# 返回字典中键k对应的值, 并将该键从字典中移除
# 如果字典中不存在键 k, 则抛出 KeyError 异常
d.pop('user')
d.pop('user') # 报错
d.pop('user', 'NULL') # 返回 NULL 字符串

################ popitem() ################
# 从字典中删除随意一个键值对, 并返回被删除的键值对
d.popitem()
# 当对一个空的字典进行 popitem() 操作时, 将会抛出 `KeyError` 异常
d.popitem()

################ setdefault() ################
# 它的作用首先是返回指定键的值
# 如果不存在该键, 则向该字典中插入值为 `v` 的键 `k`, 并返回值 `v`
d.setdefault('user', 'Smith')
d.setdefault('address', ['USA', 'Littleton'])
d
# 如果没有指定第二个参数, 则默认插入 None

################ update() ################
# 更新字典, 该方法接收三种形式的参数:
# 传递另一个字典
d.update({'size': 18, 'age': 36})
print(d)

# 或是一个可迭代对象
# 每次迭代返回的都是一个包含两个元素的对象分别作为 key 和 value; 或是向该函数传递关键字参数
# 传递一个元组
d.update((('first', 'Smith'), ('last', 'Keven')))
# 也可以将参数保存到一个变量中
t = (('first', 'Smith'), ('last', 'Keven'), ('id', 1234567))
d.update(t)

# 或是通过指定一个参数名字和值的方式
d.update(company='IBM', department='BTIT')

################ clear() ################
# 清空字典
d.clear()

################ copy() ################
d1 = {'a':1, 'b':2}
d2 = d1
d1['a'] = 0
d1
d2

d2 = d1.copy()
id(d1)
id(d2)
# 或
d2 = dict(d1)</code></pre>

<h1>字典视图</h1>

<pre class="highlight"><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}

d_k = d.keys()
d_v = d.values()
d_i = d.items()
d_k
d_v
d_i

d.setdefault('d', 4)
d
d_k
d_v
d_i

# 因为 items 返回的是一个列表
# 并且每个元素都是一个有 key 和 value 组成的元组
# 索引我们可以直接循环它来获取 key 和 value
for item, val in d.items():
    print('{} : {}'.format(item, val))

# `items()`, `keys()` 与 `values()` 函数返回的结构都是从源字典中的拷贝出来的, 如果被操作的字典包含大量元素, 这将会导致内存的大量浪费, 相应的, 我们可以使用 `iteritems()`, `iterkeys()` 和 `itervalues()`, 这些函数返回一个可迭代对象, 可以对这些可迭代对象进行 `for` 循环获取其中的内容, 在循环可迭代对象时, 之后当前被处理的元素才会被保存到内存当中, 当处理完成以后, 就会从内存当中删除.
# 在 Python3 中, 对 `items()`, `keys()` 与 `values()` 这3个函数进行了重新处理, 他们全部返回 字典视图(directory view) 对象, 并且移除了 `iteritems()`, `iterkeys()` 和 `itervalues()` 函数.</code></pre>

<h1>字典推导式</h1>

<p>前面讲解列表时, 我们讲过了 列表推导式, 字典同样也存在推导式-&gt; 字典推导式</p>

<pre class="highlight"><code class="language-python">import os

# 列出当前文件所在目录下的所有文件的大小
# os.listdir() 返回指定目录下的文件列表
# os.path.isfile 判断是否是文件
file_size = {name: os.path.getsize(name) for name in os.listdir('.') if os.path.isfile(name)}
print(file_size)</code></pre>

<h1>default dictionary</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们访问一个字典中不存在的 键 时, 会抛出 KeyError 异常.
# 这是正确的行为, 因为我们需要知道这个键不存在某个字典中

# 但有些时候我们希望当键不存在时, 可以自动将这个键添加进去, 虽然上面我们提及了字典的 `setdefault()` 方法可以帮助我们达到这一目的.
# 但使用 default dictionaies 将会更加方便.

import collections

# defaultdict 接收一个工厂函数. 一个工厂函数就是当我们调用一个函数时, 这个函数能够返回给我们一个特定类型的对象.
# 所有 Python 内置的数据类型都可以被当做一个工厂函数来使用
# 比如前面我们讲解到的 `str()`, 能够返回一个字符串, `int()`, `float()`, `tuple()`, `set()`, `dict()` 都是工厂函数.
words = collections.defaultdict(int)
print(words['a'])
print(words)

sentences = collections.defaultdict(tuple)
print(sentences['word'])
print(sentences)

# 自定义默认值
cus_type = collections.defaultdict(lambda: [0, 0, 0])
print(cus_type['a'])
print(cus_type)</code></pre>

<h1>ordereddict</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections

d = collections.OrderedDict([('z', -4), ('e', 19), ('k', 7)])
print(d)

# 注意, 如果传递给 OrderedDict 的参数是一个无法保证顺序的对象, 比如另一个字典, 则生成出来的字典的顺序是随机的.
# 但是向上面那样传递一个 list, 或是 元组 则不会出现这种情况, 因为他们都是能够保证元素顺序的对象
plain_dict = {'a':1, 'b':2, 'c':3}
d2 = collections.OrderedDict(plain_dict)
print(d2)
# 包括使用 update()
d3 = collections.OrderedDict()
d3.update(plain_dict)
print(d3)
# 因此我们应当避免使用一个元素顺序不保证的对象作为参数传递给 OrderedDict()

# 通过向字典中追加新元素的方式, 将会严格保证键值的顺序
tasks = collections.OrderedDict()
tasks[8031] = 'Backup'
tasks[4027] = 'Scan Email'
tasks[5733] = 'Build System'
print(tasks)
# 输出字典的键, 其顺序一定是按照上面的顺序下来的.
print(tasks.keys())

# 如果我们想要将一个元素移动到字典的结尾, 必须先要删除这个元素, 在将这个元素追加进字典中才能实现
tasks[4027] = tasks.pop(4027)
print(tasks)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="03_dictionary" id="_____03_dictionary3" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/03_dictionary:3">
<h1>字典视图</h1>

<p>字典视图是一个只读的可迭代对象, 可用来保存字典中的键, 或值, 或键值对</p>

<p>我们可以通过调用调用 <code>d.keys()</code>, <code>d.values()</code> 还是 <code>d.items()</code> 来分别获取这些值.</p>

<p>字典视图是动态的, 能够实时反映出字典的变化.</p>

<p>字典视图还支持 <code>set</code> 类型的集合操作</p>

<ul>
<li>
<code>v &amp; x</code> 交集</li>
<li>
<code>v | x</code> 并集</li>
<li>
<code>v - x</code> 差集</li>
<li>
<code>v ^ x</code> 对称差集</li>
</ul>

<p class="callout warning">在 Python2 中, <code>items()</code>, <code>keys()</code> 与 <code>values()</code> 函数返回的结果都是从源字典中拷贝出来的, 如果被操作的字典包含大量元素, 这将会导致内存的大量浪费, 相应的, 我们可以使用 <code>iteritems()</code>, <code>iterkeys()</code> 和 <code>itervalues()</code>, 这些函数返回一个可迭代对象, 可以对这些可迭代对象进行 <code>for</code> 循环获取其中的内容, 在循环可迭代对象时, 之后当前被处理的元素才会被保存到内存当中, 当处理完成以后, 就会从内存当中删除.</p>

<p class="callout warning">在 Python3 中, 对 <code>items()</code>, <code>keys()</code> 与 <code>values()</code> 这3个函数进行了重新处理, 他们全部返回 字典视图(directory view) 对象, 并且移除了 <code>iteritems()</code>, <code>iterkeys()</code> 和 <code>itervalues()</code> 这3个函数.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>创建</h1>

<p>前面讲的都是通过索引获取元素中的值, 虽然使用命名元组可以为元素定义名字, 但它并不是元组特有的属性, 而且不是很方便</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 返回一个空字典
d1 = dict()
print("d1", d1)

# 传递参数
d2 = dict(id=1948, name="Washer", size=3)
# 这里注意字典打印的顺序, 与我们给定的顺序是不同的
print("d2", d2)

# 传递另一个字典作为参数
d3 = dict(d2)
print("d3", d3)

# 传递一个可迭代对象, 可以是一个元组, 也可以是一个列表
# 迭代对象中每个元素又是另一个包含2个元素的可迭代对象, 元素0-&gt;key, 元素 1-&gt;value
d5 = dict([['id', 1948], ('name', 'Washer'), ('size', 3)])
print("d5:", d5)

# 也可以直接通过 大括号 创建字典
d = {'a': 1, 'b': 2}
# 在看一个例子
d = {"root": 17, 'blue': [75, 'R', 2], 21:'venus', -14:None, 'mars':'rover', (4,11):18, 0:45}
# 字典中的键可以是任何可哈希(hash)的对象, 可哈希对象简单理解就是其值不可改变的对象, 数字, 字符串, 元组就是可可哈希的对象
# 可以使用内置函数 `hash()` 判断一个对象是否是可哈希的
# hash((1, 2, 3))
# hash((1, 2, [3, 4])) 包含列表, 不可哈希
# 字典中的键值要保证是唯一的, 否则后面出现的键将会覆盖前面先出现的键

# 迭代字典中的元素
for i in d:
    # 每次迭代返回是键
    print(i)
    # 同时获取 键 和 值
    print('{}-&gt;{}'.format(i, d[i]))</code></pre>

<h2>zip</h2>

<pre class="highlight"><code class="language-python"># 使用 zip
# zip 是Python的一个内置函数
# 他接收任意个可迭代对象作为参数
# 它返回一个迭代器
z = zip('abc', (1, 2, 3))
for i in z:
    print(i)

d4 = dict(zip(('id', 'name', 'size'), (1948, 'Washer', 3)))
print("d4:", d4)

a1 = (1, 2, 3)
a2 = (4, 5, 6)
a3 = ('a', 'b', 'c')
# 增加2个元素的元组, 结果每个元组中都包含2个元素
a4 = ('x', 'y')
a = zip(a1, a2, a3, a4)
print(a)

# 生成字典
d = {}
b1 = ('a', 'b', 'c')
b2 = (1, 2, 3)
for key, val in zip(b1, b2):
    d[key] = val
print(d)</code></pre>

<h2>访问字典元素</h2>

<pre class="highlight"><code class="language-python"># 通过键值获取元素
d['root']
d['blue']
d[-14]
d[(4,11)]
# 当访问一个不存在的键时, 会抛出 KeyError 异常
#  d['x']

# 新曾元素, 因为字典是非顺序的, 所以新增的元素不一定会被追加到字典的结尾
d['x'] = 59
d

# 可以像之前讲解变量时那样, 使用 del 删除字典中的一个元素
del d['x']
d

# 我们可以使用内置函数 len() 来获取字典的长度
len(d)</code></pre>

<h1>字典方法</h1>

<pre class="highlight"><code class="language-python">d = {'user': 'Smith', 'address': ['USA', 'Littleton'], 'Level': 10, 'size': 15}

################ get() ################
# 上面提到我们可以通过键名直接获取字典中的元素
# 还可以使用 字典的 get() 方法获取
d.get('user')
# 上面提到了, 当访问一个不存在的键时, 会抛出 KeyError 异常.
# 但是返回 None ,如果 xxx 不存在
d['users'] # 报错 KeyError 异常
d.get('users', 'NULL') # 返回 NULL 字符串

# 还可以指定第二个参数
# 返回给定的值 `XXX` 如果 key `xxx` 不存在
d.get('users', 'users')

################ pop() ################
# 返回字典中键k对应的值, 并将该键从字典中移除
# 如果字典中不存在键 k, 则抛出 KeyError 异常
d.pop('user')
d.pop('user') # 报错
d.pop('user', 'NULL') # 返回 NULL 字符串

################ popitem() ################
# 从字典中删除随意一个键值对, 并返回被删除的键值对
d.popitem()
# 当对一个空的字典进行 popitem() 操作时, 将会抛出 `KeyError` 异常
d.popitem()

################ setdefault() ################
# 它的作用首先是返回指定键的值
# 如果不存在该键, 则向该字典中插入值为 `v` 的键 `k`, 并返回值 `v`
d.setdefault('user', 'Smith')
d.setdefault('address', ['USA', 'Littleton'])
d
# 如果没有指定第二个参数, 则默认插入 None

################ update() ################
# 更新字典, 该方法接收三种形式的参数:
# 传递另一个字典
d.update({'size': 18, 'age': 36})
print(d)

# 或是一个可迭代对象
# 每次迭代返回的都是一个包含两个元素的对象分别作为 key 和 value; 或是向该函数传递关键字参数
# 传递一个元组
d.update((('first', 'Smith'), ('last', 'Keven')))
# 也可以将参数保存到一个变量中
t = (('first', 'Smith'), ('last', 'Keven'), ('id', 1234567))
d.update(t)

# 或是通过指定一个参数名字和值的方式
d.update(company='IBM', department='BTIT')

################ clear() ################
# 清空字典
d.clear()

################ copy() ################
d1 = {'a':1, 'b':2}
d2 = d1
d1['a'] = 0
d1
d2

d2 = d1.copy()
id(d1)
id(d2)
# 或
d2 = dict(d1)</code></pre>

<h1>字典视图</h1>

<pre class="highlight"><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}

d_k = d.keys()
d_v = d.values()
d_i = d.items()
d_k
d_v
d_i

d.setdefault('d', 4)
d
d_k
d_v
d_i

# 因为 items 返回的是一个列表
# 并且每个元素都是一个有 key 和 value 组成的元组
# 索引我们可以直接循环它来获取 key 和 value
for item, val in d.items():
    print('{} : {}'.format(item, val))

# `items()`, `keys()` 与 `values()` 函数返回的结构都是从源字典中的拷贝出来的, 如果被操作的字典包含大量元素, 这将会导致内存的大量浪费, 相应的, 我们可以使用 `iteritems()`, `iterkeys()` 和 `itervalues()`, 这些函数返回一个可迭代对象, 可以对这些可迭代对象进行 `for` 循环获取其中的内容, 在循环可迭代对象时, 之后当前被处理的元素才会被保存到内存当中, 当处理完成以后, 就会从内存当中删除.
# 在 Python3 中, 对 `items()`, `keys()` 与 `values()` 这3个函数进行了重新处理, 他们全部返回 字典视图(directory view) 对象, 并且移除了 `iteritems()`, `iterkeys()` 和 `itervalues()` 函数.</code></pre>

<h1>字典推导式</h1>

<p>前面讲解列表时, 我们讲过了 列表推导式, 字典同样也存在推导式-&gt; 字典推导式</p>

<pre class="highlight"><code class="language-python">import os

# 列出当前文件所在目录下的所有文件的大小
# os.listdir() 返回指定目录下的文件列表
# os.path.isfile 判断是否是文件
file_size = {name: os.path.getsize(name) for name in os.listdir('.') if os.path.isfile(name)}
print(file_size)</code></pre>

<h1>default dictionary</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们访问一个字典中不存在的 键 时, 会抛出 KeyError 异常.
# 这是正确的行为, 因为我们需要知道这个键不存在某个字典中

# 但有些时候我们希望当键不存在时, 可以自动将这个键添加进去, 虽然上面我们提及了字典的 `setdefault()` 方法可以帮助我们达到这一目的.
# 但使用 default dictionaies 将会更加方便.

import collections

# defaultdict 接收一个工厂函数. 一个工厂函数就是当我们调用一个函数时, 这个函数能够返回给我们一个特定类型的对象.
# 所有 Python 内置的数据类型都可以被当做一个工厂函数来使用
# 比如前面我们讲解到的 `str()`, 能够返回一个字符串, `int()`, `float()`, `tuple()`, `set()`, `dict()` 都是工厂函数.
words = collections.defaultdict(int)
print(words['a'])
print(words)

sentences = collections.defaultdict(tuple)
print(sentences['word'])
print(sentences)

# 自定义默认值
cus_type = collections.defaultdict(lambda: [0, 0, 0])
print(cus_type['a'])
print(cus_type)</code></pre>

<h1>ordereddict</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections

d = collections.OrderedDict([('z', -4), ('e', 19), ('k', 7)])
print(d)

# 注意, 如果传递给 OrderedDict 的参数是一个无法保证顺序的对象, 比如另一个字典, 则生成出来的字典的顺序是随机的.
# 但是向上面那样传递一个 list, 或是 元组 则不会出现这种情况, 因为他们都是能够保证元素顺序的对象
plain_dict = {'a':1, 'b':2, 'c':3}
d2 = collections.OrderedDict(plain_dict)
print(d2)
# 包括使用 update()
d3 = collections.OrderedDict()
d3.update(plain_dict)
print(d3)
# 因此我们应当避免使用一个元素顺序不保证的对象作为参数传递给 OrderedDict()

# 通过向字典中追加新元素的方式, 将会严格保证键值的顺序
tasks = collections.OrderedDict()
tasks[8031] = 'Backup'
tasks[4027] = 'Scan Email'
tasks[5733] = 'Build System'
print(tasks)
# 输出字典的键, 其顺序一定是按照上面的顺序下来的.
print(tasks.keys())

# 如果我们想要将一个元素移动到字典的结尾, 必须先要删除这个元素, 在将这个元素追加进字典中才能实现
tasks[4027] = tasks.pop(4027)
print(tasks)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="03_dictionary" id="_____03_dictionary4" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/03_dictionary:4">
<h1>字典推导式</h1>

<p>列表推导式两种格式:</p>

<ul>
<li><code>{keyexpression: valueexpression for key, value in iterable}</code></li>
<li><code>{keyexpression: valueexpression for key, value in iterable if condition}</code></li>
</ul>

<p>获取当前目录下所有文件的大小, 其中键为文件名, 值为文件的大小</p>

<pre class="highlight"><code class="language-python">import os

# 列出当前文件所在目录下的所有文件的大小
file_size = {name: os.path.getsize(name) for name in os.listdir('.') if os.path.isfile(name)}
print(file_size)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>创建</h1>

<p>前面讲的都是通过索引获取元素中的值, 虽然使用命名元组可以为元素定义名字, 但它并不是元组特有的属性, 而且不是很方便</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 返回一个空字典
d1 = dict()
print("d1", d1)

# 传递参数
d2 = dict(id=1948, name="Washer", size=3)
# 这里注意字典打印的顺序, 与我们给定的顺序是不同的
print("d2", d2)

# 传递另一个字典作为参数
d3 = dict(d2)
print("d3", d3)

# 传递一个可迭代对象, 可以是一个元组, 也可以是一个列表
# 迭代对象中每个元素又是另一个包含2个元素的可迭代对象, 元素0-&gt;key, 元素 1-&gt;value
d5 = dict([['id', 1948], ('name', 'Washer'), ('size', 3)])
print("d5:", d5)

# 也可以直接通过 大括号 创建字典
d = {'a': 1, 'b': 2}
# 在看一个例子
d = {"root": 17, 'blue': [75, 'R', 2], 21:'venus', -14:None, 'mars':'rover', (4,11):18, 0:45}
# 字典中的键可以是任何可哈希(hash)的对象, 可哈希对象简单理解就是其值不可改变的对象, 数字, 字符串, 元组就是可可哈希的对象
# 可以使用内置函数 `hash()` 判断一个对象是否是可哈希的
# hash((1, 2, 3))
# hash((1, 2, [3, 4])) 包含列表, 不可哈希
# 字典中的键值要保证是唯一的, 否则后面出现的键将会覆盖前面先出现的键

# 迭代字典中的元素
for i in d:
    # 每次迭代返回是键
    print(i)
    # 同时获取 键 和 值
    print('{}-&gt;{}'.format(i, d[i]))</code></pre>

<h2>zip</h2>

<pre class="highlight"><code class="language-python"># 使用 zip
# zip 是Python的一个内置函数
# 他接收任意个可迭代对象作为参数
# 它返回一个迭代器
z = zip('abc', (1, 2, 3))
for i in z:
    print(i)

d4 = dict(zip(('id', 'name', 'size'), (1948, 'Washer', 3)))
print("d4:", d4)

a1 = (1, 2, 3)
a2 = (4, 5, 6)
a3 = ('a', 'b', 'c')
# 增加2个元素的元组, 结果每个元组中都包含2个元素
a4 = ('x', 'y')
a = zip(a1, a2, a3, a4)
print(a)

# 生成字典
d = {}
b1 = ('a', 'b', 'c')
b2 = (1, 2, 3)
for key, val in zip(b1, b2):
    d[key] = val
print(d)</code></pre>

<h2>访问字典元素</h2>

<pre class="highlight"><code class="language-python"># 通过键值获取元素
d['root']
d['blue']
d[-14]
d[(4,11)]
# 当访问一个不存在的键时, 会抛出 KeyError 异常
#  d['x']

# 新曾元素, 因为字典是非顺序的, 所以新增的元素不一定会被追加到字典的结尾
d['x'] = 59
d

# 可以像之前讲解变量时那样, 使用 del 删除字典中的一个元素
del d['x']
d

# 我们可以使用内置函数 len() 来获取字典的长度
len(d)</code></pre>

<h1>字典方法</h1>

<pre class="highlight"><code class="language-python">d = {'user': 'Smith', 'address': ['USA', 'Littleton'], 'Level': 10, 'size': 15}

################ get() ################
# 上面提到我们可以通过键名直接获取字典中的元素
# 还可以使用 字典的 get() 方法获取
d.get('user')
# 上面提到了, 当访问一个不存在的键时, 会抛出 KeyError 异常.
# 但是返回 None ,如果 xxx 不存在
d['users'] # 报错 KeyError 异常
d.get('users', 'NULL') # 返回 NULL 字符串

# 还可以指定第二个参数
# 返回给定的值 `XXX` 如果 key `xxx` 不存在
d.get('users', 'users')

################ pop() ################
# 返回字典中键k对应的值, 并将该键从字典中移除
# 如果字典中不存在键 k, 则抛出 KeyError 异常
d.pop('user')
d.pop('user') # 报错
d.pop('user', 'NULL') # 返回 NULL 字符串

################ popitem() ################
# 从字典中删除随意一个键值对, 并返回被删除的键值对
d.popitem()
# 当对一个空的字典进行 popitem() 操作时, 将会抛出 `KeyError` 异常
d.popitem()

################ setdefault() ################
# 它的作用首先是返回指定键的值
# 如果不存在该键, 则向该字典中插入值为 `v` 的键 `k`, 并返回值 `v`
d.setdefault('user', 'Smith')
d.setdefault('address', ['USA', 'Littleton'])
d
# 如果没有指定第二个参数, 则默认插入 None

################ update() ################
# 更新字典, 该方法接收三种形式的参数:
# 传递另一个字典
d.update({'size': 18, 'age': 36})
print(d)

# 或是一个可迭代对象
# 每次迭代返回的都是一个包含两个元素的对象分别作为 key 和 value; 或是向该函数传递关键字参数
# 传递一个元组
d.update((('first', 'Smith'), ('last', 'Keven')))
# 也可以将参数保存到一个变量中
t = (('first', 'Smith'), ('last', 'Keven'), ('id', 1234567))
d.update(t)

# 或是通过指定一个参数名字和值的方式
d.update(company='IBM', department='BTIT')

################ clear() ################
# 清空字典
d.clear()

################ copy() ################
d1 = {'a':1, 'b':2}
d2 = d1
d1['a'] = 0
d1
d2

d2 = d1.copy()
id(d1)
id(d2)
# 或
d2 = dict(d1)</code></pre>

<h1>字典视图</h1>

<pre class="highlight"><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}

d_k = d.keys()
d_v = d.values()
d_i = d.items()
d_k
d_v
d_i

d.setdefault('d', 4)
d
d_k
d_v
d_i

# 因为 items 返回的是一个列表
# 并且每个元素都是一个有 key 和 value 组成的元组
# 索引我们可以直接循环它来获取 key 和 value
for item, val in d.items():
    print('{} : {}'.format(item, val))

# `items()`, `keys()` 与 `values()` 函数返回的结构都是从源字典中的拷贝出来的, 如果被操作的字典包含大量元素, 这将会导致内存的大量浪费, 相应的, 我们可以使用 `iteritems()`, `iterkeys()` 和 `itervalues()`, 这些函数返回一个可迭代对象, 可以对这些可迭代对象进行 `for` 循环获取其中的内容, 在循环可迭代对象时, 之后当前被处理的元素才会被保存到内存当中, 当处理完成以后, 就会从内存当中删除.
# 在 Python3 中, 对 `items()`, `keys()` 与 `values()` 这3个函数进行了重新处理, 他们全部返回 字典视图(directory view) 对象, 并且移除了 `iteritems()`, `iterkeys()` 和 `itervalues()` 函数.</code></pre>

<h1>字典推导式</h1>

<p>前面讲解列表时, 我们讲过了 列表推导式, 字典同样也存在推导式-&gt; 字典推导式</p>

<pre class="highlight"><code class="language-python">import os

# 列出当前文件所在目录下的所有文件的大小
# os.listdir() 返回指定目录下的文件列表
# os.path.isfile 判断是否是文件
file_size = {name: os.path.getsize(name) for name in os.listdir('.') if os.path.isfile(name)}
print(file_size)</code></pre>

<h1>default dictionary</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们访问一个字典中不存在的 键 时, 会抛出 KeyError 异常.
# 这是正确的行为, 因为我们需要知道这个键不存在某个字典中

# 但有些时候我们希望当键不存在时, 可以自动将这个键添加进去, 虽然上面我们提及了字典的 `setdefault()` 方法可以帮助我们达到这一目的.
# 但使用 default dictionaies 将会更加方便.

import collections

# defaultdict 接收一个工厂函数. 一个工厂函数就是当我们调用一个函数时, 这个函数能够返回给我们一个特定类型的对象.
# 所有 Python 内置的数据类型都可以被当做一个工厂函数来使用
# 比如前面我们讲解到的 `str()`, 能够返回一个字符串, `int()`, `float()`, `tuple()`, `set()`, `dict()` 都是工厂函数.
words = collections.defaultdict(int)
print(words['a'])
print(words)

sentences = collections.defaultdict(tuple)
print(sentences['word'])
print(sentences)

# 自定义默认值
cus_type = collections.defaultdict(lambda: [0, 0, 0])
print(cus_type['a'])
print(cus_type)</code></pre>

<h1>ordereddict</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections

d = collections.OrderedDict([('z', -4), ('e', 19), ('k', 7)])
print(d)

# 注意, 如果传递给 OrderedDict 的参数是一个无法保证顺序的对象, 比如另一个字典, 则生成出来的字典的顺序是随机的.
# 但是向上面那样传递一个 list, 或是 元组 则不会出现这种情况, 因为他们都是能够保证元素顺序的对象
plain_dict = {'a':1, 'b':2, 'c':3}
d2 = collections.OrderedDict(plain_dict)
print(d2)
# 包括使用 update()
d3 = collections.OrderedDict()
d3.update(plain_dict)
print(d3)
# 因此我们应当避免使用一个元素顺序不保证的对象作为参数传递给 OrderedDict()

# 通过向字典中追加新元素的方式, 将会严格保证键值的顺序
tasks = collections.OrderedDict()
tasks[8031] = 'Backup'
tasks[4027] = 'Scan Email'
tasks[5733] = 'Build System'
print(tasks)
# 输出字典的键, 其顺序一定是按照上面的顺序下来的.
print(tasks.keys())

# 如果我们想要将一个元素移动到字典的结尾, 必须先要删除这个元素, 在将这个元素追加进字典中才能实现
tasks[4027] = tasks.pop(4027)
print(tasks)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="03_dictionary" id="_____03_dictionary5" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/03_dictionary:5">
<h1>Default Dictionaries</h1>

<p>Default Dictionaries 与 普通的字典完全一样, 唯一的不同是在当我们访问一个 Default Dictionaries 中不存在的键时, 它都会自动将这个键添加到字典中, 并且为这个键设置一个指定的默认值, 同时返回这个默认值.</p>

<p>Default Dictionaries 存在于 <code>collections</code> 包中, 默认不会被 Python 解释器引入, 因此在使用 Default Dictionaries 之前需要引入该包: <code>import collections</code></p>

<pre class="highlight"><code class="language-python">words = collections.defaultdict(int)
print(words['a'])

sentences = collections.defaultdict(tuple)
print(sentences['word'])</code></pre>

<p>defaultdict 需要一个工厂函数作为参数传递给它. 一个工厂函数就是当我们调用一个函数时, 这个函数能够返回给我们一个特定类型的对象. 所有 Python 内置的数据类型都可以被当做一个工厂函数来使用.<br>
比如前面我们讲解到的 <code>str()</code>, 能够返回一个字符串, <code>int()</code>, <code>float()</code>, <code>tuple()</code>, <code>set()</code>, <code>dict()</code> 都是工厂函数.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>创建</h1>

<p>前面讲的都是通过索引获取元素中的值, 虽然使用命名元组可以为元素定义名字, 但它并不是元组特有的属性, 而且不是很方便</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 返回一个空字典
d1 = dict()
print("d1", d1)

# 传递参数
d2 = dict(id=1948, name="Washer", size=3)
# 这里注意字典打印的顺序, 与我们给定的顺序是不同的
print("d2", d2)

# 传递另一个字典作为参数
d3 = dict(d2)
print("d3", d3)

# 传递一个可迭代对象, 可以是一个元组, 也可以是一个列表
# 迭代对象中每个元素又是另一个包含2个元素的可迭代对象, 元素0-&gt;key, 元素 1-&gt;value
d5 = dict([['id', 1948], ('name', 'Washer'), ('size', 3)])
print("d5:", d5)

# 也可以直接通过 大括号 创建字典
d = {'a': 1, 'b': 2}
# 在看一个例子
d = {"root": 17, 'blue': [75, 'R', 2], 21:'venus', -14:None, 'mars':'rover', (4,11):18, 0:45}
# 字典中的键可以是任何可哈希(hash)的对象, 可哈希对象简单理解就是其值不可改变的对象, 数字, 字符串, 元组就是可可哈希的对象
# 可以使用内置函数 `hash()` 判断一个对象是否是可哈希的
# hash((1, 2, 3))
# hash((1, 2, [3, 4])) 包含列表, 不可哈希
# 字典中的键值要保证是唯一的, 否则后面出现的键将会覆盖前面先出现的键

# 迭代字典中的元素
for i in d:
    # 每次迭代返回是键
    print(i)
    # 同时获取 键 和 值
    print('{}-&gt;{}'.format(i, d[i]))</code></pre>

<h2>zip</h2>

<pre class="highlight"><code class="language-python"># 使用 zip
# zip 是Python的一个内置函数
# 他接收任意个可迭代对象作为参数
# 它返回一个迭代器
z = zip('abc', (1, 2, 3))
for i in z:
    print(i)

d4 = dict(zip(('id', 'name', 'size'), (1948, 'Washer', 3)))
print("d4:", d4)

a1 = (1, 2, 3)
a2 = (4, 5, 6)
a3 = ('a', 'b', 'c')
# 增加2个元素的元组, 结果每个元组中都包含2个元素
a4 = ('x', 'y')
a = zip(a1, a2, a3, a4)
print(a)

# 生成字典
d = {}
b1 = ('a', 'b', 'c')
b2 = (1, 2, 3)
for key, val in zip(b1, b2):
    d[key] = val
print(d)</code></pre>

<h2>访问字典元素</h2>

<pre class="highlight"><code class="language-python"># 通过键值获取元素
d['root']
d['blue']
d[-14]
d[(4,11)]
# 当访问一个不存在的键时, 会抛出 KeyError 异常
#  d['x']

# 新曾元素, 因为字典是非顺序的, 所以新增的元素不一定会被追加到字典的结尾
d['x'] = 59
d

# 可以像之前讲解变量时那样, 使用 del 删除字典中的一个元素
del d['x']
d

# 我们可以使用内置函数 len() 来获取字典的长度
len(d)</code></pre>

<h1>字典方法</h1>

<pre class="highlight"><code class="language-python">d = {'user': 'Smith', 'address': ['USA', 'Littleton'], 'Level': 10, 'size': 15}

################ get() ################
# 上面提到我们可以通过键名直接获取字典中的元素
# 还可以使用 字典的 get() 方法获取
d.get('user')
# 上面提到了, 当访问一个不存在的键时, 会抛出 KeyError 异常.
# 但是返回 None ,如果 xxx 不存在
d['users'] # 报错 KeyError 异常
d.get('users', 'NULL') # 返回 NULL 字符串

# 还可以指定第二个参数
# 返回给定的值 `XXX` 如果 key `xxx` 不存在
d.get('users', 'users')

################ pop() ################
# 返回字典中键k对应的值, 并将该键从字典中移除
# 如果字典中不存在键 k, 则抛出 KeyError 异常
d.pop('user')
d.pop('user') # 报错
d.pop('user', 'NULL') # 返回 NULL 字符串

################ popitem() ################
# 从字典中删除随意一个键值对, 并返回被删除的键值对
d.popitem()
# 当对一个空的字典进行 popitem() 操作时, 将会抛出 `KeyError` 异常
d.popitem()

################ setdefault() ################
# 它的作用首先是返回指定键的值
# 如果不存在该键, 则向该字典中插入值为 `v` 的键 `k`, 并返回值 `v`
d.setdefault('user', 'Smith')
d.setdefault('address', ['USA', 'Littleton'])
d
# 如果没有指定第二个参数, 则默认插入 None

################ update() ################
# 更新字典, 该方法接收三种形式的参数:
# 传递另一个字典
d.update({'size': 18, 'age': 36})
print(d)

# 或是一个可迭代对象
# 每次迭代返回的都是一个包含两个元素的对象分别作为 key 和 value; 或是向该函数传递关键字参数
# 传递一个元组
d.update((('first', 'Smith'), ('last', 'Keven')))
# 也可以将参数保存到一个变量中
t = (('first', 'Smith'), ('last', 'Keven'), ('id', 1234567))
d.update(t)

# 或是通过指定一个参数名字和值的方式
d.update(company='IBM', department='BTIT')

################ clear() ################
# 清空字典
d.clear()

################ copy() ################
d1 = {'a':1, 'b':2}
d2 = d1
d1['a'] = 0
d1
d2

d2 = d1.copy()
id(d1)
id(d2)
# 或
d2 = dict(d1)</code></pre>

<h1>字典视图</h1>

<pre class="highlight"><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}

d_k = d.keys()
d_v = d.values()
d_i = d.items()
d_k
d_v
d_i

d.setdefault('d', 4)
d
d_k
d_v
d_i

# 因为 items 返回的是一个列表
# 并且每个元素都是一个有 key 和 value 组成的元组
# 索引我们可以直接循环它来获取 key 和 value
for item, val in d.items():
    print('{} : {}'.format(item, val))

# `items()`, `keys()` 与 `values()` 函数返回的结构都是从源字典中的拷贝出来的, 如果被操作的字典包含大量元素, 这将会导致内存的大量浪费, 相应的, 我们可以使用 `iteritems()`, `iterkeys()` 和 `itervalues()`, 这些函数返回一个可迭代对象, 可以对这些可迭代对象进行 `for` 循环获取其中的内容, 在循环可迭代对象时, 之后当前被处理的元素才会被保存到内存当中, 当处理完成以后, 就会从内存当中删除.
# 在 Python3 中, 对 `items()`, `keys()` 与 `values()` 这3个函数进行了重新处理, 他们全部返回 字典视图(directory view) 对象, 并且移除了 `iteritems()`, `iterkeys()` 和 `itervalues()` 函数.</code></pre>

<h1>字典推导式</h1>

<p>前面讲解列表时, 我们讲过了 列表推导式, 字典同样也存在推导式-&gt; 字典推导式</p>

<pre class="highlight"><code class="language-python">import os

# 列出当前文件所在目录下的所有文件的大小
# os.listdir() 返回指定目录下的文件列表
# os.path.isfile 判断是否是文件
file_size = {name: os.path.getsize(name) for name in os.listdir('.') if os.path.isfile(name)}
print(file_size)</code></pre>

<h1>default dictionary</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们访问一个字典中不存在的 键 时, 会抛出 KeyError 异常.
# 这是正确的行为, 因为我们需要知道这个键不存在某个字典中

# 但有些时候我们希望当键不存在时, 可以自动将这个键添加进去, 虽然上面我们提及了字典的 `setdefault()` 方法可以帮助我们达到这一目的.
# 但使用 default dictionaies 将会更加方便.

import collections

# defaultdict 接收一个工厂函数. 一个工厂函数就是当我们调用一个函数时, 这个函数能够返回给我们一个特定类型的对象.
# 所有 Python 内置的数据类型都可以被当做一个工厂函数来使用
# 比如前面我们讲解到的 `str()`, 能够返回一个字符串, `int()`, `float()`, `tuple()`, `set()`, `dict()` 都是工厂函数.
words = collections.defaultdict(int)
print(words['a'])
print(words)

sentences = collections.defaultdict(tuple)
print(sentences['word'])
print(sentences)

# 自定义默认值
cus_type = collections.defaultdict(lambda: [0, 0, 0])
print(cus_type['a'])
print(cus_type)</code></pre>

<h1>ordereddict</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections

d = collections.OrderedDict([('z', -4), ('e', 19), ('k', 7)])
print(d)

# 注意, 如果传递给 OrderedDict 的参数是一个无法保证顺序的对象, 比如另一个字典, 则生成出来的字典的顺序是随机的.
# 但是向上面那样传递一个 list, 或是 元组 则不会出现这种情况, 因为他们都是能够保证元素顺序的对象
plain_dict = {'a':1, 'b':2, 'c':3}
d2 = collections.OrderedDict(plain_dict)
print(d2)
# 包括使用 update()
d3 = collections.OrderedDict()
d3.update(plain_dict)
print(d3)
# 因此我们应当避免使用一个元素顺序不保证的对象作为参数传递给 OrderedDict()

# 通过向字典中追加新元素的方式, 将会严格保证键值的顺序
tasks = collections.OrderedDict()
tasks[8031] = 'Backup'
tasks[4027] = 'Scan Email'
tasks[5733] = 'Build System'
print(tasks)
# 输出字典的键, 其顺序一定是按照上面的顺序下来的.
print(tasks.keys())

# 如果我们想要将一个元素移动到字典的结尾, 必须先要删除这个元素, 在将这个元素追加进字典中才能实现
tasks[4027] = tasks.pop(4027)
print(tasks)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="03_dictionary" id="_____03_dictionary6" class="slide" data-transition="turnUp">
<div class="content " ref="集合类型/03_dictionary:6">
<h1>有序的字典</h1>

<p>与普通的字典不同, 有序字典严格保留了创建字典是键的顺序, 当向字典中插入新的元素时, 新插入的元素一定是字典中的最后一个元素.</p>

<p>使用 <code>collections.OrderedDict()</code> 来创建一个有序字典</p>

<pre class="highlight"><code class="language-python">import collections
d = collections.OrderedDict([('z', -4), ('e', 19), ('k', 7)])

tasks = collections.OrderedDict()
tasks[8031] = 'Backup'
tasks[4027] = 'Scan Email'
tasks[5733] = 'Build System'</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>创建</h1>

<p>前面讲的都是通过索引获取元素中的值, 虽然使用命名元组可以为元素定义名字, 但它并不是元组特有的属性, 而且不是很方便</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 返回一个空字典
d1 = dict()
print("d1", d1)

# 传递参数
d2 = dict(id=1948, name="Washer", size=3)
# 这里注意字典打印的顺序, 与我们给定的顺序是不同的
print("d2", d2)

# 传递另一个字典作为参数
d3 = dict(d2)
print("d3", d3)

# 传递一个可迭代对象, 可以是一个元组, 也可以是一个列表
# 迭代对象中每个元素又是另一个包含2个元素的可迭代对象, 元素0-&gt;key, 元素 1-&gt;value
d5 = dict([['id', 1948], ('name', 'Washer'), ('size', 3)])
print("d5:", d5)

# 也可以直接通过 大括号 创建字典
d = {'a': 1, 'b': 2}
# 在看一个例子
d = {"root": 17, 'blue': [75, 'R', 2], 21:'venus', -14:None, 'mars':'rover', (4,11):18, 0:45}
# 字典中的键可以是任何可哈希(hash)的对象, 可哈希对象简单理解就是其值不可改变的对象, 数字, 字符串, 元组就是可可哈希的对象
# 可以使用内置函数 `hash()` 判断一个对象是否是可哈希的
# hash((1, 2, 3))
# hash((1, 2, [3, 4])) 包含列表, 不可哈希
# 字典中的键值要保证是唯一的, 否则后面出现的键将会覆盖前面先出现的键

# 迭代字典中的元素
for i in d:
    # 每次迭代返回是键
    print(i)
    # 同时获取 键 和 值
    print('{}-&gt;{}'.format(i, d[i]))</code></pre>

<h2>zip</h2>

<pre class="highlight"><code class="language-python"># 使用 zip
# zip 是Python的一个内置函数
# 他接收任意个可迭代对象作为参数
# 它返回一个迭代器
z = zip('abc', (1, 2, 3))
for i in z:
    print(i)

d4 = dict(zip(('id', 'name', 'size'), (1948, 'Washer', 3)))
print("d4:", d4)

a1 = (1, 2, 3)
a2 = (4, 5, 6)
a3 = ('a', 'b', 'c')
# 增加2个元素的元组, 结果每个元组中都包含2个元素
a4 = ('x', 'y')
a = zip(a1, a2, a3, a4)
print(a)

# 生成字典
d = {}
b1 = ('a', 'b', 'c')
b2 = (1, 2, 3)
for key, val in zip(b1, b2):
    d[key] = val
print(d)</code></pre>

<h2>访问字典元素</h2>

<pre class="highlight"><code class="language-python"># 通过键值获取元素
d['root']
d['blue']
d[-14]
d[(4,11)]
# 当访问一个不存在的键时, 会抛出 KeyError 异常
#  d['x']

# 新曾元素, 因为字典是非顺序的, 所以新增的元素不一定会被追加到字典的结尾
d['x'] = 59
d

# 可以像之前讲解变量时那样, 使用 del 删除字典中的一个元素
del d['x']
d

# 我们可以使用内置函数 len() 来获取字典的长度
len(d)</code></pre>

<h1>字典方法</h1>

<pre class="highlight"><code class="language-python">d = {'user': 'Smith', 'address': ['USA', 'Littleton'], 'Level': 10, 'size': 15}

################ get() ################
# 上面提到我们可以通过键名直接获取字典中的元素
# 还可以使用 字典的 get() 方法获取
d.get('user')
# 上面提到了, 当访问一个不存在的键时, 会抛出 KeyError 异常.
# 但是返回 None ,如果 xxx 不存在
d['users'] # 报错 KeyError 异常
d.get('users', 'NULL') # 返回 NULL 字符串

# 还可以指定第二个参数
# 返回给定的值 `XXX` 如果 key `xxx` 不存在
d.get('users', 'users')

################ pop() ################
# 返回字典中键k对应的值, 并将该键从字典中移除
# 如果字典中不存在键 k, 则抛出 KeyError 异常
d.pop('user')
d.pop('user') # 报错
d.pop('user', 'NULL') # 返回 NULL 字符串

################ popitem() ################
# 从字典中删除随意一个键值对, 并返回被删除的键值对
d.popitem()
# 当对一个空的字典进行 popitem() 操作时, 将会抛出 `KeyError` 异常
d.popitem()

################ setdefault() ################
# 它的作用首先是返回指定键的值
# 如果不存在该键, 则向该字典中插入值为 `v` 的键 `k`, 并返回值 `v`
d.setdefault('user', 'Smith')
d.setdefault('address', ['USA', 'Littleton'])
d
# 如果没有指定第二个参数, 则默认插入 None

################ update() ################
# 更新字典, 该方法接收三种形式的参数:
# 传递另一个字典
d.update({'size': 18, 'age': 36})
print(d)

# 或是一个可迭代对象
# 每次迭代返回的都是一个包含两个元素的对象分别作为 key 和 value; 或是向该函数传递关键字参数
# 传递一个元组
d.update((('first', 'Smith'), ('last', 'Keven')))
# 也可以将参数保存到一个变量中
t = (('first', 'Smith'), ('last', 'Keven'), ('id', 1234567))
d.update(t)

# 或是通过指定一个参数名字和值的方式
d.update(company='IBM', department='BTIT')

################ clear() ################
# 清空字典
d.clear()

################ copy() ################
d1 = {'a':1, 'b':2}
d2 = d1
d1['a'] = 0
d1
d2

d2 = d1.copy()
id(d1)
id(d2)
# 或
d2 = dict(d1)</code></pre>

<h1>字典视图</h1>

<pre class="highlight"><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}

d_k = d.keys()
d_v = d.values()
d_i = d.items()
d_k
d_v
d_i

d.setdefault('d', 4)
d
d_k
d_v
d_i

# 因为 items 返回的是一个列表
# 并且每个元素都是一个有 key 和 value 组成的元组
# 索引我们可以直接循环它来获取 key 和 value
for item, val in d.items():
    print('{} : {}'.format(item, val))

# `items()`, `keys()` 与 `values()` 函数返回的结构都是从源字典中的拷贝出来的, 如果被操作的字典包含大量元素, 这将会导致内存的大量浪费, 相应的, 我们可以使用 `iteritems()`, `iterkeys()` 和 `itervalues()`, 这些函数返回一个可迭代对象, 可以对这些可迭代对象进行 `for` 循环获取其中的内容, 在循环可迭代对象时, 之后当前被处理的元素才会被保存到内存当中, 当处理完成以后, 就会从内存当中删除.
# 在 Python3 中, 对 `items()`, `keys()` 与 `values()` 这3个函数进行了重新处理, 他们全部返回 字典视图(directory view) 对象, 并且移除了 `iteritems()`, `iterkeys()` 和 `itervalues()` 函数.</code></pre>

<h1>字典推导式</h1>

<p>前面讲解列表时, 我们讲过了 列表推导式, 字典同样也存在推导式-&gt; 字典推导式</p>

<pre class="highlight"><code class="language-python">import os

# 列出当前文件所在目录下的所有文件的大小
# os.listdir() 返回指定目录下的文件列表
# os.path.isfile 判断是否是文件
file_size = {name: os.path.getsize(name) for name in os.listdir('.') if os.path.isfile(name)}
print(file_size)</code></pre>

<h1>default dictionary</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们访问一个字典中不存在的 键 时, 会抛出 KeyError 异常.
# 这是正确的行为, 因为我们需要知道这个键不存在某个字典中

# 但有些时候我们希望当键不存在时, 可以自动将这个键添加进去, 虽然上面我们提及了字典的 `setdefault()` 方法可以帮助我们达到这一目的.
# 但使用 default dictionaies 将会更加方便.

import collections

# defaultdict 接收一个工厂函数. 一个工厂函数就是当我们调用一个函数时, 这个函数能够返回给我们一个特定类型的对象.
# 所有 Python 内置的数据类型都可以被当做一个工厂函数来使用
# 比如前面我们讲解到的 `str()`, 能够返回一个字符串, `int()`, `float()`, `tuple()`, `set()`, `dict()` 都是工厂函数.
words = collections.defaultdict(int)
print(words['a'])
print(words)

sentences = collections.defaultdict(tuple)
print(sentences['word'])
print(sentences)

# 自定义默认值
cus_type = collections.defaultdict(lambda: [0, 0, 0])
print(cus_type['a'])
print(cus_type)</code></pre>

<h1>ordereddict</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections

d = collections.OrderedDict([('z', -4), ('e', 19), ('k', 7)])
print(d)

# 注意, 如果传递给 OrderedDict 的参数是一个无法保证顺序的对象, 比如另一个字典, 则生成出来的字典的顺序是随机的.
# 但是向上面那样传递一个 list, 或是 元组 则不会出现这种情况, 因为他们都是能够保证元素顺序的对象
plain_dict = {'a':1, 'b':2, 'c':3}
d2 = collections.OrderedDict(plain_dict)
print(d2)
# 包括使用 update()
d3 = collections.OrderedDict()
d3.update(plain_dict)
print(d3)
# 因此我们应当避免使用一个元素顺序不保证的对象作为参数传递给 OrderedDict()

# 通过向字典中追加新元素的方式, 将会严格保证键值的顺序
tasks = collections.OrderedDict()
tasks[8031] = 'Backup'
tasks[4027] = 'Scan Email'
tasks[5733] = 'Build System'
print(tasks)
# 输出字典的键, 其顺序一定是按照上面的顺序下来的.
print(tasks.keys())

# 如果我们想要将一个元素移动到字典的结尾, 必须先要删除这个元素, 在将这个元素追加进字典中才能实现
tasks[4027] = tasks.pop(4027)
print(tasks)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="逻辑控制" data-title="00_control_structures" id="_____00_control_structures1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="逻辑控制/00_control_structures:1">
<h1>逻辑控制</h1>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>条件判断</h1>

<p>每个条件判断中可以有有0个或多个 <code>elif</code>.<br>
最后的 <code>else</code> 也是可选的</p>

<h1>单行条件表达式</h1>

<pre class="highlight"><code class="language-python"># 错误, Python 将会吧 (100 + 10) 作为一个表达式,
# 当 cus 为 False 时, 结果为 0
width = 100 + 10 if cus else 0
# 可以使用括号
width = 100 + (10 if cus else 0)

# 可以很方便与其他语句一起合用
print("{0} file{1}".format((count if count != 0 else 'no'), ('s' if count !=1 else '')))</code></pre>

<h1>while</h1>

<p>正常退出是指: whild 循环没有被 <code>break</code>, <code>return</code> 语句打断, 或是没有异常发生.</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

num = 5

while num:
    # 当遇到 break 时, else 语句将不会被执行
    if num == 3:
        break
    print(num)
    num -= 1
else:
    print('end loop')

# elese 为可选语句
# 如果 while 语句正常退出, else 语句将总是被执行
# 但是如果在 while 语句中有 break, return,或是有异常抛出
# else 语句将不会被执行</code></pre>

<h1>for</h1>

<pre class="highlight"><code class="language-python"># for
# for in 循环中的 else 语句与 whil 中的一样
for i in range(0, 5):
    print(i)
else:
    print('end for')</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="逻辑控制" data-title="00_control_structures" id="_____00_control_structures2" class="slide" data-transition="turnUp">
<div class="content " ref="逻辑控制/00_control_structures:2">
<h1>条件判断</h1>

<p>语法:</p>

<pre class="highlight"><code class="language-python">if boolen_expression1:
    suite1
elif boolen_expression2:
    suite2
...
elif boolen_expressionN:
    suiteN
else
    else_suit</code></pre>

<p>每个条件判断语句中都可以包含 0 个或多个 <code>elif</code> 字句.<br>
最后的 <code>else</code> 是可选的.</p>

<p>最简单的判断语句:</p>

<pre class="highlight"><code class="language-python execute">if True: pass</code></pre>

<p class="callout info"><code>pass</code> 表示什么也不做</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>条件判断</h1>

<p>每个条件判断中可以有有0个或多个 <code>elif</code>.<br>
最后的 <code>else</code> 也是可选的</p>

<h1>单行条件表达式</h1>

<pre class="highlight"><code class="language-python"># 错误, Python 将会吧 (100 + 10) 作为一个表达式,
# 当 cus 为 False 时, 结果为 0
width = 100 + 10 if cus else 0
# 可以使用括号
width = 100 + (10 if cus else 0)

# 可以很方便与其他语句一起合用
print("{0} file{1}".format((count if count != 0 else 'no'), ('s' if count !=1 else '')))</code></pre>

<h1>while</h1>

<p>正常退出是指: whild 循环没有被 <code>break</code>, <code>return</code> 语句打断, 或是没有异常发生.</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

num = 5

while num:
    # 当遇到 break 时, else 语句将不会被执行
    if num == 3:
        break
    print(num)
    num -= 1
else:
    print('end loop')

# elese 为可选语句
# 如果 while 语句正常退出, else 语句将总是被执行
# 但是如果在 while 语句中有 break, return,或是有异常抛出
# else 语句将不会被执行</code></pre>

<h1>for</h1>

<pre class="highlight"><code class="language-python"># for
# for in 循环中的 else 语句与 whil 中的一样
for i in range(0, 5):
    print(i)
else:
    print('end for')</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="逻辑控制" data-title="00_control_structures" id="_____00_control_structures3" class="slide" data-transition="turnUp">
<div class="content " ref="逻辑控制/00_control_structures:3">
<h1>单行判断语句</h1>

<pre class="highlight"><code class="language-python">expression1 if boolan_expression else expression2</code></pre>

<p>如果表达式 <code>boolan_expression</code> 的值为</p>

<ul>
<li>
<code>True</code> 表达式返回结果为 <code>expression1</code>
</li>
<li>
<code>False</code>: 表达式返回结果为 <code>expression2</code>
</li>
</ul>

<p>示例:</p>

<pre class="highlight"><code class="language-python">print("{0} file{1}".format(
    (count if count != 0 else 'no'),
    ('s' if count !=1 else ''))
)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>条件判断</h1>

<p>每个条件判断中可以有有0个或多个 <code>elif</code>.<br>
最后的 <code>else</code> 也是可选的</p>

<h1>单行条件表达式</h1>

<pre class="highlight"><code class="language-python"># 错误, Python 将会吧 (100 + 10) 作为一个表达式,
# 当 cus 为 False 时, 结果为 0
width = 100 + 10 if cus else 0
# 可以使用括号
width = 100 + (10 if cus else 0)

# 可以很方便与其他语句一起合用
print("{0} file{1}".format((count if count != 0 else 'no'), ('s' if count !=1 else '')))</code></pre>

<h1>while</h1>

<p>正常退出是指: whild 循环没有被 <code>break</code>, <code>return</code> 语句打断, 或是没有异常发生.</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

num = 5

while num:
    # 当遇到 break 时, else 语句将不会被执行
    if num == 3:
        break
    print(num)
    num -= 1
else:
    print('end loop')

# elese 为可选语句
# 如果 while 语句正常退出, else 语句将总是被执行
# 但是如果在 while 语句中有 break, return,或是有异常抛出
# else 语句将不会被执行</code></pre>

<h1>for</h1>

<pre class="highlight"><code class="language-python"># for
# for in 循环中的 else 语句与 whil 中的一样
for i in range(0, 5):
    print(i)
else:
    print('end for')</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="逻辑控制" data-title="00_control_structures" id="_____00_control_structures4" class="slide" data-transition="turnUp">
<div class="content " ref="逻辑控制/00_control_structures:4">
<h1>循环</h1>

<p>Python 提供两种: <code>for...in</code> 和 <code>while</code></p>

<h2><code>while</code></h2>

<pre class="highlight"><code class="language-python">while boolen_expression:
    while_suite
else:
    else_suite</code></pre>

<p><code>else</code> 为可选语句, 当循环正常退出时, <code>else</code> 子句将被调用</p>

<h2><code>for ... in</code></h2>

<pre class="highlight"><code class="language-python">for expression in iterable:
    for_suite
else:
    else_suite</code></pre>

<p>和 while 一样, <code>else</code> 为可选语句, 当循环正常退出时, <code>else</code> 子句将被调用</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>条件判断</h1>

<p>每个条件判断中可以有有0个或多个 <code>elif</code>.<br>
最后的 <code>else</code> 也是可选的</p>

<h1>单行条件表达式</h1>

<pre class="highlight"><code class="language-python"># 错误, Python 将会吧 (100 + 10) 作为一个表达式,
# 当 cus 为 False 时, 结果为 0
width = 100 + 10 if cus else 0
# 可以使用括号
width = 100 + (10 if cus else 0)

# 可以很方便与其他语句一起合用
print("{0} file{1}".format((count if count != 0 else 'no'), ('s' if count !=1 else '')))</code></pre>

<h1>while</h1>

<p>正常退出是指: whild 循环没有被 <code>break</code>, <code>return</code> 语句打断, 或是没有异常发生.</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

num = 5

while num:
    # 当遇到 break 时, else 语句将不会被执行
    if num == 3:
        break
    print(num)
    num -= 1
else:
    print('end loop')

# elese 为可选语句
# 如果 while 语句正常退出, else 语句将总是被执行
# 但是如果在 while 语句中有 break, return,或是有异常抛出
# else 语句将不会被执行</code></pre>

<h1>for</h1>

<pre class="highlight"><code class="language-python"># for
# for in 循环中的 else 语句与 whil 中的一样
for i in range(0, 5):
    print(i)
else:
    print('end for')</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="00_function" id="___00_function" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="函数/00_function">
<h1>函数</h1>

<ul>
<li>全局函数</li>
<li>局部函数</li>
<li>lambda 函数</li>
<li>方法</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>全局函数</h1>

<p>当在一个 Python 文件中直接定义一个函数时, 这个函数就是全局函数. 全局函数可以被一个文件内的任何代码所访问, 并且函数所在文件如果被其他文件引入, 全局函数还可以被其他文件内的代码所调用.</p>

<h1>局部函数</h1>

<p>局部函数就是定义在一个函数或者代码块内的函数, 局部函数只能被所在的代码块内所访问, 在后面介绍闭包时我们会在详细说明</p>

<h1>lambda</h1>

<p>Python 提供的一种定义函数的特殊方式</p>

<h1>方法</h1>

<p>我的理解是, 方法其实就是定义在类中的函数.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="01_global_func" id="___01_global_func1" class="slide" data-transition="turnUp">
<div class="content " ref="函数/01_global_func:1">
<h1>函数的定义</h1>

<h2>语法</h2>

<pre class="highlight"><code class="language-python">def functionName(parameters):
    '''function help document'''
    suite</code></pre>

<p>通过 Python 中的关键 <code>def</code> 来定义函数</p>

<pre class="highlight"><code class="language-python">def cal_sum(a, b, c):
    return a + b + c</code></pre>

<p>一旦我们定义了一个函数后, 就可以在定义函数后的任何代码中调用该函数了, 格式为</p>

<pre class="highlight"><code class="language-python">func_name(parameters)</code></pre>

<p class="callout warning">由于 Python 是解释性语言, 解释顺序由上至下, 因此一定要先定义函数之后, 之可以调用这个函数.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>定义</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 使用 def 关键字, 并且无需指定函数的返回类型
# 注意 冒号 和 缩进
def test():
    print('hello')

# 当定义好函数后, 就可以使用函数名后跟一个括号的方式调用这个函数了
test()</code></pre>

<h1>函数返回值</h1>

<p>在 Python 中, 所有的函数都有且只有一个返回值, return 关键字用来终止函数的执行, 并将提供给 return 的参数(任意类型)返回给函数的调用者. 如果 return 后面没有提供任何参数, 或执行到函数体结尾, 没有通过 return 关键字返回, 函数也将同样返回 None.
None 与其他编程语言中的 null 类似, 表示什么都没有.</p>

<pre class="highlight"><code class="language-python">def test():
    print('hello')

    # 指定一个返回值
    return True
    # 虽然只能返回一个值
    # 但是可以返回任意类型的值
    # 返回一个元素
    return 1, 2, 3

a = test()

# 返回一个元组
a, b, c = test()
print(a)
print(b)
print(c)</code></pre>

<h1>带参数的函数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数时还可以指定接收的参数
# 这样在调用函数时, 就可以向它传递自定义参数了
def cal_sum(a, b, c):
    return a + b + c
# 注意, 传递给函数的参数个数一定要与函数定义的个数一样,
# 否则会抛出 TypeError 异常
cal_sum(1, 2, 3)

# 通过这种方式传递的参数是按照位置传递的
def cal_sum(a, b, c):
    print(a)
    print(b)
    print(c)
    return a + b + c
# 在调用函数时, 还可以直接指定参数名
cal_sum(c=1, a=2, b=5)</code></pre>

<h1>默认值参数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数的时候, 还可以为参数提供默认值.
def cal_sum(a, b, c=5):
# 这样, 我们就可以在调用函数的地方忽略这些有默认值的参数
print(cal_sum(1, 2))

# 但是, 如果定义函数时提供了有默认值的参数
# 带默认值的参数一定要放到没有默认值的参数的后面. 否则会提示语法错误
# def cal_sum(a=5, b, c) 将会提示错</code></pre>

<h1>可变类型作为参数</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 两个参数: 一个整数和一个列表
# 判断给定的参数 X 是否是偶数
# 如果是偶数, 就把x追加到第二个参数指定的列表中
# 并且在定义函数时, 第二个参数指定了一个空列表作为它的默认值.
def append_if_event(x, lst=[]):
    #  print(id(lst))
    if x % 2 == 0:
        lst.append(x)
    return lst

# 传递2个参数
#  print(append_if_event(2, [100, 200]))
# 也可以忽略第二个参数, 使用默认的空列表
print(append_if_event(2))
# 把 2 修改成 3, 结果也正常</code></pre>

<p>同时调用多次
    @@@ python
    print(append_if_event(2))
    print(append_if_event(3))
    print(append_if_event(4))</p>

<pre><code># 在指定一个list作为参数, 而不使用默认值
print(append_if_event(6, []))

# 前三次使用默认值的方式调用函数时, 他们共用了一个 lst 列表变量.
# 第四次指定了一个默认的 lst 变量, 表现正常

# 从结果可以看出, 前3次调用, 使用了同一个列表
# 可以通过打印出列表的 id 查看一下
print(id(lst))

# 只有最后一次的调用, 使用了一个新的列表

# 这是因为
# Python 中参数的默认值是在函数编译的时候就已经确定好了的,
# 而并不是在每次调用的时候重新创建的,
# 所以每次调用函数的时候指向的都是同一个在编译时定义好了的对象.
# 当在函数体内修改这个可变类型参数的默认值时, 每次修改的都是同一个对象.

# 但是如果默认参数是一个不可变类型就不会发生这种现象
# 这是因为不可变类型在每次修改后都会重新生成一个新的对象,
# 在讲解整数的时候我们就已经讲过这个了.
# 所以不可变类型作为参数的默认值不会有任何问题.
</code></pre>

<h2>解决</h2>

<pre class="highlight"><code class="language-python"># 不要将可变参数作为默认值
# 而是在函数内每次都创建一个新的列表
def append_if_event(x, lst=None):
    if lst is None:
        lst = []
    if x % 2 == 0:
        lst.append(x)
    return lst</code></pre>

<h1>定义参数可变的函数</h1>

<p>前面将的函数, 接收的参数全是固定的, Python 还支持定义参数不固定的函数, 参数不固定只函数可以接收任意个数的参数.</p>

<p>在前面讲解列表和字典的时候我们已经见过了, 可以使用一个 <code>*</code> 号来解压多个值到一个变量中, python 中的函数参数也可以使用类似的方式</p>

<pre class="highlight"><code class="language-python"># 在参数前面使用一个星号
# 所有的参数将全部保存到这个参数中
def test(*args):
    for i in args:
        print(i)

test('a', 'b', 'c')</code></pre>

<h2>带其它参数</h2>

<pre class="highlight"><code class="language-python"># 参数列表中还可以指定一个或多个必要参数
def test(a, *args):
    print('a is {}'.format(a))
    for i in args:
        print(i)

# a 将传递给 a 参数
# b和c将传递给 args 参数
test('a', 'b', 'c')
# 注意 a 和 *args 的顺序</code></pre>

<h2>字典参数</h2>

<p>前面讲过了, 调用一个函数时, 我们还可以指定参数的名字. Python 同样可以接受任意个指定了名字的参数</p>

<pre class="highlight"><code class="language-python"># 通过使用两个星号来存储命名的参数.
def test(a, *args, **kvargs):
    print('a is {}'.format(a))
    for i in args:
        print(i)
    for key, val in kvargs.items():
        print("{} -&gt; {}".format(key, val))

test('a', 'b', 'c', val1='val1', val2='val2')</code></pre>

<h2>将参数保存到元组和字典中</h2>

<pre class="highlight"><code class="language-python"># 我们还可以直接传递一个元组和字典作为参数给函数
args = ('b', 'c')
kvargs = {'val1': 'val1', 'val2': 'val2'}
# 传递的时候同样需要使用*和**解压元组的字典
test('a', *args, **kvargs)</code></pre>

<hr>

<pre class="highlight"><code class="language-python">def product(a, b=1, *args, **kargs):
print('a: {}'.format(a))
print('b: {}'.format(b))

for arg in args:
    print(arg)
for key,val in kargs.items():
    print('{}: {}'.format(key, val))

param1 = ('a', 'b', 'c')
param2 = {'m': 'm', 'n': 'n'}
product(1, 2, *param1, **param2)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="01_global_func" id="___01_global_func2" class="slide" data-transition="turnUp">
<div class="content " ref="函数/01_global_func:2">
<h1>函数的返回值</h1>

<p>当定义一个函数时, 我们无需声明函数返回值的类型,</p>

<p>在 Python 中, 所有的函数都有且只有一个返回值, <code>return</code> 关键字用来终止函数的执行, 并将提供给 return 的参数(任意类型)返回给函数的调用者. 如果 <code>return</code> 后面没有提供任何参数, 或执行到函数体结尾, 没有通过 <code>return</code> 关键字返回, 函数也将同样返回 <code>None</code>.<br>
<code>None</code> 与其他编程语言中的 <code>null</code> 类似, 表示什么都没有.</p>

<h2>函数帮助文档</h2>

<p>在定义函数时, 可以使用 <code>'''</code> 为函数定义帮助文档信息.通过 <code>functionName.__doc__</code> 获取帮助文档信息.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>定义</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 使用 def 关键字, 并且无需指定函数的返回类型
# 注意 冒号 和 缩进
def test():
    print('hello')

# 当定义好函数后, 就可以使用函数名后跟一个括号的方式调用这个函数了
test()</code></pre>

<h1>函数返回值</h1>

<p>在 Python 中, 所有的函数都有且只有一个返回值, return 关键字用来终止函数的执行, 并将提供给 return 的参数(任意类型)返回给函数的调用者. 如果 return 后面没有提供任何参数, 或执行到函数体结尾, 没有通过 return 关键字返回, 函数也将同样返回 None.
None 与其他编程语言中的 null 类似, 表示什么都没有.</p>

<pre class="highlight"><code class="language-python">def test():
    print('hello')

    # 指定一个返回值
    return True
    # 虽然只能返回一个值
    # 但是可以返回任意类型的值
    # 返回一个元素
    return 1, 2, 3

a = test()

# 返回一个元组
a, b, c = test()
print(a)
print(b)
print(c)</code></pre>

<h1>带参数的函数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数时还可以指定接收的参数
# 这样在调用函数时, 就可以向它传递自定义参数了
def cal_sum(a, b, c):
    return a + b + c
# 注意, 传递给函数的参数个数一定要与函数定义的个数一样,
# 否则会抛出 TypeError 异常
cal_sum(1, 2, 3)

# 通过这种方式传递的参数是按照位置传递的
def cal_sum(a, b, c):
    print(a)
    print(b)
    print(c)
    return a + b + c
# 在调用函数时, 还可以直接指定参数名
cal_sum(c=1, a=2, b=5)</code></pre>

<h1>默认值参数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数的时候, 还可以为参数提供默认值.
def cal_sum(a, b, c=5):
# 这样, 我们就可以在调用函数的地方忽略这些有默认值的参数
print(cal_sum(1, 2))

# 但是, 如果定义函数时提供了有默认值的参数
# 带默认值的参数一定要放到没有默认值的参数的后面. 否则会提示语法错误
# def cal_sum(a=5, b, c) 将会提示错</code></pre>

<h1>可变类型作为参数</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 两个参数: 一个整数和一个列表
# 判断给定的参数 X 是否是偶数
# 如果是偶数, 就把x追加到第二个参数指定的列表中
# 并且在定义函数时, 第二个参数指定了一个空列表作为它的默认值.
def append_if_event(x, lst=[]):
    #  print(id(lst))
    if x % 2 == 0:
        lst.append(x)
    return lst

# 传递2个参数
#  print(append_if_event(2, [100, 200]))
# 也可以忽略第二个参数, 使用默认的空列表
print(append_if_event(2))
# 把 2 修改成 3, 结果也正常</code></pre>

<p>同时调用多次
    @@@ python
    print(append_if_event(2))
    print(append_if_event(3))
    print(append_if_event(4))</p>

<pre><code># 在指定一个list作为参数, 而不使用默认值
print(append_if_event(6, []))

# 前三次使用默认值的方式调用函数时, 他们共用了一个 lst 列表变量.
# 第四次指定了一个默认的 lst 变量, 表现正常

# 从结果可以看出, 前3次调用, 使用了同一个列表
# 可以通过打印出列表的 id 查看一下
print(id(lst))

# 只有最后一次的调用, 使用了一个新的列表

# 这是因为
# Python 中参数的默认值是在函数编译的时候就已经确定好了的,
# 而并不是在每次调用的时候重新创建的,
# 所以每次调用函数的时候指向的都是同一个在编译时定义好了的对象.
# 当在函数体内修改这个可变类型参数的默认值时, 每次修改的都是同一个对象.

# 但是如果默认参数是一个不可变类型就不会发生这种现象
# 这是因为不可变类型在每次修改后都会重新生成一个新的对象,
# 在讲解整数的时候我们就已经讲过这个了.
# 所以不可变类型作为参数的默认值不会有任何问题.
</code></pre>

<h2>解决</h2>

<pre class="highlight"><code class="language-python"># 不要将可变参数作为默认值
# 而是在函数内每次都创建一个新的列表
def append_if_event(x, lst=None):
    if lst is None:
        lst = []
    if x % 2 == 0:
        lst.append(x)
    return lst</code></pre>

<h1>定义参数可变的函数</h1>

<p>前面将的函数, 接收的参数全是固定的, Python 还支持定义参数不固定的函数, 参数不固定只函数可以接收任意个数的参数.</p>

<p>在前面讲解列表和字典的时候我们已经见过了, 可以使用一个 <code>*</code> 号来解压多个值到一个变量中, python 中的函数参数也可以使用类似的方式</p>

<pre class="highlight"><code class="language-python"># 在参数前面使用一个星号
# 所有的参数将全部保存到这个参数中
def test(*args):
    for i in args:
        print(i)

test('a', 'b', 'c')</code></pre>

<h2>带其它参数</h2>

<pre class="highlight"><code class="language-python"># 参数列表中还可以指定一个或多个必要参数
def test(a, *args):
    print('a is {}'.format(a))
    for i in args:
        print(i)

# a 将传递给 a 参数
# b和c将传递给 args 参数
test('a', 'b', 'c')
# 注意 a 和 *args 的顺序</code></pre>

<h2>字典参数</h2>

<p>前面讲过了, 调用一个函数时, 我们还可以指定参数的名字. Python 同样可以接受任意个指定了名字的参数</p>

<pre class="highlight"><code class="language-python"># 通过使用两个星号来存储命名的参数.
def test(a, *args, **kvargs):
    print('a is {}'.format(a))
    for i in args:
        print(i)
    for key, val in kvargs.items():
        print("{} -&gt; {}".format(key, val))

test('a', 'b', 'c', val1='val1', val2='val2')</code></pre>

<h2>将参数保存到元组和字典中</h2>

<pre class="highlight"><code class="language-python"># 我们还可以直接传递一个元组和字典作为参数给函数
args = ('b', 'c')
kvargs = {'val1': 'val1', 'val2': 'val2'}
# 传递的时候同样需要使用*和**解压元组的字典
test('a', *args, **kvargs)</code></pre>

<hr>

<pre class="highlight"><code class="language-python">def product(a, b=1, *args, **kargs):
print('a: {}'.format(a))
print('b: {}'.format(b))

for arg in args:
    print(arg)
for key,val in kargs.items():
    print('{}: {}'.format(key, val))

param1 = ('a', 'b', 'c')
param2 = {'m': 'm', 'n': 'n'}
product(1, 2, *param1, **param2)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="01_global_func" id="___01_global_func3" class="slide" data-transition="turnUp">
<div class="content " ref="函数/01_global_func:3">
<h1>函数的参数</h1>

<p>定义函数时, 可以指定函数可以接收的参数, 参数个数可以为为 0 个, 也可以为多个, 各个参数之间用逗号(<code>,</code>)分隔.</p>

<p>调用函数时, 提供给函数的参数个数一定要与定义时的个数保持一致, 否则会抛出 <code>TypeError</code> 异常.</p>

<p>在这种情况下, 函数中的参数是通过参数的位置进行传递的.</p>

<h2>带默认值的参数</h2>

<pre class="highlight"><code class="language-python">def cal_sum(a, b, c=5): pass</code></pre>

<p>在定义函数时, 如果指定了带默认值的参数, 则在调用该函数时, 带有默认值的参数可以忽略不写.</p>

<p>带默认值的参数一定要放到没有默认值的参数后面, 否则会报出语法错误.</p>

<p class="callout warning">当定义函数时指定了带有默认值的参数时, 带默认值的参数必须放到没有默认值的参数后面.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>定义</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 使用 def 关键字, 并且无需指定函数的返回类型
# 注意 冒号 和 缩进
def test():
    print('hello')

# 当定义好函数后, 就可以使用函数名后跟一个括号的方式调用这个函数了
test()</code></pre>

<h1>函数返回值</h1>

<p>在 Python 中, 所有的函数都有且只有一个返回值, return 关键字用来终止函数的执行, 并将提供给 return 的参数(任意类型)返回给函数的调用者. 如果 return 后面没有提供任何参数, 或执行到函数体结尾, 没有通过 return 关键字返回, 函数也将同样返回 None.
None 与其他编程语言中的 null 类似, 表示什么都没有.</p>

<pre class="highlight"><code class="language-python">def test():
    print('hello')

    # 指定一个返回值
    return True
    # 虽然只能返回一个值
    # 但是可以返回任意类型的值
    # 返回一个元素
    return 1, 2, 3

a = test()

# 返回一个元组
a, b, c = test()
print(a)
print(b)
print(c)</code></pre>

<h1>带参数的函数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数时还可以指定接收的参数
# 这样在调用函数时, 就可以向它传递自定义参数了
def cal_sum(a, b, c):
    return a + b + c
# 注意, 传递给函数的参数个数一定要与函数定义的个数一样,
# 否则会抛出 TypeError 异常
cal_sum(1, 2, 3)

# 通过这种方式传递的参数是按照位置传递的
def cal_sum(a, b, c):
    print(a)
    print(b)
    print(c)
    return a + b + c
# 在调用函数时, 还可以直接指定参数名
cal_sum(c=1, a=2, b=5)</code></pre>

<h1>默认值参数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数的时候, 还可以为参数提供默认值.
def cal_sum(a, b, c=5):
# 这样, 我们就可以在调用函数的地方忽略这些有默认值的参数
print(cal_sum(1, 2))

# 但是, 如果定义函数时提供了有默认值的参数
# 带默认值的参数一定要放到没有默认值的参数的后面. 否则会提示语法错误
# def cal_sum(a=5, b, c) 将会提示错</code></pre>

<h1>可变类型作为参数</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 两个参数: 一个整数和一个列表
# 判断给定的参数 X 是否是偶数
# 如果是偶数, 就把x追加到第二个参数指定的列表中
# 并且在定义函数时, 第二个参数指定了一个空列表作为它的默认值.
def append_if_event(x, lst=[]):
    #  print(id(lst))
    if x % 2 == 0:
        lst.append(x)
    return lst

# 传递2个参数
#  print(append_if_event(2, [100, 200]))
# 也可以忽略第二个参数, 使用默认的空列表
print(append_if_event(2))
# 把 2 修改成 3, 结果也正常</code></pre>

<p>同时调用多次
    @@@ python
    print(append_if_event(2))
    print(append_if_event(3))
    print(append_if_event(4))</p>

<pre><code># 在指定一个list作为参数, 而不使用默认值
print(append_if_event(6, []))

# 前三次使用默认值的方式调用函数时, 他们共用了一个 lst 列表变量.
# 第四次指定了一个默认的 lst 变量, 表现正常

# 从结果可以看出, 前3次调用, 使用了同一个列表
# 可以通过打印出列表的 id 查看一下
print(id(lst))

# 只有最后一次的调用, 使用了一个新的列表

# 这是因为
# Python 中参数的默认值是在函数编译的时候就已经确定好了的,
# 而并不是在每次调用的时候重新创建的,
# 所以每次调用函数的时候指向的都是同一个在编译时定义好了的对象.
# 当在函数体内修改这个可变类型参数的默认值时, 每次修改的都是同一个对象.

# 但是如果默认参数是一个不可变类型就不会发生这种现象
# 这是因为不可变类型在每次修改后都会重新生成一个新的对象,
# 在讲解整数的时候我们就已经讲过这个了.
# 所以不可变类型作为参数的默认值不会有任何问题.
</code></pre>

<h2>解决</h2>

<pre class="highlight"><code class="language-python"># 不要将可变参数作为默认值
# 而是在函数内每次都创建一个新的列表
def append_if_event(x, lst=None):
    if lst is None:
        lst = []
    if x % 2 == 0:
        lst.append(x)
    return lst</code></pre>

<h1>定义参数可变的函数</h1>

<p>前面将的函数, 接收的参数全是固定的, Python 还支持定义参数不固定的函数, 参数不固定只函数可以接收任意个数的参数.</p>

<p>在前面讲解列表和字典的时候我们已经见过了, 可以使用一个 <code>*</code> 号来解压多个值到一个变量中, python 中的函数参数也可以使用类似的方式</p>

<pre class="highlight"><code class="language-python"># 在参数前面使用一个星号
# 所有的参数将全部保存到这个参数中
def test(*args):
    for i in args:
        print(i)

test('a', 'b', 'c')</code></pre>

<h2>带其它参数</h2>

<pre class="highlight"><code class="language-python"># 参数列表中还可以指定一个或多个必要参数
def test(a, *args):
    print('a is {}'.format(a))
    for i in args:
        print(i)

# a 将传递给 a 参数
# b和c将传递给 args 参数
test('a', 'b', 'c')
# 注意 a 和 *args 的顺序</code></pre>

<h2>字典参数</h2>

<p>前面讲过了, 调用一个函数时, 我们还可以指定参数的名字. Python 同样可以接受任意个指定了名字的参数</p>

<pre class="highlight"><code class="language-python"># 通过使用两个星号来存储命名的参数.
def test(a, *args, **kvargs):
    print('a is {}'.format(a))
    for i in args:
        print(i)
    for key, val in kvargs.items():
        print("{} -&gt; {}".format(key, val))

test('a', 'b', 'c', val1='val1', val2='val2')</code></pre>

<h2>将参数保存到元组和字典中</h2>

<pre class="highlight"><code class="language-python"># 我们还可以直接传递一个元组和字典作为参数给函数
args = ('b', 'c')
kvargs = {'val1': 'val1', 'val2': 'val2'}
# 传递的时候同样需要使用*和**解压元组的字典
test('a', *args, **kvargs)</code></pre>

<hr>

<pre class="highlight"><code class="language-python">def product(a, b=1, *args, **kargs):
print('a: {}'.format(a))
print('b: {}'.format(b))

for arg in args:
    print(arg)
for key,val in kargs.items():
    print('{}: {}'.format(key, val))

param1 = ('a', 'b', 'c')
param2 = {'m': 'm', 'n': 'n'}
product(1, 2, *param1, **param2)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="01_global_func" id="___01_global_func4" class="slide" data-transition="turnUp">
<div class="content " ref="函数/01_global_func:4">
<h1>小心可变类型作为参数的默认值</h1>

<pre class="highlight"><code class="language-python">def append_if_event(x, lst=[]):
    if x % 2 == 0:
        lst.append(x)
    return lst
print(append_if_event(2))
print(append_if_event(3))
print(append_if_event(4))
print(append_if_event(6, []))</code></pre>

<p>Python 中参数的默认值是在函数编译的时候就已经确定好了的, 而并不是在每次调用的时候重新创建的, 所以每次调用函数的时候指向的都是同一个在编译时定义好了的对象.<br>
当在函数体内修改这个可变类型参数的默认值时, 每次修改的都是同一个对象.<br>
而不可变类型在每次修改后都会重新生成一个新的对象, 所以不可变类型作为参数的默认值不会有任何问题.</p>

<p>解决</p>

<pre class="highlight"><code class="language-python">def append_if_event(x, lst=None):
    if lst is None:
        lst = []
    if x % 2 == 0:
        lst.append(x)
    return lst
print(append_if_event(2))
print(append_if_event(3))
print(append_if_event(4))
print(append_if_event(6, []))</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>定义</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 使用 def 关键字, 并且无需指定函数的返回类型
# 注意 冒号 和 缩进
def test():
    print('hello')

# 当定义好函数后, 就可以使用函数名后跟一个括号的方式调用这个函数了
test()</code></pre>

<h1>函数返回值</h1>

<p>在 Python 中, 所有的函数都有且只有一个返回值, return 关键字用来终止函数的执行, 并将提供给 return 的参数(任意类型)返回给函数的调用者. 如果 return 后面没有提供任何参数, 或执行到函数体结尾, 没有通过 return 关键字返回, 函数也将同样返回 None.
None 与其他编程语言中的 null 类似, 表示什么都没有.</p>

<pre class="highlight"><code class="language-python">def test():
    print('hello')

    # 指定一个返回值
    return True
    # 虽然只能返回一个值
    # 但是可以返回任意类型的值
    # 返回一个元素
    return 1, 2, 3

a = test()

# 返回一个元组
a, b, c = test()
print(a)
print(b)
print(c)</code></pre>

<h1>带参数的函数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数时还可以指定接收的参数
# 这样在调用函数时, 就可以向它传递自定义参数了
def cal_sum(a, b, c):
    return a + b + c
# 注意, 传递给函数的参数个数一定要与函数定义的个数一样,
# 否则会抛出 TypeError 异常
cal_sum(1, 2, 3)

# 通过这种方式传递的参数是按照位置传递的
def cal_sum(a, b, c):
    print(a)
    print(b)
    print(c)
    return a + b + c
# 在调用函数时, 还可以直接指定参数名
cal_sum(c=1, a=2, b=5)</code></pre>

<h1>默认值参数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数的时候, 还可以为参数提供默认值.
def cal_sum(a, b, c=5):
# 这样, 我们就可以在调用函数的地方忽略这些有默认值的参数
print(cal_sum(1, 2))

# 但是, 如果定义函数时提供了有默认值的参数
# 带默认值的参数一定要放到没有默认值的参数的后面. 否则会提示语法错误
# def cal_sum(a=5, b, c) 将会提示错</code></pre>

<h1>可变类型作为参数</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 两个参数: 一个整数和一个列表
# 判断给定的参数 X 是否是偶数
# 如果是偶数, 就把x追加到第二个参数指定的列表中
# 并且在定义函数时, 第二个参数指定了一个空列表作为它的默认值.
def append_if_event(x, lst=[]):
    #  print(id(lst))
    if x % 2 == 0:
        lst.append(x)
    return lst

# 传递2个参数
#  print(append_if_event(2, [100, 200]))
# 也可以忽略第二个参数, 使用默认的空列表
print(append_if_event(2))
# 把 2 修改成 3, 结果也正常</code></pre>

<p>同时调用多次
    @@@ python
    print(append_if_event(2))
    print(append_if_event(3))
    print(append_if_event(4))</p>

<pre><code># 在指定一个list作为参数, 而不使用默认值
print(append_if_event(6, []))

# 前三次使用默认值的方式调用函数时, 他们共用了一个 lst 列表变量.
# 第四次指定了一个默认的 lst 变量, 表现正常

# 从结果可以看出, 前3次调用, 使用了同一个列表
# 可以通过打印出列表的 id 查看一下
print(id(lst))

# 只有最后一次的调用, 使用了一个新的列表

# 这是因为
# Python 中参数的默认值是在函数编译的时候就已经确定好了的,
# 而并不是在每次调用的时候重新创建的,
# 所以每次调用函数的时候指向的都是同一个在编译时定义好了的对象.
# 当在函数体内修改这个可变类型参数的默认值时, 每次修改的都是同一个对象.

# 但是如果默认参数是一个不可变类型就不会发生这种现象
# 这是因为不可变类型在每次修改后都会重新生成一个新的对象,
# 在讲解整数的时候我们就已经讲过这个了.
# 所以不可变类型作为参数的默认值不会有任何问题.
</code></pre>

<h2>解决</h2>

<pre class="highlight"><code class="language-python"># 不要将可变参数作为默认值
# 而是在函数内每次都创建一个新的列表
def append_if_event(x, lst=None):
    if lst is None:
        lst = []
    if x % 2 == 0:
        lst.append(x)
    return lst</code></pre>

<h1>定义参数可变的函数</h1>

<p>前面将的函数, 接收的参数全是固定的, Python 还支持定义参数不固定的函数, 参数不固定只函数可以接收任意个数的参数.</p>

<p>在前面讲解列表和字典的时候我们已经见过了, 可以使用一个 <code>*</code> 号来解压多个值到一个变量中, python 中的函数参数也可以使用类似的方式</p>

<pre class="highlight"><code class="language-python"># 在参数前面使用一个星号
# 所有的参数将全部保存到这个参数中
def test(*args):
    for i in args:
        print(i)

test('a', 'b', 'c')</code></pre>

<h2>带其它参数</h2>

<pre class="highlight"><code class="language-python"># 参数列表中还可以指定一个或多个必要参数
def test(a, *args):
    print('a is {}'.format(a))
    for i in args:
        print(i)

# a 将传递给 a 参数
# b和c将传递给 args 参数
test('a', 'b', 'c')
# 注意 a 和 *args 的顺序</code></pre>

<h2>字典参数</h2>

<p>前面讲过了, 调用一个函数时, 我们还可以指定参数的名字. Python 同样可以接受任意个指定了名字的参数</p>

<pre class="highlight"><code class="language-python"># 通过使用两个星号来存储命名的参数.
def test(a, *args, **kvargs):
    print('a is {}'.format(a))
    for i in args:
        print(i)
    for key, val in kvargs.items():
        print("{} -&gt; {}".format(key, val))

test('a', 'b', 'c', val1='val1', val2='val2')</code></pre>

<h2>将参数保存到元组和字典中</h2>

<pre class="highlight"><code class="language-python"># 我们还可以直接传递一个元组和字典作为参数给函数
args = ('b', 'c')
kvargs = {'val1': 'val1', 'val2': 'val2'}
# 传递的时候同样需要使用*和**解压元组的字典
test('a', *args, **kvargs)</code></pre>

<hr>

<pre class="highlight"><code class="language-python">def product(a, b=1, *args, **kargs):
print('a: {}'.format(a))
print('b: {}'.format(b))

for arg in args:
    print(arg)
for key,val in kargs.items():
    print('{}: {}'.format(key, val))

param1 = ('a', 'b', 'c')
param2 = {'m': 'm', 'n': 'n'}
product(1, 2, *param1, **param2)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="01_global_func" id="___01_global_func5" class="slide" data-transition="turnUp">
<div class="content " ref="函数/01_global_func:5">
<h1>定义参数可变的函数</h1>

<ul>
<li>
<code>*</code> 用来保存所有未命名的参数, 元组类型</li>
<li>
<code>**</code> 用来保存所有命名的参数, 字典类型, 格式为: {参数名:参数值}</li>
</ul>

<p>示例:</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

def product(a, b=1, *args, **kargs):
    print('a: {}'.format(a))
    print('b: {}'.format(b))
    # 除去前两个参数 a 和 b
    # 所有剩余的未命名的参数全部存储到 args 变量中
    # 而所有带参数名的参数将全部传递给 kargs 变量中
    for arg in args:
        print(arg)
    for key,val in kargs.items():
        print('{}: {}'.format(key, val))

#  product(1, 2, 3, 4, x='5', y='6', z='7')

# 还可以将元组和字典直接作为参数传递给函数
param1 = ('a', 'b', 'c')
param2 = {'m': 'm', 'n': 'n'}
product(1, 2, *param1, **param2)
# 如果没有指定 a, b 两个参数
product(*param1, **param2)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>定义</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 使用 def 关键字, 并且无需指定函数的返回类型
# 注意 冒号 和 缩进
def test():
    print('hello')

# 当定义好函数后, 就可以使用函数名后跟一个括号的方式调用这个函数了
test()</code></pre>

<h1>函数返回值</h1>

<p>在 Python 中, 所有的函数都有且只有一个返回值, return 关键字用来终止函数的执行, 并将提供给 return 的参数(任意类型)返回给函数的调用者. 如果 return 后面没有提供任何参数, 或执行到函数体结尾, 没有通过 return 关键字返回, 函数也将同样返回 None.
None 与其他编程语言中的 null 类似, 表示什么都没有.</p>

<pre class="highlight"><code class="language-python">def test():
    print('hello')

    # 指定一个返回值
    return True
    # 虽然只能返回一个值
    # 但是可以返回任意类型的值
    # 返回一个元素
    return 1, 2, 3

a = test()

# 返回一个元组
a, b, c = test()
print(a)
print(b)
print(c)</code></pre>

<h1>带参数的函数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数时还可以指定接收的参数
# 这样在调用函数时, 就可以向它传递自定义参数了
def cal_sum(a, b, c):
    return a + b + c
# 注意, 传递给函数的参数个数一定要与函数定义的个数一样,
# 否则会抛出 TypeError 异常
cal_sum(1, 2, 3)

# 通过这种方式传递的参数是按照位置传递的
def cal_sum(a, b, c):
    print(a)
    print(b)
    print(c)
    return a + b + c
# 在调用函数时, 还可以直接指定参数名
cal_sum(c=1, a=2, b=5)</code></pre>

<h1>默认值参数</h1>

<pre class="highlight"><code class="language-python"># 在定义函数的时候, 还可以为参数提供默认值.
def cal_sum(a, b, c=5):
# 这样, 我们就可以在调用函数的地方忽略这些有默认值的参数
print(cal_sum(1, 2))

# 但是, 如果定义函数时提供了有默认值的参数
# 带默认值的参数一定要放到没有默认值的参数的后面. 否则会提示语法错误
# def cal_sum(a=5, b, c) 将会提示错</code></pre>

<h1>可变类型作为参数</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 两个参数: 一个整数和一个列表
# 判断给定的参数 X 是否是偶数
# 如果是偶数, 就把x追加到第二个参数指定的列表中
# 并且在定义函数时, 第二个参数指定了一个空列表作为它的默认值.
def append_if_event(x, lst=[]):
    #  print(id(lst))
    if x % 2 == 0:
        lst.append(x)
    return lst

# 传递2个参数
#  print(append_if_event(2, [100, 200]))
# 也可以忽略第二个参数, 使用默认的空列表
print(append_if_event(2))
# 把 2 修改成 3, 结果也正常</code></pre>

<p>同时调用多次
    @@@ python
    print(append_if_event(2))
    print(append_if_event(3))
    print(append_if_event(4))</p>

<pre><code># 在指定一个list作为参数, 而不使用默认值
print(append_if_event(6, []))

# 前三次使用默认值的方式调用函数时, 他们共用了一个 lst 列表变量.
# 第四次指定了一个默认的 lst 变量, 表现正常

# 从结果可以看出, 前3次调用, 使用了同一个列表
# 可以通过打印出列表的 id 查看一下
print(id(lst))

# 只有最后一次的调用, 使用了一个新的列表

# 这是因为
# Python 中参数的默认值是在函数编译的时候就已经确定好了的,
# 而并不是在每次调用的时候重新创建的,
# 所以每次调用函数的时候指向的都是同一个在编译时定义好了的对象.
# 当在函数体内修改这个可变类型参数的默认值时, 每次修改的都是同一个对象.

# 但是如果默认参数是一个不可变类型就不会发生这种现象
# 这是因为不可变类型在每次修改后都会重新生成一个新的对象,
# 在讲解整数的时候我们就已经讲过这个了.
# 所以不可变类型作为参数的默认值不会有任何问题.
</code></pre>

<h2>解决</h2>

<pre class="highlight"><code class="language-python"># 不要将可变参数作为默认值
# 而是在函数内每次都创建一个新的列表
def append_if_event(x, lst=None):
    if lst is None:
        lst = []
    if x % 2 == 0:
        lst.append(x)
    return lst</code></pre>

<h1>定义参数可变的函数</h1>

<p>前面将的函数, 接收的参数全是固定的, Python 还支持定义参数不固定的函数, 参数不固定只函数可以接收任意个数的参数.</p>

<p>在前面讲解列表和字典的时候我们已经见过了, 可以使用一个 <code>*</code> 号来解压多个值到一个变量中, python 中的函数参数也可以使用类似的方式</p>

<pre class="highlight"><code class="language-python"># 在参数前面使用一个星号
# 所有的参数将全部保存到这个参数中
def test(*args):
    for i in args:
        print(i)

test('a', 'b', 'c')</code></pre>

<h2>带其它参数</h2>

<pre class="highlight"><code class="language-python"># 参数列表中还可以指定一个或多个必要参数
def test(a, *args):
    print('a is {}'.format(a))
    for i in args:
        print(i)

# a 将传递给 a 参数
# b和c将传递给 args 参数
test('a', 'b', 'c')
# 注意 a 和 *args 的顺序</code></pre>

<h2>字典参数</h2>

<p>前面讲过了, 调用一个函数时, 我们还可以指定参数的名字. Python 同样可以接受任意个指定了名字的参数</p>

<pre class="highlight"><code class="language-python"># 通过使用两个星号来存储命名的参数.
def test(a, *args, **kvargs):
    print('a is {}'.format(a))
    for i in args:
        print(i)
    for key, val in kvargs.items():
        print("{} -&gt; {}".format(key, val))

test('a', 'b', 'c', val1='val1', val2='val2')</code></pre>

<h2>将参数保存到元组和字典中</h2>

<pre class="highlight"><code class="language-python"># 我们还可以直接传递一个元组和字典作为参数给函数
args = ('b', 'c')
kvargs = {'val1': 'val1', 'val2': 'val2'}
# 传递的时候同样需要使用*和**解压元组的字典
test('a', *args, **kvargs)</code></pre>

<hr>

<pre class="highlight"><code class="language-python">def product(a, b=1, *args, **kargs):
print('a: {}'.format(a))
print('b: {}'.format(b))

for arg in args:
    print(arg)
for key,val in kargs.items():
    print('{}: {}'.format(key, val))

param1 = ('a', 'b', 'c')
param2 = {'m': 'm', 'n': 'n'}
product(1, 2, *param1, **param2)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="02_lambda" id="___02_lambda1" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="函数/02_lambda:1">
<h1>匿名函数</h1>

<p>Python 允许我们创建一个没有函数名的函数, 称之为 匿名函数, 匿名函数使用 <code>lambda</code> 关键字定义:</p>

<pre class="highlight"><code class="language-python">lambda param1, param2: expression</code></pre>

<p>匿名函数可以接受0至多个参数, 各个参数之间使用逗号(<code>,</code>)分隔</p>

<p>expression 中不能包含任何条件判断语句和循环语句, 并且不能包含 <code>return</code> 语句, 而函数的返回结果就是 <code>expression</code> 执行的结果.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>匿名函数</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

s = lambda x: "" if x == 1 else "s"

# 创建一个匿名函数, 并将这个匿名函数赋给变量 s
# 通过调用 s 可以像调用正常函数那样调用匿名函数
print(s(1))
print(s(0))

# 直接使用在其他函数内
count = 3
print("{0} file{1} processed".format(count, s(count)))</code></pre>

<h1>map()</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当前我们有一个由数字构成的列表
l = [1, 2, 3]
# 如果我们想将这个列表中的所有元素做平方操作
# 然后返回一个新的列表
# 通常做法是循环这个列表, 获取其中的每个元素一次做平方操作

new_l = []
for i in l:
    new_l.append(i ** 2)
print(new_l)

# 这样类似的操作平时遇到的几率很大,
# 对一个可迭代对象中的每个元素做一些特殊处理后返回一个新的对象
# python 为我们提供了内置函数 map() 就是专门用于类似操作的.
# map() 函数可以接收两个或多个参数,
# 第一个参数是一个函数, 剩余参数均为可迭代对象
# 它的作用就是将可迭代对象中的每个元素以参数的形式传递给第一个参数指定的函数
# 这个函数需要一个返回值, 返回做完特殊处理后的值
# 最后整个 map 函数返回一个新的列表对象, 包含了所有被应用到函数上后返回的新值
# 如:
def sqr(x):
    return x ** 2

new_l2 = map(sqr, l)
print(new_l2)

# 还可以同时传递多个序列,
# 当传递多个序列时, 每个序列中的元素会同时一起传递给函数作为参数
# 这时, 相应的第一个参数指向的函数也需要修改它可接收的参数个数.
def sqr(x, y, z):
    return (x+y+z) ** 2
l2 = [4, 5, 6]
l3 = [7, 8, 9]
new_l3 = map(sqr, l, l2, l3)
print(new_l3)

# 如果传递给map的函数比较简单, 我们就可以使用匿名函数来代替
new_l4 = map(lambda x: x ** 2, l)
print(new_l4)</code></pre>

<h1>filter()</h1>

<pre class="highlight"><code class="language-python"># filter 函数与 map 函数类似, 接收一个函数和一个序列作为参数
# 这个函数需要返回一个 bool 值
# filter 会将序列中的每个元素一次应用到函数中,
# 当函数返回 True 时, 会将这个序列中的这个元素返回到新的序列中,
# 如果函数返回 False, 则抛弃这个元素
l = (1, 2, 3, 4, 5, 6)
filter_val = filter(lambda x: True if x % 2 == 0 else False, l)
print(filter_val)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="02_lambda" id="___02_lambda2" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="函数/02_lambda:2">
<h1>内建函数 <code>map()</code> 和 <code>filter()</code>
</h1>

<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>map(func, seq1[, seq2...])</code></td>
<td>将序列中的每个元素依次作为参数传递给函数 <code>func</code>, 并将结果以列表的形式返回.</td>
</tr>
<tr>
<td><code>filter(func, seq)</code></td>
<td>调用一个 <code>bool</code> 函数 <code>func</code> 来迭代 <code>seq</code> 中的每个元素, 返回一个使 <code>func</code>返回值为 <code>true</code> 的元素序列</td>
</tr>
</tbody>
</table>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>匿名函数</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

s = lambda x: "" if x == 1 else "s"

# 创建一个匿名函数, 并将这个匿名函数赋给变量 s
# 通过调用 s 可以像调用正常函数那样调用匿名函数
print(s(1))
print(s(0))

# 直接使用在其他函数内
count = 3
print("{0} file{1} processed".format(count, s(count)))</code></pre>

<h1>map()</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当前我们有一个由数字构成的列表
l = [1, 2, 3]
# 如果我们想将这个列表中的所有元素做平方操作
# 然后返回一个新的列表
# 通常做法是循环这个列表, 获取其中的每个元素一次做平方操作

new_l = []
for i in l:
    new_l.append(i ** 2)
print(new_l)

# 这样类似的操作平时遇到的几率很大,
# 对一个可迭代对象中的每个元素做一些特殊处理后返回一个新的对象
# python 为我们提供了内置函数 map() 就是专门用于类似操作的.
# map() 函数可以接收两个或多个参数,
# 第一个参数是一个函数, 剩余参数均为可迭代对象
# 它的作用就是将可迭代对象中的每个元素以参数的形式传递给第一个参数指定的函数
# 这个函数需要一个返回值, 返回做完特殊处理后的值
# 最后整个 map 函数返回一个新的列表对象, 包含了所有被应用到函数上后返回的新值
# 如:
def sqr(x):
    return x ** 2

new_l2 = map(sqr, l)
print(new_l2)

# 还可以同时传递多个序列,
# 当传递多个序列时, 每个序列中的元素会同时一起传递给函数作为参数
# 这时, 相应的第一个参数指向的函数也需要修改它可接收的参数个数.
def sqr(x, y, z):
    return (x+y+z) ** 2
l2 = [4, 5, 6]
l3 = [7, 8, 9]
new_l3 = map(sqr, l, l2, l3)
print(new_l3)

# 如果传递给map的函数比较简单, 我们就可以使用匿名函数来代替
new_l4 = map(lambda x: x ** 2, l)
print(new_l4)</code></pre>

<h1>filter()</h1>

<pre class="highlight"><code class="language-python"># filter 函数与 map 函数类似, 接收一个函数和一个序列作为参数
# 这个函数需要返回一个 bool 值
# filter 会将序列中的每个元素一次应用到函数中,
# 当函数返回 True 时, 会将这个序列中的这个元素返回到新的序列中,
# 如果函数返回 False, 则抛弃这个元素
l = (1, 2, 3, 4, 5, 6)
filter_val = filter(lambda x: True if x % 2 == 0 else False, l)
print(filter_val)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="03_closures" id="___03_closures1" class="slide" data-transition="none">
<div class="content " ref="函数/03_closures:1">
<h1>函数对象</h1>

<p>在 Python 中, 一切皆对象, 包括函数, 因此我们可以将函数赋值给一个变量, 也可以将一个函数变量作为参数传递给其他函数</p>

<pre class="highlight"><code class="language-python">def foo():
    print('foo')

def bar(func):
    func()

my_var = foo

# 作为参数传递给其他函数
bar(my_var)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>函数对象</h1>

<p>在 Python 中, 一切皆对象, 当然包括函数</p>

<pre class="highlight"><code class="language-python">def foo():
    print('hello')

# 既然是对象, 就可以将它赋值给一个变量
bar = foo
type(bar)

# 打印出函数名字
print(bar.__name__)

# 通过调用这个变量来调用函数
bar()

# 也可以将它作为参数传递给另一个函数</code></pre>

<h1>闭包</h1>

<h2>步骤1:</h2>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

def outer_func():
    message = 'Hi'

    def inner_func():
        print(message)

    return inner_func()

outer_func()</code></pre>

<p>首先看一下这段代码, 我们定义了一个函数 outer_func(), 它不接受任何参数, 在这个函数内, 第一行语句定义了 <code>message</code> 变量, 值 <code>Hi</code>.<br>
下面我们又定义了一个函数 <code>inner_func</code>, 同样不接受任何参数. <code>inner_func</code> 所做的就是打印出 <code>message</code> 这个变量, 这一这个变量我们名没有在 <code>inner_func</code> 函数体内定义, 所以它使用的是外层的 <code>message</code> 变量.<br>
最后我们执行 <code>inner_func()</code> 函数, 并把它的结果作为返回值返回给我们. 所以当我们执行 <code>outer_func</code> 函数时, 实际上执行了 <code>inner_func</code> 函数, 所以我们可以看到输出结果为 <code>Hi</code>.</p>

<h2>步骤 2</h2>

<p>现在修改一下代码, 在 <code>outer_func</code> 函数的最后, 我们直接执行了 <code>inner_func</code> 函数, 并返回这个函数的执行结果.</p>

<pre class="highlight"><code class="language-python">def outer_func():
    message = 'Hi'

    def inner_func():
        print(message)

    # 替换执行 inner_func 函数
    # 我们可以直接将这个函数作为 outer_func 返回值直接返回
    return inner_func

# outer_func() 执行后没有任何输出, 说明 inner_func 没有被执行

# 但是既然 outer_func() 函数将 inner_func 函数作为返回值给返回回来了
# 我们当然可以使用另一个变量接收它的返回值
my_func = outer_func() # 没有任何输出

# 查看 my_func 类型, 确实是一个函数
print(type(my_func))
# 打印出函数的名字
print(my_func.__name__)

# 既然是一个函数, 我们就可以调用这个函数
my_func()
# 可以看到我们正确输出了 `Hi` 这条信息

# 虽然我们已经从 outer_func 函数返回了,
# 但是通过调用 inner_func 函数, 我们仍然可以访问到 outter_func 函数内的变量 message
# 这就是 闭包 函数的能力

# 我们也可以调用多次 my_func, 结果都是同样的.
my_func()
my_func()
my_func()</code></pre>

<h2>步骤3</h2>

<p>添加参数</p>

<pre class="highlight"><code class="language-python">def outer_func(msg):
    message = msg

    def inner_func():
        print(message)

    return inner_func

say_hi = outer_func('hi')
say_hello = outer_func('hello')

say_hi()
say_hello()
# 可以看到这两个函数都能记住各自的 message 变量的值</code></pre>

<h2>步骤4</h2>

<p>为 inner_func 添加参数</p>

<pre class="highlight"><code class="language-python">    def outer_func(msg):
    message = msg

    def inner_func(name):
        print("{}, {}".format(message, name))

    return inner_func

say_hi = outer_func('hi')
say_hello = outer_func('hello')

say_hi('zhang san')
say_hello('li si')</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="03_closures" id="___03_closures2" class="slide" data-transition="none">
<div class="content " ref="函数/03_closures:2">
<h1>闭包</h1>

<p>在 Python 中, 我们可以在一个函数体内定义另一个函数, 当这个外部函数将内部函数作为返回值返回时, 这就是闭包</p>

<pre class="highlight"><code class="language-python">def logger(func):
    def log_func(*args):
        print("Running {} with arguments {}".format(func.__name__, args))
        return func(*args)
    return log_func

def add(x, y):
    return x + y

def sub(x, y):
    return x - y

add_logger = logger(add)
sub_logger = logger(sub)

print(add_logger(3, 4))
print(sub_logger(5, 2))</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>函数对象</h1>

<p>在 Python 中, 一切皆对象, 当然包括函数</p>

<pre class="highlight"><code class="language-python">def foo():
    print('hello')

# 既然是对象, 就可以将它赋值给一个变量
bar = foo
type(bar)

# 打印出函数名字
print(bar.__name__)

# 通过调用这个变量来调用函数
bar()

# 也可以将它作为参数传递给另一个函数</code></pre>

<h1>闭包</h1>

<h2>步骤1:</h2>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

def outer_func():
    message = 'Hi'

    def inner_func():
        print(message)

    return inner_func()

outer_func()</code></pre>

<p>首先看一下这段代码, 我们定义了一个函数 outer_func(), 它不接受任何参数, 在这个函数内, 第一行语句定义了 <code>message</code> 变量, 值 <code>Hi</code>.<br>
下面我们又定义了一个函数 <code>inner_func</code>, 同样不接受任何参数. <code>inner_func</code> 所做的就是打印出 <code>message</code> 这个变量, 这一这个变量我们名没有在 <code>inner_func</code> 函数体内定义, 所以它使用的是外层的 <code>message</code> 变量.<br>
最后我们执行 <code>inner_func()</code> 函数, 并把它的结果作为返回值返回给我们. 所以当我们执行 <code>outer_func</code> 函数时, 实际上执行了 <code>inner_func</code> 函数, 所以我们可以看到输出结果为 <code>Hi</code>.</p>

<h2>步骤 2</h2>

<p>现在修改一下代码, 在 <code>outer_func</code> 函数的最后, 我们直接执行了 <code>inner_func</code> 函数, 并返回这个函数的执行结果.</p>

<pre class="highlight"><code class="language-python">def outer_func():
    message = 'Hi'

    def inner_func():
        print(message)

    # 替换执行 inner_func 函数
    # 我们可以直接将这个函数作为 outer_func 返回值直接返回
    return inner_func

# outer_func() 执行后没有任何输出, 说明 inner_func 没有被执行

# 但是既然 outer_func() 函数将 inner_func 函数作为返回值给返回回来了
# 我们当然可以使用另一个变量接收它的返回值
my_func = outer_func() # 没有任何输出

# 查看 my_func 类型, 确实是一个函数
print(type(my_func))
# 打印出函数的名字
print(my_func.__name__)

# 既然是一个函数, 我们就可以调用这个函数
my_func()
# 可以看到我们正确输出了 `Hi` 这条信息

# 虽然我们已经从 outer_func 函数返回了,
# 但是通过调用 inner_func 函数, 我们仍然可以访问到 outter_func 函数内的变量 message
# 这就是 闭包 函数的能力

# 我们也可以调用多次 my_func, 结果都是同样的.
my_func()
my_func()
my_func()</code></pre>

<h2>步骤3</h2>

<p>添加参数</p>

<pre class="highlight"><code class="language-python">def outer_func(msg):
    message = msg

    def inner_func():
        print(message)

    return inner_func

say_hi = outer_func('hi')
say_hello = outer_func('hello')

say_hi()
say_hello()
# 可以看到这两个函数都能记住各自的 message 变量的值</code></pre>

<h2>步骤4</h2>

<p>为 inner_func 添加参数</p>

<pre class="highlight"><code class="language-python">    def outer_func(msg):
    message = msg

    def inner_func(name):
        print("{}, {}".format(message, name))

    return inner_func

say_hi = outer_func('hi')
say_hello = outer_func('hello')

say_hi('zhang san')
say_hello('li si')</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="04_decorator" id="___04_decorator" class="slide" data-transition="none">
<div class="content " ref="函数/04_decorator">
<h1>装饰器</h1>

<p>装饰器是 Python 中的语法糖, 对某个函数定义一个装饰器函数, 在我们调用这个函数时, Python 会自动为我们调用这个装饰器函数, 并将函数名作为装饰器函数参数自动传递给装饰器函数. 并且装饰器函数必须返回一个函数.</p>

<p>在 Python 中通过使用 <code>@func_name</code> 为一个函数定义一个装饰器函数.</p>

<pre class="highlight"><code class="language-python">@decorator_func
def my_func():
    pass</code></pre>

<p>示例</p>

<pre class="highlight"><code class="language-python">def logger(func):
    def log_func(*args):
        print("Running {} with arguments {}".format(func.__name__, args))
        return func(*args)
    return log_func

@logger
def add(x, y):
    return x + y

@logger
def sub(x, y):
    return x - y

print(add(4, 5))</code></pre>

<h2>带参数的装饰器</h2>

<pre class="highlight"><code class="language-python">def logger(level):
    def wrap(func):
        def log_func(*args):
            print("{}: Running {} with arguments {}".format(level, func.__name__, args))
            return func(*args)
        return log_func
    return wrap

@logger('Info')
def add(x, y):
    return x + y

@logger('Warning')
def sub(x, y):
    return x - y

add(3, 4)
sub(5, 2)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>装饰器</h1>

<pre class="highlight"><code class="language-python">def logger(func):
    def log_func(*args):
        print("Running {} with arguments {}".format(func.__name__, args))
        return func(*args)
    return log_func

# 一个将闭包函数作为返回值的函数
# Python 会自动将 add 函数作为参数传递给 logger() 函数
@logger
def add(x, y):
    return x + y

@logger
def sub(x, y):
    return x - y

#  add_logger = logger(add)
#  add_logger(3, 4)
#  sub_logger = logger(sub)

#  print(add_logger(3, 4))
#  print(sub_logger(5, 2))

print(add(4, 5))</code></pre>

<h1>带参数装饰器</h1>

<pre class="highlight"><code class="language-python">def logger(level):
    def wrap(func):
        def log_func(*args):
            print("{}: Running {} with arguments {}".format(level, func.__name__, args))
            return func(*args)
        return log_func
    return wrap

@logger('Info')
def add(x, y):
    return x + y

@logger('Warning')
def sub(x, y):
    return x - y

#  add_logger = logger(add)
#  add_logger(3, 4)

# 等价于
#  unnamed_func = logger('info')
#  add_logger = unnamed_func(add)
#  add_logger(3, 4)

add(3, 4)
sub(5, 2)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="05_variable_scope" id="___05_variable_scope" class="slide" data-transition="turnUp">
<div class="content " ref="函数/05_variable_scope">
<h1>变量作用范围</h1>

<p>无论是那种编程语言, 每个变量都有自己的访问范围, 如果在超出这个范围内代码段中访问变量, 则会提示变量未定义错误.</p>

<p>在 Python 中当引用一个变量时, 会使用 <code>LEGB</code> 规则的按顺序查找一个变量, 其中各个字母代表的含义是: </p>

<ul>
<li>
<code>Local</code>: 定义在一个函数中的变量</li>
<li>
<code>Enclosing</code>: 外部嵌套函数中定义的变量, 以及传递给函数的参数</li>
<li>
<code>Global</code>: 全局变量</li>
<li>
<code>Built-in</code>: Python 内置函数</li>
</ul>

<h2>
<code>global</code> 关键字</h2>

<p>当我们在一个函数内想要明确访问一个全局变量时, 可以使用 <code>global</code> 声明该变量, 明确指定它是一个 全局变量</p>

<h2>内置函数 <code>locals()</code> 和 <code>globals()</code>
</h2>

<p>Python 提供了两个内置函数 <code>locals()</code> 和 <code>globals()</code>, 可以让我们分别获取当前的 局部变量 和 全局变量.</p>

<pre class="highlight"><code class="language-python">x = 'global x'

def test():
    y = 'local y'
    print(locals())
    print(globals()['x'])

test()</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>变量的可见度</h1>

<pre class="highlight"><code class="language-python">x = 'global x'
pwd = 'zzl'

def test():
    y = 'local y'

    # 2: 局部变量的定义覆盖全局变量
    #  x = 'local x'

    # 3: 指明要访问的是全局变量
    # 从这段代码可以看出, 当直接访问变量 x 时, 调用的其实是全局变量 x,
    # 但是当重新为 x 赋值后, 实际是定义了一个新的局部变量 x.
    # 当我们想要在函数内明确指定要修改一个全局变量时
    # 可以使用 global 关键字先明确声明这个变量是一个全局变量
    #  global x
    #  x = 'local x'

    # 3: 修改全局变量
    x = 'local x'
    print(x)
    print(y)

test()
print(x)

# 访问局部变量, 报错
#  print(y)</code></pre>

<h1>locals() 和 globals()</h1>

<pre class="highlight"><code class="language-python">x = 'global x'

def test():
    y = 'local y'
    print(locals())
    print(globals()['x'])

    # 2: 还可以直接向里面添加元素
    globals()['name'] = 'zzl'

test()
# print(name)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="00_define_class" id="_____00_define_class1" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/00_define_class:1">
<h1>类的定义与类实例</h1>

<h2>定义类</h2>

<p>关键字 <code>class</code> 用于定义一个类</p>

<p>格式为:</p>

<pre class="highlight"><code class="language-python">class ClassName(base_classes):
    '''class document'''
    suite</code></pre>

<p>创建类时可以指定一个或多个要继承的父类 <code>base_classes</code>. 而 <code>object</code> 类是所有类的总父类, 也就是说, Python 中的所有类都继承自 <code>object</code> 类</p>

<p>在创建一个类时, 我们还可以为该类创建说明文档, 通过三引号来创建类文档</p>

<p>示例:</p>

<pre class="highlight"><code class="language-python">class Employee(): pass</code></pre>

<p>与定义函数一样, 需要先定义好类之后, 才能在后面的代码中使用.</p>

<h2>实例化一个类</h2>

<p>在 Python 中, 可以直接通过类名来创建一个类实例, 而无需使用 <code>new</code> 关键字.</p>

<pre class="highlight"><code class="language-python">emp_1 = Employee()
emp_2 = Employee()</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>定义类</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当前我们有一个公司, 公司下面有很多的员工
# 这个时候我们可以创建一个员工的类,
# 因为员工都共有相同的属性, 比容名字, emai地址, 工资
# 当我们创建一个员工的类后,
# 就可以为每个员工创建自己的实例了.

# 创建类很简单, 使用 class 关键字即可
class Employee:
    pass
    # 我们可以简单的放一个 pass 语句
    # 告诉Python这个类什么都不做
    # 但是即使是这样, 我们也成功地创建出了一个类
    # 当我们创建好一个类之后
    # 就可以为这个类创建任意多个实例
    # 简单来说 class 就相当于一个蓝图
    # 而实例就是根据这个蓝图创建出来的一个一个的实体

# 通过 type() 查来 Employee
print(type(Employee))</code></pre>

<h1>定义实例</h1>

<pre class="highlight"><code class="language-python"># 当我们创建好一个类之后, 接着就可以创建这个类的类实例了
# 跟其他的编程语言有点不同的地方就是
# 在Python中创建一个实例不需要使用 `new` 关键字
emp_1 = Employee()
emp_2 = Employee()

# 打印出实例, 可以看到他们都属于 Employee 的实例
print(emp_1)
print(emp_2)</code></pre>

<h1>定义实例属性</h1>

<pre class="highlight"><code class="language-python"># 在类中, 属性可以分为两种类型,
#   实例属性
#   类属性
# 首先看一下实例属性
# 实例属性被每个实例所拥有, 各个实例之间的属性是相互分离的, 互不影响的.
# 为类实例添加属性非常简单
# 当创建完一个类实例后, 可以直接通过实例名为这个实例添加任何属性
# 而不用像大部分其它编程语言那样, 需要提前在类中定义好类实例的属性
emp_1.first = 'Test1' # 这样我们就给实例 emp_1 添加了一个新属性 first
emp_1.last = 'User1'
emp_1.email = 'Test1.User1@company.com'
emp_1.pay = 5000

# 为第二个员工添加实例属性
emp_2.first = 'Test2'
emp_2.last = 'User2'
emp_2.email = 'Test2.User2@company.com'
emp_2.pay = 6000
# 现在这两个实例都有了自己的实例属性
# 输出实例属性
print(emp_1.email)
print(emp_2.email)</code></pre>

<h1>构造函数</h1>

<pre class="highlight"><code class="language-python">class Employee:
    # 虽然这段代码运行正常, 但是如果我们需要创建很多个实例
    # 每个实例都应该有这些属性, f/l name, pay
    # 如果要像这样, 为每个实例手动添加这些属性, 将会非常低效
    # 应该有这样一种机制, 就是当我们创建一个新的实例时, 应该能自动为我们创建这些属性
    # 我们可以通过类的构造函数来解决这个问题.
    # 如果我们为一个类定义了构造函数
    # 每当为这个类创建一个新的实例时,
    # 构造函数就会被 Python 自动调用.
    # 我们可以将这些属性放到构造函数中, 让 Python 自动为我们新的实例添加这些属性
    # 现在修改我们的类,
    # 增加一个特殊的方法 __init__()
    # __init__ 就是类的构造方法
    # 定义方法与定义函数是一样的, 都使用 def 关键字
    # 构造函数至少需要接收一个参数: self
    # 当构造函数被调用的时, Python 会自动将实例对象作为第一个参数传递给构造函数
    # 我们用 self 代表被传递的这个实例自身.
    # 我们还可以给构造函数设置一些其它参数, 用来初始化属性
    # 比如增加其他3个参数: first/last name 和 pay
    def __init__(self, first, last, pay):
        # 在构造方法内, 将这些属性赋给当前实例
        self.first = first
        self.last = last
        self.pay = pay
        # 在这里我们为 self 定义了这些属性
        # 因为 self 代表了当前对这个实例的引用
        # 并且我们就是要为这个实例创建这些属性
        # 所以为 self 赋值

        # 通过first 和 last name 拼接邮箱地址
        self.email = '{}.{}@company.com'.format(first, last)

# 2
# 现在当我们创建 Employee 实例的时候
# Employee 类需要接受三个参数, 
# 就是我们在定义构造函数时指定的后3个参数first/last name 和 pay
emp_1 = Employee('Corey', 'Schafer', 5000)
emp_2 = Employee('Test', 'User', 6000)
# 注意, 我们并没有传递 self 参数, 因为 self 是由 Python 自动传递的
# 无需我们插手, 并且这个参数总是作为第一个参数
# 其实不仅仅是构造函数, 类中的所有函数都需要接受 self 作为第一个参数

# 定义完之后就可以直接访问实例属性了
print(emp_1.email)
print(emp_2.email)</code></pre>

<h1>方法</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 1
# 继续我们的例子
# 现在考虑下面的情况,
# 我们希望能够获取到员工的全名
# 第一个想到的方式就是:
# 分别获取到实例的first name 和 last name
# 然后拼接到一起打印出来
print('{} {}'.format(emp_1.first, emp_2.last))

# 但是如果每次都这样获取全名, 很麻烦, 并且也会增加代码量
# 我们可以通过在类中定义一个方法,
# 在方法体内实现全名的拼接
# 以后我们只需要调用这个方法, 就可以获取到全名了
class Employee:
    ...
    def fullname(self):
    # 2
    # 跟构造函数一样
    # Python 在调用类中的方法时, 同样会自动传递当前实例作为第一个参数给这个方法
    # 所以第一个参数仍然是 self
    # 在这个方法中, 当前实例是我们唯一需要的属性
    # 因此不再需要传递其他参数到这个方法
        # 注意这里的 self.first
        # 这是我们就可以直接调用这个方法来获取员工的全名了
        return '{} {}'.format(first, last)
        # 尝试执行这段代码时, 报错
        # 提示没有找到全局变量.
        # 这是对的, 因为first 和 last 存在于实例中,
        # 我们并没有在这个方法体内定义这两个变量
        # 我们需要的是获取实例中的这两个属性
        # 所以我们需要用代表当前实例的 self 变量来获取他们的值
        # 将代码修改代码为
        return '{} {}'.format(self.first, self.last)

emp_1 = Employee('Corey', 'Schafer', 5000)
emp_2 = Employee('Test', 'User', 6000)

print(emp_1.email)
print(emp_2.email)

#  print('{} {}'.format(emp_1.first, emp_2.last))
# 3
# 最后我们在通过类实例来访问 fullname() 方法
# 这是 emp_1 就是 Python 自动传递给 self 的那个实例
# 注意最后的括号, 因为我们调用的是方法
print(emp_1.fullname())
print(emp_2.fullname())</code></pre>

<h2>不传递 self 参数</h2>

<pre class="highlight"><code class="language-python"># 当我们定义方法时, 必须传递一个 self 作为第一个参数给这个方法
# 但是如果我们没有传递这个参数, 会有什么结果呢?
# 删掉 fullname() 方法中的 self,
print(emp_1.fullname())
# 提示错误, 
# 在我们fullname() 没有参数, 但是传递了一个参数
# 这个参数就是 Python 自动传递的 self 参数

# 我们还可以通过 Employee 类直接来调用 fullname 方法
# 但是当我们用类名直接调用实例方法时
# Python 不知道使用的是哪个实例
# 所以我们就需要手动传递一个类实例作为参数传递给他
print(Employee.fullname(emp_1))
# emp_1 实例将传递给 fullname() 方法的 self 参数

# 所以最终的结论就是
# 当我们用实例调用一个类中的方法时
# Python 会自动将这个实例作为方法的第一个参数自动传递给我们要调用的方法
# 而我们用类名调用方法时, Python并不知道我们要使用哪个实例
# 因此需要手动传递一个实例作为参数传递给方法</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="00_define_class" id="_____00_define_class2" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/00_define_class:2">
<h2>实例属性和方法</h2>

<p>实例属性属于每个单独实例的私有属性, 各个实例之间的属性是相互独立存在的, 互不影响.</p>

<p>Python 支持动态添加实例属性, 这意味着当我们创建好一个实例后, 可以直接为实例自由地创建任何属性, 而无需预先在类中定义好.<br>
Python 中通过句点 <code>.</code> 来访问实例中的属性:</p>

<pre class="highlight"><code class="language-python">emp_1.property = Value</code></pre>

<h2>构造函数</h2>

<p>如果一个类定义了构造函数, 当创建这个类的实例时, 构造函数会自动被 Python 调用, 我们通常在构造函数中用来初始化一些属性. 在 Python 中, 使用固定的命名来创建一个构造函数:</p>

<p>构造函数至少接收一个参数 <code>self</code>, 用来表示类实例自身</p>

<pre class="highlight"><code class="language-python">def __init__(self): pass</code></pre>

<h2>方法</h2>

<p>与创建普通函数一样, 使用关键字 <code>def</code> 为类定义一个方法</p>

<pre class="highlight"><code class="language-python">def method(self): pass</code></pre>

<p>与构造函数一样, 类中的方法也至少需要一个 <code>self</code> 参数, 作为对实例自身的引用.</p>

<p class="callout info"><code>self</code> 并不是 Python 中的关键字, 使用 <code>self</code> 只是所有 Python 开发者的默认协议, 我们可以使用任何自定义变量来代替.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>定义类</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当前我们有一个公司, 公司下面有很多的员工
# 这个时候我们可以创建一个员工的类,
# 因为员工都共有相同的属性, 比容名字, emai地址, 工资
# 当我们创建一个员工的类后,
# 就可以为每个员工创建自己的实例了.

# 创建类很简单, 使用 class 关键字即可
class Employee:
    pass
    # 我们可以简单的放一个 pass 语句
    # 告诉Python这个类什么都不做
    # 但是即使是这样, 我们也成功地创建出了一个类
    # 当我们创建好一个类之后
    # 就可以为这个类创建任意多个实例
    # 简单来说 class 就相当于一个蓝图
    # 而实例就是根据这个蓝图创建出来的一个一个的实体

# 通过 type() 查来 Employee
print(type(Employee))</code></pre>

<h1>定义实例</h1>

<pre class="highlight"><code class="language-python"># 当我们创建好一个类之后, 接着就可以创建这个类的类实例了
# 跟其他的编程语言有点不同的地方就是
# 在Python中创建一个实例不需要使用 `new` 关键字
emp_1 = Employee()
emp_2 = Employee()

# 打印出实例, 可以看到他们都属于 Employee 的实例
print(emp_1)
print(emp_2)</code></pre>

<h1>定义实例属性</h1>

<pre class="highlight"><code class="language-python"># 在类中, 属性可以分为两种类型,
#   实例属性
#   类属性
# 首先看一下实例属性
# 实例属性被每个实例所拥有, 各个实例之间的属性是相互分离的, 互不影响的.
# 为类实例添加属性非常简单
# 当创建完一个类实例后, 可以直接通过实例名为这个实例添加任何属性
# 而不用像大部分其它编程语言那样, 需要提前在类中定义好类实例的属性
emp_1.first = 'Test1' # 这样我们就给实例 emp_1 添加了一个新属性 first
emp_1.last = 'User1'
emp_1.email = 'Test1.User1@company.com'
emp_1.pay = 5000

# 为第二个员工添加实例属性
emp_2.first = 'Test2'
emp_2.last = 'User2'
emp_2.email = 'Test2.User2@company.com'
emp_2.pay = 6000
# 现在这两个实例都有了自己的实例属性
# 输出实例属性
print(emp_1.email)
print(emp_2.email)</code></pre>

<h1>构造函数</h1>

<pre class="highlight"><code class="language-python">class Employee:
    # 虽然这段代码运行正常, 但是如果我们需要创建很多个实例
    # 每个实例都应该有这些属性, f/l name, pay
    # 如果要像这样, 为每个实例手动添加这些属性, 将会非常低效
    # 应该有这样一种机制, 就是当我们创建一个新的实例时, 应该能自动为我们创建这些属性
    # 我们可以通过类的构造函数来解决这个问题.
    # 如果我们为一个类定义了构造函数
    # 每当为这个类创建一个新的实例时,
    # 构造函数就会被 Python 自动调用.
    # 我们可以将这些属性放到构造函数中, 让 Python 自动为我们新的实例添加这些属性
    # 现在修改我们的类,
    # 增加一个特殊的方法 __init__()
    # __init__ 就是类的构造方法
    # 定义方法与定义函数是一样的, 都使用 def 关键字
    # 构造函数至少需要接收一个参数: self
    # 当构造函数被调用的时, Python 会自动将实例对象作为第一个参数传递给构造函数
    # 我们用 self 代表被传递的这个实例自身.
    # 我们还可以给构造函数设置一些其它参数, 用来初始化属性
    # 比如增加其他3个参数: first/last name 和 pay
    def __init__(self, first, last, pay):
        # 在构造方法内, 将这些属性赋给当前实例
        self.first = first
        self.last = last
        self.pay = pay
        # 在这里我们为 self 定义了这些属性
        # 因为 self 代表了当前对这个实例的引用
        # 并且我们就是要为这个实例创建这些属性
        # 所以为 self 赋值

        # 通过first 和 last name 拼接邮箱地址
        self.email = '{}.{}@company.com'.format(first, last)

# 2
# 现在当我们创建 Employee 实例的时候
# Employee 类需要接受三个参数, 
# 就是我们在定义构造函数时指定的后3个参数first/last name 和 pay
emp_1 = Employee('Corey', 'Schafer', 5000)
emp_2 = Employee('Test', 'User', 6000)
# 注意, 我们并没有传递 self 参数, 因为 self 是由 Python 自动传递的
# 无需我们插手, 并且这个参数总是作为第一个参数
# 其实不仅仅是构造函数, 类中的所有函数都需要接受 self 作为第一个参数

# 定义完之后就可以直接访问实例属性了
print(emp_1.email)
print(emp_2.email)</code></pre>

<h1>方法</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 1
# 继续我们的例子
# 现在考虑下面的情况,
# 我们希望能够获取到员工的全名
# 第一个想到的方式就是:
# 分别获取到实例的first name 和 last name
# 然后拼接到一起打印出来
print('{} {}'.format(emp_1.first, emp_2.last))

# 但是如果每次都这样获取全名, 很麻烦, 并且也会增加代码量
# 我们可以通过在类中定义一个方法,
# 在方法体内实现全名的拼接
# 以后我们只需要调用这个方法, 就可以获取到全名了
class Employee:
    ...
    def fullname(self):
    # 2
    # 跟构造函数一样
    # Python 在调用类中的方法时, 同样会自动传递当前实例作为第一个参数给这个方法
    # 所以第一个参数仍然是 self
    # 在这个方法中, 当前实例是我们唯一需要的属性
    # 因此不再需要传递其他参数到这个方法
        # 注意这里的 self.first
        # 这是我们就可以直接调用这个方法来获取员工的全名了
        return '{} {}'.format(first, last)
        # 尝试执行这段代码时, 报错
        # 提示没有找到全局变量.
        # 这是对的, 因为first 和 last 存在于实例中,
        # 我们并没有在这个方法体内定义这两个变量
        # 我们需要的是获取实例中的这两个属性
        # 所以我们需要用代表当前实例的 self 变量来获取他们的值
        # 将代码修改代码为
        return '{} {}'.format(self.first, self.last)

emp_1 = Employee('Corey', 'Schafer', 5000)
emp_2 = Employee('Test', 'User', 6000)

print(emp_1.email)
print(emp_2.email)

#  print('{} {}'.format(emp_1.first, emp_2.last))
# 3
# 最后我们在通过类实例来访问 fullname() 方法
# 这是 emp_1 就是 Python 自动传递给 self 的那个实例
# 注意最后的括号, 因为我们调用的是方法
print(emp_1.fullname())
print(emp_2.fullname())</code></pre>

<h2>不传递 self 参数</h2>

<pre class="highlight"><code class="language-python"># 当我们定义方法时, 必须传递一个 self 作为第一个参数给这个方法
# 但是如果我们没有传递这个参数, 会有什么结果呢?
# 删掉 fullname() 方法中的 self,
print(emp_1.fullname())
# 提示错误, 
# 在我们fullname() 没有参数, 但是传递了一个参数
# 这个参数就是 Python 自动传递的 self 参数

# 我们还可以通过 Employee 类直接来调用 fullname 方法
# 但是当我们用类名直接调用实例方法时
# Python 不知道使用的是哪个实例
# 所以我们就需要手动传递一个类实例作为参数传递给他
print(Employee.fullname(emp_1))
# emp_1 实例将传递给 fullname() 方法的 self 参数

# 所以最终的结论就是
# 当我们用实例调用一个类中的方法时
# Python 会自动将这个实例作为方法的第一个参数自动传递给我们要调用的方法
# 而我们用类名调用方法时, Python并不知道我们要使用哪个实例
# 因此需要手动传递一个实例作为参数传递给方法</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="01_class_variables" id="_____01_class_variables" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/01_class_variables">
<h1>类属性</h1>

<p>不同于实例属性, 类属性可以被所有实例和类方法所共享, 在类的方法外定义的变量都是类属性.</p>

<pre class="highlight"><code class="language-python">class ClassName():
    kls_attr = value;
    ...</code></pre>

<p>类属性既可以通过类名来访问, 还可以通过某个实例名访问</p>

<pre class="highlight"><code class="language-python">ClassName.kls_attr
instanceName.kls_attr</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>类变量</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

class Employee():
    num_of_emps = 0 # 2
    raise_amount = 1.04 # 1

    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.pay = pay
        self.email = '{}.{}@company.com'.format(first, last) # 3

        Employee.num_of_emps += 1

    def fullname(self):
        return '{} {}'.format(self.first, self.last)

    def apply_raise(self):
        #  self.pay = int(self.pay * 1.04) # 1
        #  self.pay = int(self.pay * raise_amount) # 2
        self.pay = int(self.pay * self.raise_amount)

emp_1 = Employee('Corey', 'Schafer', 5000)
emp_2 = Employee('Test', 'User', 6000)</code></pre>

<p>刚才我们提到了, 类中的属性有两种, 实例属性和类属性, 上面的例子中, 我们讲解了实例变量. 实例变量是属于单个实例的,他们之间相互分离, 互不影响, 但有些时候, 我们需要一些所有实例可以共享的变量, 这可以通过创建类变量来达到我们的目的.因为类变量可以被类的所有实例共享.</p>

<h1>硬编码编写 apply_raise(self) 方法</h1>

<pre class="highlight"><code class="language-python">class Employee():
    ...
# 继续使用这个例子
# 公司每年都会为员工涨工资, 工资的涨幅每年都不同
# 但是不管涨幅是多少, 我们暂时假设将所有员工的涨幅都是一样的
# 现在我们要获取员工涨薪后的工资
# 我们定义一个新方法
def apply_raise(self):
    self.pay = int(self.pay * 1.04) # 1

# 这时我们就可以将涨幅度设置成一个类属性来使用.
# 但是在使用类变量之前, 我们先用硬编码的形式来实现这个功能
# 增加一个新方法 apply_raise(self)
# 这个方法用来返回员工当前工资*加薪后的工资

# 现在我们来输出员工的工资
# 首先输出加薪前的工资
print(emp_1.pay)
emp_1.apply_raise()
print(emp_1.pay)
# 虽然现在运行起来一切正常
# 但是有许多地方需要改进
# 首先我们应该能通过某个变量来够获取到工资的涨幅, 类似一些这样的变量
emp_1.raise_amount
# 因为所有的员工涨幅都一样, 甚至我们还应该可以通过类名来获取到这个百分比
# 像是
Employee.raise_amount
# 但是当前类中并不存在 raise_amount 这个变量, 所以我们还无法获取到这个值
# 而且如果这个值在类中被很多地方使用时
# 当涨幅度发生变化后, 我们应该能够很容易的修改这个值
# 而不是像上面定义的那个函数那样, 需要修改所有出现 1.04 这个值的地方</code></pre>

<h1>定义类变量</h1>

<pre class="highlight"><code class="language-pyton">class Employee():
    # 为了达到以上这些要求, 我们可以使用类变量
    # 一个类变量可以被该类的所有实例所共享, 这意味着任何一个类实例都可以访问类变量
    # 定义类变量非常简单, 在类的最上面直接定义一个变量, 就是一个类变量
    raise_amount = 1.04
    # 一旦定义好一个类变量后, 我们就可以使用这个类变量了
    ...</code></pre>

<h1>更新 apply_raise() 方法</h1>

<pre class="highlight"><code class="language-python"># 现在修改我们的 apply_raise 函数, 使用类变量名来替换
# 我们先用 raise_amount 变量直接替换到我们的硬编码
#  self.pay = int(self.pay * raise_amount)
# 保存后执行
# 发现提示错误
# name 'raise_amount' is not defined
# 这是因为, 当我们想要访问一个类变量时
# 要么使用实例来访问, 要么直接通过类名来访问
# 修改代码
def apply_raise(self):
    self.pay = int(self.pay * Employee.raise_amount)

# 执行代码, 可以正常使用
# 在这个例子中, 我们使用 类名 来访问类属性
# 如果我们将类名修改成 self 会怎么样呢?
self.pay = int(self.pay * self.raise_amount)
# 再次执行代码, 返现仍然可以正常执行.
# 但是这明明是一个类变量
# 为什么实例可以直接访问类变量呢?

# 先让我们分别通过类名和实例名来打印出这个变量
# 分别通过类和实例访问 raise_amount 变量
print(Employee.raise_amount)
print(emp_1.raise_amount)
print(emp_2.raise_amount)
# 可以看到, 无论是通过类名还是实例名, 都可以获取到这个值
# 这是因为当我们尝试访问一个实例中的属性时,
# Python首先会在这个实例对象中查找这个属性
# 如果没有在当前实例对象中找到这个属性
# 则它将尝试到类中查找, 如果仍然没有找到, 将继续在类的父类中查找这个属性
# 直到查找到最上层, 如果仍然没有找到, 则程序报错退出

# 在这里, 当我们尝试用实例去访问 raise_amount 变量时,
# 实例中并不存在这个属性, 所以Python自动在Employee类中查找这个变量
# 最终发现了这个变量的定义, 并返回这个变量的值
# 我们可以通过打印出实例中的所有属性来看看到底是什么情况
# Python中, 每个实例都有一个特殊的属性 __dict__,
# 这是一个字典类型, 保存了实例中的所有属性信息
print(emp_1.__dict__)
# 我们发现在输出的结果中并没有发现 raise_amount 这个属性
# 使用同样的方法来获取类中的属性
print(Employee.__dict__)
# 可以看到类中存在这个属性</code></pre>

<h1>通过类名修改类属性</h1>

<pre class="highlight"><code class="language-python"># 现在我们将尝试用类来修改这个类变量
Employee.raise_amount = 1.05
# 再次输出这个值
print(Employee.raise_amount)
print(emp_1.raise_amount)
print(emp_2.raise_amount)
# 发现每个实例中的值也跟着发生了变化
# 说明他们都共享了同一个变量</code></pre>

<h1>通过实例修改类属性</h1>

<pre class="highlight"><code class="language-python"># 但是如果我们尝试使用实例去更新这个值会怎么样呢
emp_1.raise_amount = 1.05
# 再次输出这个值
print(Employee.raise_amount)
print(emp_1.raise_amount)
print(emp_2.raise_amount)
# 会发现只有 emp_1 中的值发生了变化
# 这是因为当我们使用 emp_1.raise_amount = 1.05 去更新这个值的时候
# 实际上是为 emp_1 实例创建了一个新的实例属性
# 再次打印出实例中的所有属性
print(emp_1.__dict__)
# 会发现实例中已经多了一个 raise_amount 属性

# 现在在让我们返回到 apply_raise() 方法
# 虽然使用类名和self都可以获取到 raise_amount 这个属性
# 但是我们更倾向于使用 self,
# 因为这样我们就可以为不同的员工设置不同的涨幅度了
# 而使用类名 Employee 将总是获取类中的这个属性值</code></pre>

<h1>何时使用类名获取类属性</h1>

<pre class="highlight"><code class="language-python">#################################################
# 但是并不是什么时候使用self都是一个好的选择
# 现在我们想要获取员工的数量
# 我们通过增加一个新的类变量 num_if_emps, 用来表示当前员工数
# 而这个员工数对于所有员工来说获取到的值应该都是一样的
# 当定义好这个类变量后
# 修改构造函数, 增加 Employee.num_of_emps += 1
class Employee():
    num_of_emps = 0
    def __init__(self):
        ...
        # 当每当实例化一个新实例对象时, 就会自动加 1
        Employee.num_of_emps += 1
# 这样每当我们实例化一个实例后, 类属性 num_of_emps 就会加1
# 这里我们更倾向于使用类名来访问这个属性, 因为我们不想让实例属性来覆盖这个变量
print(Employee.num_of_emps)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="02_clsmethod" id="_____02_clsmethod1" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/02_clsmethod:1">
<h1>常规方法</h1>

<p>一个常规方法就是定义在类中的一个普通方法, Python 会自动将实例本身作为第一个参数传递给常规方法, 我们用 <code>self</code> 来表示.<br>
可以通过类实例来调用方法.</p>

<pre class="highlight"><code class="language-python">def method(self):
    suite</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>classmethod</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

class Employee:

    num_of_emps = 0
    raise_amount = 1.04

    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.pay = pay
        self.email = '{}.{}@company.com'.format(first, last)

        Employee.num_of_emps += 1

    def fullname(self):
        return '{} {}'.format(self.first, self.last)

    def apply_raise(self):
        self.pay = int(self.pay * self.raise_amount)

    @classmethod
    def set_raise_amount(cls, amount):
        # 修改类属性
        cls.raise_amount = amount

    @classmethod
    def from_string(cls, emp_str):
        first, last, pay = emp_str.split('-')
        # 创建一个新的实例
        # 并返回这个实例
        return cls(first, last, pay)

emp_1 = Employee('Corey', 'Schafer', 5000)
emp_2 = Employee('Test', 'Employee', 6000)</code></pre>

<h1>添加类方法 set_raise_amount()</h1>

<pre class="highlight"><code class="language-python"># 继续修改我们的这个类
# 我们已经有了类属性 raise_amount,
# 现在我们希望可以有个方法能够修改这个值
# 创建一个新的类方法 set_raise_amount
# 这个方法应该能接收一个数值作为参数,
# 用来更新 raise_amount 的值

@classmethod
# 当我们调用类方法时, Python 会自动将类本身作为第一个参数传递给类方法
# 这里我们使用 cls 来接收这个参数
def set_raise_amount(cls, amount):
    # 在这里编写更新 raise_amount 值的代码
    # 我们可以用传递过来的 cls 参数来引用类属性
    cls.raise_amount = amount</code></pre>

<h1>类名调用类方法</h1>

<pre class="highlight"><code class="language-python"># 当定义好类方法后, 我们可以直接通过类名来调用类方法
Employee.set_raise_amount(1.05)
# 输出 raise_amount
print(Employee.raise_amount)
print(emp_1.raise_amount)
print(emp_2.raise_amount)
# 效果是一样的
Employee.raise_amount = 1.05</code></pre>

<h1>类实例调用类方法</h1>

<pre class="highlight"><code class="language-python"># 现在让我们尝试直接用实例去调用这个方法
emp_1.set_raise_amount(1.08)
print(Employee.raise_amount)
print(emp_1.raise_amount)
print(emp_2.raise_amount)
# 使用实例调用类方法没有任何问题
# 并且也正确修改了类变量
# 说明类方法既可以被类调用, 也可以直接被实例调用</code></pre>

<h1>继续完善</h1>

<pre class="highlight"><code class="language-python"># 现在我们考虑下面情况
# 我们又如下字符串
emp_str_1 = 'John-Doe-7000'
emp_str_2 = 'Steve-Smith-3000'
emp_str_3 = 'Jane-Doe-9000'
# first name, last name 和 pay 都用-分割
# 现在要通过这些字符串来创建Employee实例
# 我们可以拆分这些字符串
# 并保存这些变量
first, last, pay = emp_str_1.split('-')
# 根据这些变量来生成实例
new_emp_1 = Employee(first, last, pay)
print(new_emp_1.email)
print(new_emp_1.pay)
# 可以正确输出

# 但是每次都要手动拆分字符串, 然后在创建实例
# 这时候我们可以创建一个 类 方法,
# 用来专门处理这种格式的字符串
# 并创建一个新的类示例
# 这样我们每次只需要调用这个类方法, 并把这个字符串作为参数传递给它, 就能创建一个新的实例
# 创建类方法 from_string
new_emp_3 = Employee.from_string(emp_str_3)
print(new_emp_3.email)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="02_clsmethod" id="_____02_clsmethod2" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/02_clsmethod:2">
<h1>类方法</h1>

<p>定义类方法非常简单, 在常规方法声明的上面使用 <code>@classmethod</code> 即可定义了一个类方法.</p>

<pre class="highlight"><code class="language-python">class ClassName():
    @classmethod
    def cls_method(cls, params):
        suite</code></pre>

<p>类方法即可以被类调用, 也可以被某个实例所调用.<br>
当一个类方法被调用时, Python 会自动将类自身作为第一个参数传递给这个方法, 因此类方法必须至少接受一个参数, 我们通常用 <code>cls</code> 来捕获.<br>
除了又 Python 自动传递的 <code>cls</code> 参数外, 类方法还可以接收 0 或任意个自定义参数.</p>

<pre class="highlight"><code class="language-python">ClassName.cls_method()</code></pre>

<p class="callout info">与 <code>self</code> 类似, <code>cls</code> 并不是 Python 中的关键字, 使用他只是 Python 程序员的一种默认规则.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>classmethod</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

class Employee:

    num_of_emps = 0
    raise_amount = 1.04

    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.pay = pay
        self.email = '{}.{}@company.com'.format(first, last)

        Employee.num_of_emps += 1

    def fullname(self):
        return '{} {}'.format(self.first, self.last)

    def apply_raise(self):
        self.pay = int(self.pay * self.raise_amount)

    @classmethod
    def set_raise_amount(cls, amount):
        # 修改类属性
        cls.raise_amount = amount

    @classmethod
    def from_string(cls, emp_str):
        first, last, pay = emp_str.split('-')
        # 创建一个新的实例
        # 并返回这个实例
        return cls(first, last, pay)

emp_1 = Employee('Corey', 'Schafer', 5000)
emp_2 = Employee('Test', 'Employee', 6000)</code></pre>

<h1>添加类方法 set_raise_amount()</h1>

<pre class="highlight"><code class="language-python"># 继续修改我们的这个类
# 我们已经有了类属性 raise_amount,
# 现在我们希望可以有个方法能够修改这个值
# 创建一个新的类方法 set_raise_amount
# 这个方法应该能接收一个数值作为参数,
# 用来更新 raise_amount 的值

@classmethod
# 当我们调用类方法时, Python 会自动将类本身作为第一个参数传递给类方法
# 这里我们使用 cls 来接收这个参数
def set_raise_amount(cls, amount):
    # 在这里编写更新 raise_amount 值的代码
    # 我们可以用传递过来的 cls 参数来引用类属性
    cls.raise_amount = amount</code></pre>

<h1>类名调用类方法</h1>

<pre class="highlight"><code class="language-python"># 当定义好类方法后, 我们可以直接通过类名来调用类方法
Employee.set_raise_amount(1.05)
# 输出 raise_amount
print(Employee.raise_amount)
print(emp_1.raise_amount)
print(emp_2.raise_amount)
# 效果是一样的
Employee.raise_amount = 1.05</code></pre>

<h1>类实例调用类方法</h1>

<pre class="highlight"><code class="language-python"># 现在让我们尝试直接用实例去调用这个方法
emp_1.set_raise_amount(1.08)
print(Employee.raise_amount)
print(emp_1.raise_amount)
print(emp_2.raise_amount)
# 使用实例调用类方法没有任何问题
# 并且也正确修改了类变量
# 说明类方法既可以被类调用, 也可以直接被实例调用</code></pre>

<h1>继续完善</h1>

<pre class="highlight"><code class="language-python"># 现在我们考虑下面情况
# 我们又如下字符串
emp_str_1 = 'John-Doe-7000'
emp_str_2 = 'Steve-Smith-3000'
emp_str_3 = 'Jane-Doe-9000'
# first name, last name 和 pay 都用-分割
# 现在要通过这些字符串来创建Employee实例
# 我们可以拆分这些字符串
# 并保存这些变量
first, last, pay = emp_str_1.split('-')
# 根据这些变量来生成实例
new_emp_1 = Employee(first, last, pay)
print(new_emp_1.email)
print(new_emp_1.pay)
# 可以正确输出

# 但是每次都要手动拆分字符串, 然后在创建实例
# 这时候我们可以创建一个 类 方法,
# 用来专门处理这种格式的字符串
# 并创建一个新的类示例
# 这样我们每次只需要调用这个类方法, 并把这个字符串作为参数传递给它, 就能创建一个新的实例
# 创建类方法 from_string
new_emp_3 = Employee.from_string(emp_str_3)
print(new_emp_3.email)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="03_staticmethod" id="_____03_staticmethod" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/03_staticmethod">
<h1>静态方法</h1>

<p>与定义类方法格式相同, 使用 <code>@staticmethod</code> 来定义一个静态方法</p>

<pre class="highlight"><code class="language-python">class ClassName():
    @staticmethod
    def static_method(params):
        suite</code></pre>

<p>当调用类的静态方法时, Python 不会传递任何参数给它, 因此在定义静态方法时, 我们不需要定义任何特殊的参数</p>

<p>当我们定义的方法中不需要访问任何类属性或实例属性时, 就可以考虑使用静态方法来实现我们的需求了.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>静态方法</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

class Employee:

    num_of_emps = 0
    raise_amount = 1.04

    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.pay = pay
        self.email = '{}.{}@company.com'.format(first, last)

        Employee.num_of_emps += 1

    def fullname(self):
        return '{} {}'.format(self.first, self.last)

    def apply_raise(self):
        self.pay = int(self.pay * self.raise_amount)

    @classmethod
    def set_raise_amount(cls, amount):
        cls.raise_amount = amount

    @classmethod
    def from_string(cls, emp_str):
        first, last, pay = emp_str.split('-')
        return cls(first, last, pay)

    @staticmethod
    # 使用 @staticmethod 来创建一个静态方法
    # 在静态方法中, 我们不能访问任何实例属性或是类属性
    # Python 也不会自动传递任何参数给静态方法
    # 因此在定义静态方法的时候, 直接写上我们将要传递给方法的参数就可以了
    # 这里需要一个日期参数, 用来判断是否是工作日
    # 不需要self或是 cls 参数
    def is_workday(day):
        # 星期一是0, 所以星期6是5
        if day.weekday() == 5 or day.weekday() == 6:
            return False
        return True

emp_1 = Employee("Corey", 'Schafer', 5000)
emp_2 = Employee("Test", 'User', 6000)</code></pre>

<h1>定义静态方法</h1>

<pre class="highlight"><code class="language-python"># 现在我们想给 Employee 类增加一个新的方法
# 这个方法接收一个日期作为参数
# 用来判断这个日期是否是工作日, 只要不是周六周日, 就是工作日
# 从需求来看, 这个方法不需要访问任何实例中的属性或是类中的属性
# 所以我们可以创建一个静态方法来实现这个功能
class Employee():
    ...
    # Python中使用 @staticmethod 来创建一个静态方法
    @staticmethod
    # 在静态方法中, 我们不能访问任何实例属性或是类属性
    # Python 也不会自动传递任何参数给静态方法
    # 因此在定义静态方法的时候, 直接写上我们将要传递给方法的参数就可以了
    # 不需要任何额外的参数了
    # 这里需要一个日期参数, 用来判断是否是工作日
    def is_workday(day):
        # 星期一是0, 所以星期6是5
        if day.weekday() == 5 or day.weekday() == 6:
            return False
        return True
# 这样我们就可以使用这个方法来判断是否是工作日了</code></pre>

<h1>访问静态方法</h1>

<pre class="highlight"><code class="language-python"># 和调用类方法一样, 使用类名来调用静态方法
# is_workday() 需要接收一个日期对象作为参数
# 要使用日期对象, 我们需要先引入日期库
import datetime
# 生成一个新的日期对象
my_date = datetime.date(2017, 8, 23)
# 将日期对象作为参数传递给is_workday静态方法
print(Employee.is_workday(my_date))</code></pre>

<h1>总结</h1>

<p>现在先总结一下
常规方法中, Python 会自动传递一个实例作为第一个参数传递给它, 我们用 self 来代表<br>
类方法中, Python 会自动传递当前类作为第一个参数传递给它, 我们用 cls 来代表<br>
而对于静态方法, Python 不会自动传递任何参数给它</p>

<p>静态方法和类方法很相似, 都可以通过类名直接访问的<br>
我们应该怎么选择什么时候时候类/静态方法呢?<br>
一般当我们的方法中不需要访问任何类中的属性, 或是实例中的属性时<br>
就可以使用静态方法, 剩下情况下就使用类方法</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="04_inheritance" id="_____04_inheritance" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/04_inheritance">
<h1>继承</h1>

<p>当我们创建一个自定义时, 可以指定自定义类继承自一个或多个父类, 各个父类之间使用逗号 <code>,</code> 分隔.</p>

<p>在 Python 中, 类 <code>object</code> 是所有类的父类, 即所有类的最终父类就继承自 <code>object</code> 类.</p>

<pre class="highlight"><code class="language-python">class MyClass(ClassA, ClassB, ...)</code></pre>

<p>子类实例默认拥有父类中的所有类属性和方法, 我们可以使用 <code>issubclass(childCls, parentCls)</code> 方法来判断 <code>childCls</code> 类是否属于 <code>parentCls</code> 类的子类.</p>

<p>我们可以使用 <code>super()</code> 方法在子类中调用父类的方法.</p>

<h1>父类查找顺序</h1>

<p>当一个类继承自多个父类时, Python中采用的是广度优先搜索.</p>

<p><img src="./file//_images/oop/new-style.png" alt="父类查找顺序"></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>继承</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 而 `object` 类是所有类的总父类, 也就是说, Python 中的所有类都继承自 `object` 类
class Employee(object):

    num_of_emps = 0
    raise_amount = 1.04

    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.pay = pay
        self.email = '{}.{}@company.com'.format(first, last)

        Employee.num_of_emps += 1

    def fullname(self):
        return '{} {}'.format(self.first, self.last)

    def apply_raise(self):
        self.pay = int(self.pay * self.raise_amount)</code></pre>

<h1>定义 Developer 子类</h1>

<pre class="highlight"><code class="language-python"># 在前面的例子中, 我们定义列 Employee 类,
# 用来表示公司中的所有员工
# 现在我们需要根据员工的职位来区分开来
# 比如说所有的 developer.
# 我们可以为 developer 设计一个类,
# 一个专门针对所有 develper 的类
class Developer():
    pass

# 但是所有的 developer 又同时也属于公司的员工
# 因此 Employee类中的这些方法, 在 Developer 类中也应该同样实现.
# 我们可以把 Employee 中的所有代码拷贝一份到 Developer 类中
# 但是这样做不仅效率低, 当 Employee 中新增或修改了某些方法
# 也需要在 Developer 类中作出相应的修改
# 而且如果还有其他职位的类被创建, 所有这些类都需要被修改.
# 效率低下.
# 这时我们应该使用类继承来实现我们的功能
# 如果一个类(子列)继承了某个类(父类), 那么子类将拥有父类中的所有属性和方法

class Developer(Employee): pass

# 现在让我们创建 Developer() 类的实例了
dev_1 = Developer('Test1', 'User1', 5000)
dev_2 = Developer('Test2', 'User2', 6000)
# 输出 dev_1 的全名
print(dev_1.fullname())
# 查看 dev_2 的 email 地址
print(dev_2.email)
# 可以看到, 即使我们的 Develoer 类中什么都没写
# 还是可以像使用 Employee 那样使用这两个实例
# 通过help内置函数可以查看到 Developer 类中的所有属性
#  print(help(Developer))
# 可以看到 Developer 类中包含了所有 Employee 中的属性
# 这些属性都是通过继承而来的</code></pre>

<h2>增加 <strong>init</strong>() 方法</h2>

<pre class="highlight"><code class="language-python"># 现在让我们为 Developer 类添加一些新的属性
# 当我们创建 Developer 时, 需要为每个实例指定一个新的属性: 编程语言(prog_lang)
# 用来确定这个 Developer 使用的是那种编程语言.
# 我们需要重写父类中的 __init__(self) 方法, 来增加这个属性
# 在最后追加一个属性 prog_lang
    def __init__(self, first, last, pay, prog_lang):
        # 在父类的构造函数中, 我们已经实现了名字和工资功能
        # 因此我们不应该再重复编写这些代码
        # 只要告诉Python, 我们需要调用父类的构造函数来帮我们初始化这些名字和工资这些属性
        # 可以通过类名的方式调用父类的构造方法
        Employee.__init__(self, first, last, pay)
        # 因为我们是通过类名直接调用的实例函数, 所以需要手动传递类实例参数 self.
        # 但是这样做的缺点就是, 一个是每次都需要手动传递 self 参数
        # 另一个是如果父类类名变了, 我们就得在所有使用类名调用的地方修改

        # 一个更好的方式是使用 super() 方法
        # 这个方法是专门用来调用父类中的方法的.

        # python 3
        #  super().__init__(first, last, pay)
        # python 2
        super(Developer, self).__init__(first, last, pay)
        # 这样我们就可以利用父类中的构造函数来帮助我们初始化 name 和 pay 属性了
        # 现在我们需要增加一个新的属性 prog_lang 给 Developer 类使用
        self.prog_lang = prog_lang

# 修改我们的实例化类的代码, 增加新的参数.
dev_1 = Developer('Corey', 'Schafer', 5000, 'Python')
dev_2 = Developer('Test', 'User', 6000, "Java")
# 此时我们就可以获取到Develper的编程语言技能了
print(dev_1.prog_lang)
print(dev_2.prog_lang)
# 至此, 我们定义的子类 Developer 类就完成了.

#########################################
# 现在让我们自定义一些新的属性给 Developer 子类
# 在 Employee 类中, 所有员工工资涨幅都是 1.04
# 但是工资比较看重程序员, 对程序员的涨幅比较大
# 我们可以直接在 Developer 类中定义同样的类变量
# raise_amount = 1.10
# 再次输出员工工资
# 可以看到 dev_1 的工资已经发生了变化
#  print(dev_1.pay)
#  dev_1.apply_raise()
#  print(dev_1.pay)
#  print(dev_1.raise_amount)
# 打印出 Employee 类的属性
# 并没有改变, 说明修改子类中的属性, 并不会影响到父类
#  print(Employee.raise_amount)

# 当我们创建一个developer实例时
# 我们希望不仅能体现出员工的姓名和工资
# 同时还能指出developer使用的编程语言
# 我们需要让 Developer 类使用自己的构造方法

dev_1 = Developer('Corey', 'Schafer', 5000, 'Python')
dev_2 = Developer('Test', 'User', 6000, "Java")
print(dev_1.email)
print(dev_2.email)</code></pre>

<h1>定义 Manager 子类</h1>

<pre class="highlight"><code class="language-python"># 现在在让我们继续创建另一个子类 Manager 类, 用来创建 Manager
# 作为一个 Manager, 他下面应该记录了他手下的员工信息
# 我们应该可以方便的查看, 添加和删除 Manager 下的员工
# 创建 Manager 类, 同样继承自 Employee 类.
class Manager(Employee):
    # 注意, 不要使用一个可变类型对象作为默认值
    # 原因我们已经在 函数 那节讲过了.
    def __init__(self, first, last, pay, employees=None):
        super(Manager, self).__init__(first, last, pay)
        if employees is None:
            self.employees = []
        else:
            self.employees = employees

    # 需要一个方法, 用来向这个 Manager 中增加员工
    def add_emp(self, emp):
        if emp not in self.employees:
            self.employees.append(emp)

    # 用来删除员工的方法
    def remove_emp(self, emp):
        if emp in self.employees:
            self.employees.remove(emp)

    # 打印出 Manager 名下的所有员工信息
    def print_emps(self):
        for emp in self.employees:
            print('--&gt;{}'.format(emp.fullname()))

# 创建一个 Manager 实例
mgr_1 = Manager('Sue', 'Smith', 9000, [dev_1])
# 先尝试打印出 manager 的邮件地址
print(mgr_1.email)
# 因打印员工信息
mgr_1.print_emps()
# 增加一个新员工
mgr_1.add_emp(dev_2)
mgr_1.print_emps()
mgr_1.remove_emp(dev_1)
mgr_1.print_emps()</code></pre>

<h1>类方法</h1>

<pre class="highlight"><code class="language-python"># isinstance()
print(isinstance(mgr_1, Manager))
print(isinstance(mgr_1, Employee))
print(isinstance(mgr_1, Developer))
# issubclass
print(issubclass(Developer, Employee))
print(issubclass(Manager, Employee))
print(issubclass(Manager, Developer))

# 而 `object` 类是所有类的总父类, 也就是说, Python 中的所有类都继承自 `object` 类</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="05_magic_functions" id="_____05_magic_functions1" class="slide" data-transition="none">
<div class="content " ref="面向对象/05_magic_functions:1">
<h1>魔术方法</h1>

<p>Python 为我们预定义了一系列以双下滑线(<code>__</code>)开头和结尾的方法, 当我们对某些对象做特殊操作, 或是通过特定函数调用对象时, 对应的这些方法就会被 Python 自动调用, 我们称这些方法为 魔术方法.<br>
我们可以通过对自定义的类实现这些魔术方法, 来达到特殊的功能.</p>

<h2>常用的魔术方法</h2>

<h3>
<code>__repr__(self)</code>, <code>__str__(self)</code>:</h3>

<p>说明:<br>
当我们尝试打印某个对象, 或对某个对象调用 <code>repr()</code> 或 <code>str()</code> 函数时, Python 会尝试调用这两个方法.</p>

<p>返回值:<br>
返回一个用于对对象进行描述的字符串.</p>

<p class="callout info">当一个对象中只包含 <code>__repr__</code> 方法时, <code>print(obj)</code>, <code>str(obj)</code> 和 <code>repr(obj)</code> 行为全部一样. 当只包含 <code>__str__</code> 时, <code>print(obj)</code> 和 <code>str(obj)</code> 行为一致.</p>

<p class="callout info"><code>__str__</code> 主要用于返回对用户友好的字符串, 对一个字符使用 <code>str()</code> 将返回字符串本身.<br>
<code>__repr__</code> 则倾向于返回调试信息.</p>

<h3>
<code>__len__(self)</code>:</h3>

<p>说明:<br>
当对某个对象使用 <code>len()</code> 函数时, Python 会尝试调用该方法.</p>

<p>返回值:<br>
返回一个代表对象长度的数字</p>

<h3>
<code>__getitem__(self, index)</code>:</h3>

<p>说明:<br>
当尝试通过索引或者键名访问对象中的某个元素时, Python 会尝试调用该方法.<br>
对象中一旦定义了该方法, 就可以使用 <code>for in</code> 来循环获取对象中的元素了.</p>

<p>返回值:<br>
返回对象中的某个元素.</p>

<h3>
<code>__next__(self)</code>:</h3>

<p>说明:
如果一个对象中存在 <code>__next__</code> 方法, 就可以对函数使用 <code>next()</code> 方法来依次获取对象中的元素, 当获取完最后一个元素后, 如果继续对这个对象使用 <code>next()</code> 方法, 应当抛出 <code>StopIteration</code> 异常.<br>
含有 <code>__next__</code> 方法的对象也称作 <strong>迭代器</strong></p>

<p>返回值:<br>
返回对象中的下一个元素, 直到没有更多的元素可返回时, 抛出 <code>StopIteration</code> 异常.</p>

<p class="callout warning">在 Python2 中, 应当使用 <code>next()</code> 来代替 <code>__next__()</code></p>

<h3>
<code>__iter__(self)</code>:</h3>

<p>说明:<br>
<code>__iter__</code> 用于返回一个迭代器, 用于 <code>__iter__()</code> 方法的对象可以被 <code>for</code> 循环语句迭代.</p>

<p>返回值:
返回一个迭代器.</p>

<h3><code>__getattr__(self, name)</code></h3>

<p>说明:<br>
当尝试访问对象中一个不存在的属性时, Python 会自动调用该方法. 可在该方法中尝试捕获属性拼写等错误, 并给出相应的警告信息.</p>

<p>返回值:<br>
返回属性值, 或是抛出 <code>AttributeError</code> 异常.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>魔术方法</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# encoding: utf-8

class Employee:
        def __init__(self, first, last, pay):
            self.first = first
            self.last = last
            self.pay = pay
            self.email = '{}.{}@company.com'.format(first, last)

        def fullname(self):
            return '{} {}'.format(self.first, self.last)

emp_1 = Employee('Test1', 'User1', 5000)
emp_2 = Employee('Test2', 'User2', 6000)

# 我们知道, 在 Python 中, 一切皆对象
# 包括数字和字符串
# 但是当我们执行
print(1 + 2)
# 表示两个数字对象做相加操作
# Python 能够正确为我们计算出结果

# 甚至是让2个字符串相加
print('str1' + 'str2')
# 执行代码
# 可以看到两个字符串能够正确拼接到一起
# 不同的对象对 + 有不同的操作
# 数字类型对象是做数学运算
# 字符串类型是做字符串的拼接

# 在让我们列举一个例子
# 删除这两个 print 语句
# 现在我们尝试打印 Employee 实例
print(emp_1)
# 发现 Python 可以正确打印出结果
# 虽然输出的信息对我们的帮助不是很大
# 但是如果我们能够自定义这些信息, 那是最好不过的了.
# 那么 Python 是如何实现这些功能的呢?
# 答案就是魔术方法
# Python 中提供了大量的 魔术方法
# 这些方法全是是以 双下划线开头和结尾的.

# 到现在为止, 其实我们已经接触过Python中的魔术方法了
# 就是 __init__ 方法
# 当我们实例化一个类时
# python 会自动为我们调用 init 方法
# 这样我们可以将我们的初始化代码放到 init 方法中了.

# 跟 init 方法类似,
# Python 还提供了很多其他的魔术方法
# 当我们对一个对象做一些特殊操作, 或是调用特定方法时
# 特定的魔术方法就会被调用.</code></pre>

<h1>
<code>__repr__</code> 和 <code>__str__</code>
</h1>

<pre class="highlight"><code class="language-python"># 先让我们看一下两个最常用的魔术方法
# `repr` 和 `str`
# 当我们尝试打印一个对象的时
# Python 首先会查看对象中是否定义了这两个方法
# 如果定义了, 则调用这两个方法
# 如果没有定义这两个魔术方法
# Python 则采用默认规则来打印出对象信息
# 如:
print(emp_1)
# 或是直接调用 repr() 函数
print(repr(emp_1))
# 和 str 函数时
print(str(emp_1))
# 这两个魔术方法同样被调用</code></pre>

<h2><code>__repr__</code></h2>

<pre class="highlight"><code class="language-python"># 我们先定义一个 repr 方法
    def __repr__(self):
        # Python 规定
        # 这方方法需要返回一个字符串
        # 所以我们需要一个 return 语句
        # 然后返回一个字符串
        # 注释掉 repr(emp_1) 和 str(emp_1) 这两个方法
        # 运行脚本
        # 在运行之前, 大家看一下当前我们输出实例时的结果
        return "Employee('{}', '{}', '{}')".format(self.first, self.last, self.pay)</code></pre>

<h2><code>__str__</code></h2>

<pre class="highlight"><code class="language-python">def __str__(self):
    # 我们希望输出员工的全名和 emai 地址信息
    return '{}, {}'.format(self.fullname(), self.email)
    # 执行代码
    # 发现 print 语句的输出发生了变量
    # 输出结果是我们在 __str__ 中定义的字符串</code></pre>

<h2><code>__len__</code></h2>

<pre class="highlight"><code class="language-python"># 当我们调用 len() 来获取某个对象的长度时
# __len__() 方法就会被调用
# 给 Manager 添加该方法
# 用来表示Manager下有多少开发人员
def __len__(self):
    return len(self.employees)
# 这样我们就可以使用 len() 方法来获取manager下员工的数量了
print(len(mgr_1))

# 我们在 __len__ 方法内还是使用了 len() 函数来获取列表的长度
# 如果我们将这个长度作为一个实例属性保存在实例中
# 每次增加或删改的时候, 都相应的改变这个值
# 那我们在 __len__ 函数中就可以直接返回这个属性的值
# 而不用每次在重新计算这个长度了
# 这样无论这个对象下有多少长度,
# 每次获取这个长度的时候都是一样的
# 因为只需要返回这个值就可以了
# 因此返回这个对象的时间复杂度为 1: O(1)
# 实际上这也是列表内部获取元素长度的方式
# 因此我们无需在手动添加这个变量了</code></pre>

<h2><code>__getitem__</code></h2>

<pre class="highlight"><code class="language-python"># 还记得上面讲过的可迭代对象么,
# 其中一点就是
# 如果对象中有 `__getitem__` 方法
# 那么这个对象就叫做可迭代的对象
# 当我们用 for 语句循环对象时
# 就是尝试调用这个方法
# 当我们用索引或者键名访问对象中的某个元素时
# Python就会为我们自动调用这个方法
# 这个方法应该返回对象中的某个元素
# 我们为 Manager 添加这个方法
# 根据索引位置来返回程序员
def __getitem__(self, i):
    # 除了 self 之外
    # 还需要一个数值作为参数
    # 来返回指定索引位置的员工
    return self.employees[i]
# 这样我们就可以对 manger 实例使用索引了
# 获取员工的全名
print(mgr_1[0].fullname())
# 也可以使用 for 循环来获取所有员工信息
for i in mgr_1:
    print(i.fullname())</code></pre>

<h2><code>__next__</code></h2>

<pre class="highlight"><code class="language-python">def next(self):
    if self.index &lt; len(self):
        item = self.employees[self.index].fullname()
        # 在构造函数中增加一个变量
        # self.index = 0
        # 用来记录 next 中的索引
        self.index += 1
        return item
    # 当没有更多的元素时, 抛出 StopIteration 异常
    # 至于为什么要抛出 StopIteration 异常
    # 一会会在后面说到
    raise StopIteration()

print(next(mgr_1))
print(next(mgr_1))
# 再次使用 next() 方法, 则抛出 StopIteration 异常
#  print(next(mgr_1))</code></pre>

<h2><code>__iter__</code></h2>

<pre class="highlight"><code class="language-python"># 为 Manger 类增加
def __iter__(self):
    # print('iter')
    # 该方法必须返回一个迭代器
    # 即一个含有 __next__ 方法的对象
    # 因为我们的 Manager 类中已经包含了 next 方法
    # 所以此处就可以直接 self
    return self
# 含有 `__iter__`方法的对象可以通过 for 循环来一次获取其中的元素
for i in mgr_1:
    print(i)
# 在刚才讲解 next 方法时, 我们提到了
# 当对象中没有更多的元素可以被 next() 方法调用时
# 应当抛出 StopIteration 异常
# 这个异常主要是为 for 提供的
# 当使用 for 语句迭代一个元素时
# 如果遇到了 StopIteration 异常
# 说明没有更多的元素可以获取了
# 并且 for 语句会自动处理 StopIteration 异常
# 所以我们的程序不会因为遇到了异常而报错退出</code></pre>

<h2><code>__getattr__</code></h2>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="05_magic_functions" id="_____05_magic_functions2" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/05_magic_functions:2">
<h1>魔术方法列表</h1>

<h2>二进制运算</h2>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>object.<strong>add</strong>(self, other)</td>
</tr>
<tr>
<td>-</td>
<td>object.<strong>sub</strong>(self, other)</td>
</tr>
<tr>
<td>*</td>
<td>object.<strong>mul</strong>(self, other)</td>
</tr>
<tr>
<td>//</td>
<td>object.<strong>floordiv</strong>(self, other)</td>
</tr>
<tr>
<td>/</td>
<td>object.<strong>truediv</strong>(self, other)</td>
</tr>
<tr>
<td>%</td>
<td>object.<strong>mod</strong>(self, other)</td>
</tr>
<tr>
<td>**</td>
<td>object.<strong>pow</strong>(self, other[, modulo])</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>object.<strong>lshift</strong>(self, other)</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>object.<strong>rshift</strong>(self, other)</td>
</tr>
<tr>
<td>&amp;</td>
<td>object.<strong>and</strong>(self, other)</td>
</tr>
<tr>
<td>^</td>
<td>object.<strong>xor</strong>(self, other)</td>
</tr>
<tr>
<td>\</td>
<td></td>
</tr>
</tbody>
</table>

<h2>扩展赋值运算</h2>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>+=</td>
<td>object.<strong>iadd</strong>(self, other)</td>
</tr>
<tr>
<td>-=</td>
<td>object.<strong>isub</strong>(self, other)</td>
</tr>
<tr>
<td>*=</td>
<td>object.<strong>imul</strong>(self, other)</td>
</tr>
<tr>
<td>/=</td>
<td>object.<strong>idiv</strong>(self, other)</td>
</tr>
<tr>
<td>//=</td>
<td>object.<strong>ifloordiv</strong>(self, other)</td>
</tr>
<tr>
<td>%=</td>
<td>object.<strong>imod</strong>(self, other)</td>
</tr>
<tr>
<td>**=</td>
<td>object.<strong>ipow</strong>(self, other[, modulo])</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>object.<strong>ilshift</strong>(self, other)</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>object.<strong>irshift</strong>(self, other)</td>
</tr>
<tr>
<td>&amp;=</td>
<td>object.<strong>iand</strong>(self, other)</td>
</tr>
<tr>
<td><sup>=</sup></td>
<td>object.<strong>ixor</strong>(self, other)</td>
</tr>
<tr>
<td>\</td>
<td>=</td>
</tr>
</tbody>
</table>

<h2>一元运算符</h2>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>object.<strong>neg</strong>(self)</td>
</tr>
<tr>
<td>+</td>
<td>object.<strong>pos</strong>(self)</td>
</tr>
<tr>
<td>abs()</td>
<td>object.<strong>abs</strong>(self)</td>
</tr>
<tr>
<td>~</td>
<td>object.<strong>invert</strong>(self)</td>
</tr>
<tr>
<td>complex()</td>
<td>object.<strong>complex</strong>(self)</td>
</tr>
<tr>
<td>int()</td>
<td>object.<strong>int</strong>(self)</td>
</tr>
<tr>
<td>long()</td>
<td>object.<strong>long</strong>(self)</td>
</tr>
<tr>
<td>float()</td>
<td>object.<strong>float</strong>(self)</td>
</tr>
<tr>
<td>oct()</td>
<td>object.<strong>oct</strong>(self)</td>
</tr>
<tr>
<td>hex()</td>
<td>object.<strong>hex</strong>(self)</td>
</tr>
</tbody>
</table>

<h2>比较运算符</h2>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>object.<strong>lt</strong>(self, other)</td>
</tr>
<tr>
<td>&lt;=</td>
<td>object.<strong>le</strong>(self, other)</td>
</tr>
<tr>
<td>==</td>
<td>object.<strong>eq</strong>(self, other)</td>
</tr>
<tr>
<td>!=</td>
<td>object.<strong>ne</strong>(self, other)</td>
</tr>
<tr>
<td>&gt;=</td>
<td>object.<strong>ge</strong>(self, other)</td>
</tr>
<tr>
<td>&gt;</td>
<td>object.<strong>gt</strong>(self, other)</td>
</tr>
</tbody>
</table>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>魔术方法</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# encoding: utf-8

class Employee:
        def __init__(self, first, last, pay):
            self.first = first
            self.last = last
            self.pay = pay
            self.email = '{}.{}@company.com'.format(first, last)

        def fullname(self):
            return '{} {}'.format(self.first, self.last)

emp_1 = Employee('Test1', 'User1', 5000)
emp_2 = Employee('Test2', 'User2', 6000)

# 我们知道, 在 Python 中, 一切皆对象
# 包括数字和字符串
# 但是当我们执行
print(1 + 2)
# 表示两个数字对象做相加操作
# Python 能够正确为我们计算出结果

# 甚至是让2个字符串相加
print('str1' + 'str2')
# 执行代码
# 可以看到两个字符串能够正确拼接到一起
# 不同的对象对 + 有不同的操作
# 数字类型对象是做数学运算
# 字符串类型是做字符串的拼接

# 在让我们列举一个例子
# 删除这两个 print 语句
# 现在我们尝试打印 Employee 实例
print(emp_1)
# 发现 Python 可以正确打印出结果
# 虽然输出的信息对我们的帮助不是很大
# 但是如果我们能够自定义这些信息, 那是最好不过的了.
# 那么 Python 是如何实现这些功能的呢?
# 答案就是魔术方法
# Python 中提供了大量的 魔术方法
# 这些方法全是是以 双下划线开头和结尾的.

# 到现在为止, 其实我们已经接触过Python中的魔术方法了
# 就是 __init__ 方法
# 当我们实例化一个类时
# python 会自动为我们调用 init 方法
# 这样我们可以将我们的初始化代码放到 init 方法中了.

# 跟 init 方法类似,
# Python 还提供了很多其他的魔术方法
# 当我们对一个对象做一些特殊操作, 或是调用特定方法时
# 特定的魔术方法就会被调用.</code></pre>

<h1>
<code>__repr__</code> 和 <code>__str__</code>
</h1>

<pre class="highlight"><code class="language-python"># 先让我们看一下两个最常用的魔术方法
# `repr` 和 `str`
# 当我们尝试打印一个对象的时
# Python 首先会查看对象中是否定义了这两个方法
# 如果定义了, 则调用这两个方法
# 如果没有定义这两个魔术方法
# Python 则采用默认规则来打印出对象信息
# 如:
print(emp_1)
# 或是直接调用 repr() 函数
print(repr(emp_1))
# 和 str 函数时
print(str(emp_1))
# 这两个魔术方法同样被调用</code></pre>

<h2><code>__repr__</code></h2>

<pre class="highlight"><code class="language-python"># 我们先定义一个 repr 方法
    def __repr__(self):
        # Python 规定
        # 这方方法需要返回一个字符串
        # 所以我们需要一个 return 语句
        # 然后返回一个字符串
        # 注释掉 repr(emp_1) 和 str(emp_1) 这两个方法
        # 运行脚本
        # 在运行之前, 大家看一下当前我们输出实例时的结果
        return "Employee('{}', '{}', '{}')".format(self.first, self.last, self.pay)</code></pre>

<h2><code>__str__</code></h2>

<pre class="highlight"><code class="language-python">def __str__(self):
    # 我们希望输出员工的全名和 emai 地址信息
    return '{}, {}'.format(self.fullname(), self.email)
    # 执行代码
    # 发现 print 语句的输出发生了变量
    # 输出结果是我们在 __str__ 中定义的字符串</code></pre>

<h2><code>__len__</code></h2>

<pre class="highlight"><code class="language-python"># 当我们调用 len() 来获取某个对象的长度时
# __len__() 方法就会被调用
# 给 Manager 添加该方法
# 用来表示Manager下有多少开发人员
def __len__(self):
    return len(self.employees)
# 这样我们就可以使用 len() 方法来获取manager下员工的数量了
print(len(mgr_1))

# 我们在 __len__ 方法内还是使用了 len() 函数来获取列表的长度
# 如果我们将这个长度作为一个实例属性保存在实例中
# 每次增加或删改的时候, 都相应的改变这个值
# 那我们在 __len__ 函数中就可以直接返回这个属性的值
# 而不用每次在重新计算这个长度了
# 这样无论这个对象下有多少长度,
# 每次获取这个长度的时候都是一样的
# 因为只需要返回这个值就可以了
# 因此返回这个对象的时间复杂度为 1: O(1)
# 实际上这也是列表内部获取元素长度的方式
# 因此我们无需在手动添加这个变量了</code></pre>

<h2><code>__getitem__</code></h2>

<pre class="highlight"><code class="language-python"># 还记得上面讲过的可迭代对象么,
# 其中一点就是
# 如果对象中有 `__getitem__` 方法
# 那么这个对象就叫做可迭代的对象
# 当我们用 for 语句循环对象时
# 就是尝试调用这个方法
# 当我们用索引或者键名访问对象中的某个元素时
# Python就会为我们自动调用这个方法
# 这个方法应该返回对象中的某个元素
# 我们为 Manager 添加这个方法
# 根据索引位置来返回程序员
def __getitem__(self, i):
    # 除了 self 之外
    # 还需要一个数值作为参数
    # 来返回指定索引位置的员工
    return self.employees[i]
# 这样我们就可以对 manger 实例使用索引了
# 获取员工的全名
print(mgr_1[0].fullname())
# 也可以使用 for 循环来获取所有员工信息
for i in mgr_1:
    print(i.fullname())</code></pre>

<h2><code>__next__</code></h2>

<pre class="highlight"><code class="language-python">def next(self):
    if self.index &lt; len(self):
        item = self.employees[self.index].fullname()
        # 在构造函数中增加一个变量
        # self.index = 0
        # 用来记录 next 中的索引
        self.index += 1
        return item
    # 当没有更多的元素时, 抛出 StopIteration 异常
    # 至于为什么要抛出 StopIteration 异常
    # 一会会在后面说到
    raise StopIteration()

print(next(mgr_1))
print(next(mgr_1))
# 再次使用 next() 方法, 则抛出 StopIteration 异常
#  print(next(mgr_1))</code></pre>

<h2><code>__iter__</code></h2>

<pre class="highlight"><code class="language-python"># 为 Manger 类增加
def __iter__(self):
    # print('iter')
    # 该方法必须返回一个迭代器
    # 即一个含有 __next__ 方法的对象
    # 因为我们的 Manager 类中已经包含了 next 方法
    # 所以此处就可以直接 self
    return self
# 含有 `__iter__`方法的对象可以通过 for 循环来一次获取其中的元素
for i in mgr_1:
    print(i)
# 在刚才讲解 next 方法时, 我们提到了
# 当对象中没有更多的元素可以被 next() 方法调用时
# 应当抛出 StopIteration 异常
# 这个异常主要是为 for 提供的
# 当使用 for 语句迭代一个元素时
# 如果遇到了 StopIteration 异常
# 说明没有更多的元素可以获取了
# 并且 for 语句会自动处理 StopIteration 异常
# 所以我们的程序不会因为遇到了异常而报错退出</code></pre>

<h2><code>__getattr__</code></h2>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="06_property_decorator" id="_____06_property_decorator" class="slide" data-transition="none">
<div class="content " ref="面向对象/06_property_decorator">
<h1>属性装饰器</h1>

<p>属性装饰器可以让我们想访问对象中的属性那样调用某个方法, 而不用在调用方法的时候使用括号(<code>()</code>)来执行方法.</p>

<p>创建属性装饰器非常简单, 只需要在定义方法的上一行使用 <code>@property</code> 即可.</p>

<pre class="highlight"><code class="language-python">@property
def func(self):
    suite</code></pre>

<h1>setter 装饰器</h1>

<p>通过属性装饰器, Python 允许我们像访问属性那样调用对象中的方法, 而通过 setter decoraotr, Python 允许我们像为属性赋值那样使用赋值语句来调用某个方法, 并将赋值语句右边的值作为参数传递给这个方法.</p>

<pre class="highlight"><code class="language-python">@func_name.setter
def func_name(self, val):
    suite</code></pre>

<p>调用 <code>func_name</code> 方法时看起来就像: <code>obj.func_name = 'value'</code></p>

<h1>deleter 装饰器</h1>

<p>与 setter 装饰器对应的, 还有一个 deleter 装饰器, 如果为某个方法设置了 deleter 装饰器, 当使用 <code>del obj.func_name</code> 时, 名为 <code>func_name</code> 的方法就会被调用.</p>

<pre class="highlight"><code class="language-python">@func_name.deleter
def func_name(self):
    suite</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>属性装饰器</h1>

<p>在 Employee 类的构造方法中, 我们通过手动拼接的方式拼接出每个员工的邮箱地址, 但是问题是, 当我们修改了员工的first name 或是 last name 后, 员工的邮箱地址不会发生相应的变化, 除非是在我们修改了员工名字后在手动修改邮箱地址.</p>

<p>我们可以为 Employee 类创建一个方法, 专门用来获取用户邮箱的, 这个方法中每次都会获取员工的名字来拼接邮箱地址, 这样即使员工的姓名发生了变化, 我们也能正确获取到员工的邮箱了.</p>

<pre class="highlight"><code class="language-python">def email(self):
    return '{}.{}@email.com'.format(self.first, self.last)
# 移除掉构造函数中的 email 属性
# 这样我们就可以直接通过调用 email() 方法来获取员工的邮箱地址了
print(mgr_1.email())</code></pre>

<p>虽然现在我们可以正确获取到用户的邮箱地址了, 但是我们需要通过追加括号的方式调用 email 方法, 来获取用户的email信息. 怎么样才能向访问一个属性那样直接访问emai地址呢?<br>
答案就是通过 property decorator.<br>
定义一个 property decorator 非常简单, 在方法上加上 @property 即可, 这样我们就可以忽略 emai 后面的括号, 而像访问属性那样访问这个方法了.</p>

<p>用同样的方式修改 fullname() 方法, 就像类中已经有了 fullname 属性那样, 可以直接访问全名了.</p>

<h1>setter decorator</h1>

<p>现在我们又有新的需求了, 既然 fullname 是通过 first name 和 last name 拼接而成的, 那么我们希望可以通过像给 first 属性那样给一个员工赋值一个全名, 我们的类会根据给定的这个全名拆分成 first name 和 last name, 并分别赋给实例的 first 和 last 属性.</p>

<p>例如: 我们希望通过语句 <code>mgr_1.fullname = 'John Smith'</code> 来给 emp_1 员工赋值一个全名, 并且更新他的 fist name 和 last name.<br>
如果此时我们直接执行这段代码, Python 会提示我们一个错误: <code>can't set attribute.</code><br>
这是因为当前的 Employee 中已近存在了一个名为 <code>fullname</code> 的方法, 当我们再次尝试设置一个同名的属性时, Python 就会提示我们无法设置这个属性.<br>
为了实现这个功能, 我们必须使用 Python 中的 setter decorator. setter decorator 同样是作用在类中的方法上的. 当我们将某个方法设置成了 setter decorator 后, 就可以像为属性赋值那样通过赋值语句调用这个方法了. setter decorator 除了自动接收 <code>self</code> 参数以外, 还会额外接收一个参数, 这个参数就是我们调用赋值语句时等号右边的值.</p>

<p>创建一个 setter decorator 的格式为: <code>@方法名.setter</code></p>

<pre class="highlight"><code class="language-python"># 这个例子中, 我们希望像直接给 fullname 赋值那样来使用
# 所以创建一个 fullname 的 setter decorator
@fullname.setter
# 接着创建一个同名的 fullname 方法
# 这个方法会接收一个参数, 我们这里使用 name
# 而它的值就是来自于我们调用
# mgr_1.fullname = 'John Smith 时指定的值
def fullname(self, name):
    # 首先使用空格拆分 fullname
    # 并将拆分的结果分别赋值给 first 变量和 last 变量
    first, last = name.split(' ')
    # 当获取到 first name 和 last name后
    # 就可以更新实例中的这两个属性了
    self.first = first
    self.last = last

# 这是我们就可以像给类属性赋值那样调用 fullname 这个方法了
mgr_1.fullname = 'John Smith'
# 打印出 first name 和 last name
# 查看结果
print(mgr_1.first)
print(mgr_1.last)
# 这是我们再次尝试获取 email 地址, 也能够正确获取到了
print(mgr_1.email)</code></pre>

<h1>deleter decoratory</h1>

<p>继续使用这个例子, 现在我们希望能够像删除属性那样删除 Employee 中的 fullname, 与此同时, first name 和 last name 属性也应当同时置空.</p>

<pre class="highlight"><code class="language-python"># 设置一个 deleter decoratory
@ fullname.deleter
def fullname(self):
    print("Delete Name!")
    self.first = None
    self.last = None
# 删除 fullname 属性
del mgr_1.fullname</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="07_iterator" id="_____07_iterator1" class="slide center incremental subsection" data-transition="none">
<div class="content center incremental subsection" ref="面向对象/07_iterator:1">
<h1>迭代对象</h1>

<ul>
<li><p>可迭代对象</p></li>
<li><p>迭代器</p></li>
</ul>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="07_iterator" id="_____07_iterator2" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/07_iterator:2">
<h1>可迭代对象(iterable)</h1>

<p>可迭代对象是指该对象每次可以返回对象中的一个元素的对象. 任何一个包含了用 <code>__iter__()</code> 方法返回一个迭代器的对象, 或是任何序列类型(包含了接收一个整数作为参数的 <code>__getitem__()</code> 方法的对象)都是可迭代对象. 这些方法用来返回用来返回一个迭代器(<code>__iter__</code>) 或是对象中的一个元素(<code>__gititem__</code>).</p>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="07_iterator" id="_____07_iterator3" class="slide" data-transition="turnUp">
<div class="content " ref="面向对象/07_iterator:3">
<h1>迭代器(iterator)</h1>

<p>一个迭代器就是一个提供了 <code>__next__()</code> 方法的对象, <code>__next__()</code>方法用来依次返回该对象中的每个元素, 当没有更多元素可访问时, 则会抛出 <code>StopIteration</code> 异常.<br>
当使用 <code>for</code> 循环, <code>map()</code> 函数, 或是列表推导式时, 都会自动调用 <code>__next__</code> 方法返回迭代器中的一个元素.<br>
可以通过内建函数 <code>next()</code> 调用对象内的 <code>__next__()</code> 方法来依次访问迭代器中的元素.<br>
可以使用内置函数 <code>iter()</code> 将一个可迭代对象转换成迭代器.<br>
迭代器一定是迭代对象, 迭代对象不一定是迭代器.<br>
迭代器只能被迭代一次, 一旦元素全部被迭代完, 无法再次重头迭代.</p>

<p class="callout warning">在 Python2 中是 <code>next()</code></p>

<h1>迭代器通用操作和方法</h1>

<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s + t</code></td>
<td>返回一个由序列 <code>s</code> 和 序列<code>t</code> 拼接的新序列</td>
</tr>
<tr>
<td><code>s * n</code></td>
<td>返回一个重复 <code>n</code> 次序列 <code>s</code>的新序列</td>
</tr>
<tr>
<td><code>x in i</code></td>
<td>如果元素 <code>x</code> 存在于可迭代对象 <code>i</code> 中, 则返回 <code>True</code>, 否则返回 <code>False</code>
</td>
</tr>
<tr>
<td><code>all(i)</code></td>
<td>当可迭代对象中的所有元素都为 <code>True</code> 时, 返回 <code>True</code>
</td>
</tr>
<tr>
<td><code>any(i)</code></td>
<td>当可迭代对象中的元素中有一个为 <code>True</code> 时, 就返回 <code>True</code>
</td>
</tr>
<tr>
<td><code>len(x)</code></td>
<td>返回可迭代对象的长度</td>
</tr>
<tr>
<td><code>max(i, key)</code></td>
<td>返回可迭代对象 <code>i</code> 中的最大元素, 该方法还可以接收一个参数 <code>key</code>, 指向一个自定义函数, 此时则返回 <code>key(item)</code> 的最大值.</td>
</tr>
<tr>
<td><code>min(i, key)</code></td>
<td>返回可迭代对象 <code>i</code> 中的最小元素.</td>
</tr>
<tr>
<td><code>range(start, stop, step</code></td>
<td>返回一个由数字组成的迭代器.</td>
</tr>
<tr>
<td><code>reversed(i)</code></td>
<td>将可迭代对象 <code>i</code> 中的元素翻转后返回</td>
</tr>
<tr>
<td><code>enumerate(i, start)</code></td>
<td>与 <code>for...in</code> 一起使用, 每次循环返回一个包含元素索引和对应的元素值的元组, 默认从索引 0 开始, 如果指定了 <code>start</code> 参数, 则索引从 <code>start</code> 开始</td>
</tr>
<tr>
<td><code>zip(i1, ..., iN)</code></td>
<td>将每个参数中的元素按照顺序生成元组, 返回回来.</td>
</tr>
</tbody>
</table>

<p class="callout warning">Python2 中存在另一个内置函数 <code>xrang()</code>, 该函数效果与 <code>rang()</code>, 不同之处在于 <code>range()</code> 返回一个列表, 而 <code>xrang()</code> 返回一个可迭代对象, 如果生成的列表中包含了大量元素, 这些元素将全部被保存到内存中. 而可迭代对象只会将当前处理的元素保存在内存中, 因此使用 <code>xrang()</code> 会被 <code>range()</code> 更节省内存空间<br>
但是在 Python3 中的 <code>range()</code> 被重新升级成了与 <code>xrang()</code> 一样的行为, 并且移除了 <code>xrange()</code> 函数.</p>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="08_newstyle_class" id="_____08_newstyle_class" class="slide" data-transition="none">
<div class="content " ref="面向对象/08_newstyle_class">
<h1>Python2中的类</h1>

<p>在 Python2 中, 有两种形式的类存在:</p>

<ul>
<li>旧式类</li>
<li>新式类: Python2.2 版本中引入</li>
</ul>

<p>为了代码的向后兼容, 当我们创建一个类时, 默认使用旧式类. 如果需要定义一个新式类, 我们的类要么是直接继承自 <code>object</code> 类, 要么是类的总根类继承自 <code>object</code> 类.<br>
或是通过在 python 文件中使用使用 <code>__metaclass__ = type</code></p>

<p>示例:</p>

<pre class="highlight"><code class="language-python">class A(object): pass

class B(A): pass</code></pre>

<h2>区别</h2>

<ul>
<li>只有在新式类中才有 <code>super()</code> 方法</li>
<li>
<code>type()</code> 返回结果不一样, 并且新式类中增加了 <code>__class__</code> 属性, 其值与 <code>type()</code> 一样</li>
<li>新式类中重新规划了父类搜索顺序, 采用了 C3 算法, 即广度优先搜索，而旧式类是采用深度优先搜索, 并在新式类中增加了 <code>__mro__</code> 属性, 可用来查看父类搜索顺序.</li>
<li>新式类 <code>__slots__</code>
</li>
<li><p>新式类 <code>__getattribute__</code></p></li>
<li><p>只有新式类才有描述器</p></li>
</ul>

<p><img src="./file//_images/oop/old-style.png" alt="父类查找顺序"></p>

<p class="callout info">在 Python3 中, 没有新式类和旧式类之分了, 所有的类全部属于新式类.</p>

<p>而在 Python3 中, 默认定义的所有类都是新式类.</p>

<p>新式类中才有 <code>super()</code></p>

<pre class="highlight"><code class="language-python">class A(object):
    def __init__(self):
        print('A')

class B(object):
    def __init__(self):
        print('B')

class C(A, B):
    def __init__(self):
        print('C')
        super(C, self).__init__()

c = C()
# 输出: C A</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1><code>type()</code></h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

class A(object): pass
class B(object): pass

a = A()
b = B()

print(type(a), type(a))
# 旧式类中, type(a) 永远等于 type(b)
print(type(a) == type(b))</code></pre>

<h1>继承顺序</h1>

<h2>旧式类</h2>

<pre class="highlight"><code class="language-python">class C: i = 0
class C1(C): pass
class C2(C): i = 2
class C12(C1, C2): pass
class C21(C2, C1): pass

assert C12().i == 0
assert C21().i == 2</code></pre>

<h2>新式类</h2>

<pre class="highlight"><code class="language-python">class C(object): i = 0
class C1(C): pass
class C2(C): i = 2
class C12(C1, C2): pass
class C21(C2, C1): pass

print(C12().i)
print(C21().i)
print(C12.__mro__)
print(C21.__mro__)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="异常" data-title="01_exception" id="___01_exception1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="异常/01_exception:1">
<h1>Python 中的异常</h1>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>exception</h1>

<p>至少应该存在一个 <code>except</code> 语句, 但 <code>else</code> 和 <code>finally</code> 都是可选的, 当没有异常被捕获到的时候,</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们的程序中出现一些错误的时, Python 默认会打印出错误信息, 并终止程序的运行.
# 比如我们定义一个字典, 并访问字典中不存在的一个键时
d = {'a':1, 'b':2}
#  d[6]
# 程序直接报错: KeyError: 6 错误, 并终止程序的运行.

# 但有些时候我们希望能够自己处理这些错误, 当遇到这些错误后,
# 我们可能希望输出可读性更好的自定义错误信息,
# 或是在发现这些错误信息后, 做一些相应的操作后, 让程序继续执行,
# 比如说在这个例子中, 当访问一个不存在的键时,
# 我们希望打印出一个提示信息, 并将这个键加到字典中
# 这时我们就需要使用 Pthon 中的异常处理机制
# 将可能会发生错误的代码放到 try 字句中
# 在用 except 捕获可能会发生的异常错误.
# 当有异常发生时, Python 会去 except 语句中查看是否有相应的异常信息
# 如果找到了, 就会执行except语句,
# 如果没有在 except 语句中找到对应的异常信息
# 则异常向上抛出, 抛给调用它的代码, 直到程序的调用出.
try:
    d[6]
    #  d['a'] / 0
# 而除数为 0 会抛出 ZeroDivisionError 异常
except Exception:
    print('Key does not exist in the dictionary d. Adding it.')

# 在这个例子中, 我们使用了 KeyError 异常.
# 执行脚本, 与我们的期待一样

#####################################
# 我们继续看这个例子, 修改这段代码:
#  d['a'] / 0
# 我们知道, 无论什么时候, 任何数除以 0 都是错误的.
# 所以这段代码会抛出异常,
# 虽然它能够正确捕获到异常, 但是异常显示的结果明显是不对的.
# 在所有的编程语言中, 都有各种各样的异常来针对不同的错误, Python 也不例外
# 所以我们可以通过增加不同的异常来捕获不同的错误.
# 当访问一个不存在的 键 时, 会抛出 KeyError 异常.
# 因此增加 KeyError 异常的处理
#  except KeyError:
    #  print('Key does not exist in the dictionary d. Adding it.')
# 而除数为 0 会抛出 ZeroDivisionError 异常
#  except ZeroDivisionError:
    #  print("Error, divisor is 0.")
# 当有多个 except 字句时, Python 会按照定义except 的顺序, 从上至下依次查找,
# 直到找到有符合的异常, 如果执行到最后一个 except 语句都没有符合的异常
# 则向上抛出这个异常直到程序的最顶端后打印出错误信息并终止程序.

#####################################
# 我们不仅可以在 except 语句中直接捕获这个异常, 还可以通过捕获发生异常的父异常来捕获到.
# 在这个例子中, KeyError 异常继承自它的父异常 `LookupError` 异常(从我给出的列表中可以看到),
# 因此我们还可以通过捕获 `LookupError` 异常来达到我们的目的.
# except LookupError as e:
#  except Exception:
    #  print('Error')
# 这里有一点需要注意一下,
# 如果有多个 except 语句, 一定要把范围小的异常放在最上面.
# 如果把 Exception 异常类放到了第一个位置,
# 因为 Exception 异常类是所有异常类的总父类, 即所有异常都继承自 Exception 异常类.
# 那么它就会捕获到任何发生的异常, 而下面的 except 也就不会被执行了.
# 因此通常将 Except 放到最后, 来捕获为捕获到的异常

# 在这个例子中, KeyError 范围小于 LookupError, 因为 KeyError 是 LookupError 的子类,
# 而 LookupError 又是 Exception 的子类.
# 所以通常在最后使用 Exception 来捕获我们没有指定的所有异常.

#####################################
# 我们还可以在一个 except 语句中同时获取多个异常,
# 这些异常以元组的形式出现, 如:
#  except (KeyError, LookupError):
# 这样, 当出现 IndexError 异常时, 我们也能在这个 except 语句中捕获到
# 注意: IndexError 也是 LookupError 的子类

#####################################
# 在这个例子中, 我们虽然捕获到了我们需要的异常信息.
# 但是在提示信息中, 我们希望能过获取到更详细的错误信息
# 这个时候就可以通过在 except 语句的最后使用 as 语法, 如:
#  except (KeyError, LookupError) as e:
    #  print('Key [{}] does not exist in the dictionary d. Adding it.'.format(e))

#####################################
# else
# 我们还可以在最后一个 except 语句后面添加 else 子句
# else 中的子句会在没有发生异常的时候被执行
#  else:
    #  print("No exception")

#####################################
# finally
# finally 语句则无论是否有异常抛出, 都会被执行
#  finally:
    #  print("Finally clause")

try:
    #  d['a']
    d['c']
    #  5/0
except (KeyError, LookupError) as e:
    print(e)
except Exception:
    print('Catch an exception')
else:
    print("No exception")
finally:
    print("Finally clause")</code></pre>

<h1>自定义异常</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 自定义异常实际上就是一种自定义类型(自定义类), 我们将会在后面讲解类.
# 但是创建一个类实在很简单, 只需使用 class 关键字即可创建一个类
# 其中的 `baseException` 指定自定义异常类的父类, 父类必须是 `Exception` 类, 或是 `Exception` 的某个子类.

# 考虑这样一个例子
# 查找一个表中某个字段是否含有指定的元素

table = (
    (('C1B1A1S', 'C1B1A1S-name'),),
    (('E1C1B1A1S', 'E1C1B1A1S-name'),),
    (('C2B1A1S', 'C2B1A1S-name'),),
    (('type4', 'E2C2B1A1S-name'),),
)

found = False
target = 'C2B1A1S-name'
for row, record in enumerate(table):
    for column, field in enumerate(record):
        for index, item in enumerate(field):
            if item == target:
                found = True
                break
        if found:
            break
    if found:
        break
if found:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")

# 使用异常实现
class FoundException(Exception): pass
try:
    for row, record in enumerate(table):
        for column, field in enumerate(record):
            for index, item in enumerate(field):
                if item == target:
                    raise FoundException()
except FoundException:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="异常" data-title="01_exception" id="___01_exception2" class="slide" data-transition="turnUp">
<div class="content " ref="异常/01_exception:2">
<h1>捕获异常</h1>

<p>基本语法:</p>

<pre class="highlight"><code class="language-python">try:
    try_suite
except exception_group1 as variable1:
    except_suite1
...
except exception_groupN as variableN:
    except_suiteN
else:
    else_suite
finally:
    finally_suite</code></pre>

<p><code>else</code> 当没有异常发生时, <code>else</code> 子句将被调用</p>

<p><code>finally</code> 无论是否发生异常, <code>finall</code> 子句将总是被调用</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>exception</h1>

<p>至少应该存在一个 <code>except</code> 语句, 但 <code>else</code> 和 <code>finally</code> 都是可选的, 当没有异常被捕获到的时候,</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们的程序中出现一些错误的时, Python 默认会打印出错误信息, 并终止程序的运行.
# 比如我们定义一个字典, 并访问字典中不存在的一个键时
d = {'a':1, 'b':2}
#  d[6]
# 程序直接报错: KeyError: 6 错误, 并终止程序的运行.

# 但有些时候我们希望能够自己处理这些错误, 当遇到这些错误后,
# 我们可能希望输出可读性更好的自定义错误信息,
# 或是在发现这些错误信息后, 做一些相应的操作后, 让程序继续执行,
# 比如说在这个例子中, 当访问一个不存在的键时,
# 我们希望打印出一个提示信息, 并将这个键加到字典中
# 这时我们就需要使用 Pthon 中的异常处理机制
# 将可能会发生错误的代码放到 try 字句中
# 在用 except 捕获可能会发生的异常错误.
# 当有异常发生时, Python 会去 except 语句中查看是否有相应的异常信息
# 如果找到了, 就会执行except语句,
# 如果没有在 except 语句中找到对应的异常信息
# 则异常向上抛出, 抛给调用它的代码, 直到程序的调用出.
try:
    d[6]
    #  d['a'] / 0
# 而除数为 0 会抛出 ZeroDivisionError 异常
except Exception:
    print('Key does not exist in the dictionary d. Adding it.')

# 在这个例子中, 我们使用了 KeyError 异常.
# 执行脚本, 与我们的期待一样

#####################################
# 我们继续看这个例子, 修改这段代码:
#  d['a'] / 0
# 我们知道, 无论什么时候, 任何数除以 0 都是错误的.
# 所以这段代码会抛出异常,
# 虽然它能够正确捕获到异常, 但是异常显示的结果明显是不对的.
# 在所有的编程语言中, 都有各种各样的异常来针对不同的错误, Python 也不例外
# 所以我们可以通过增加不同的异常来捕获不同的错误.
# 当访问一个不存在的 键 时, 会抛出 KeyError 异常.
# 因此增加 KeyError 异常的处理
#  except KeyError:
    #  print('Key does not exist in the dictionary d. Adding it.')
# 而除数为 0 会抛出 ZeroDivisionError 异常
#  except ZeroDivisionError:
    #  print("Error, divisor is 0.")
# 当有多个 except 字句时, Python 会按照定义except 的顺序, 从上至下依次查找,
# 直到找到有符合的异常, 如果执行到最后一个 except 语句都没有符合的异常
# 则向上抛出这个异常直到程序的最顶端后打印出错误信息并终止程序.

#####################################
# 我们不仅可以在 except 语句中直接捕获这个异常, 还可以通过捕获发生异常的父异常来捕获到.
# 在这个例子中, KeyError 异常继承自它的父异常 `LookupError` 异常(从我给出的列表中可以看到),
# 因此我们还可以通过捕获 `LookupError` 异常来达到我们的目的.
# except LookupError as e:
#  except Exception:
    #  print('Error')
# 这里有一点需要注意一下,
# 如果有多个 except 语句, 一定要把范围小的异常放在最上面.
# 如果把 Exception 异常类放到了第一个位置,
# 因为 Exception 异常类是所有异常类的总父类, 即所有异常都继承自 Exception 异常类.
# 那么它就会捕获到任何发生的异常, 而下面的 except 也就不会被执行了.
# 因此通常将 Except 放到最后, 来捕获为捕获到的异常

# 在这个例子中, KeyError 范围小于 LookupError, 因为 KeyError 是 LookupError 的子类,
# 而 LookupError 又是 Exception 的子类.
# 所以通常在最后使用 Exception 来捕获我们没有指定的所有异常.

#####################################
# 我们还可以在一个 except 语句中同时获取多个异常,
# 这些异常以元组的形式出现, 如:
#  except (KeyError, LookupError):
# 这样, 当出现 IndexError 异常时, 我们也能在这个 except 语句中捕获到
# 注意: IndexError 也是 LookupError 的子类

#####################################
# 在这个例子中, 我们虽然捕获到了我们需要的异常信息.
# 但是在提示信息中, 我们希望能过获取到更详细的错误信息
# 这个时候就可以通过在 except 语句的最后使用 as 语法, 如:
#  except (KeyError, LookupError) as e:
    #  print('Key [{}] does not exist in the dictionary d. Adding it.'.format(e))

#####################################
# else
# 我们还可以在最后一个 except 语句后面添加 else 子句
# else 中的子句会在没有发生异常的时候被执行
#  else:
    #  print("No exception")

#####################################
# finally
# finally 语句则无论是否有异常抛出, 都会被执行
#  finally:
    #  print("Finally clause")

try:
    #  d['a']
    d['c']
    #  5/0
except (KeyError, LookupError) as e:
    print(e)
except Exception:
    print('Catch an exception')
else:
    print("No exception")
finally:
    print("Finally clause")</code></pre>

<h1>自定义异常</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 自定义异常实际上就是一种自定义类型(自定义类), 我们将会在后面讲解类.
# 但是创建一个类实在很简单, 只需使用 class 关键字即可创建一个类
# 其中的 `baseException` 指定自定义异常类的父类, 父类必须是 `Exception` 类, 或是 `Exception` 的某个子类.

# 考虑这样一个例子
# 查找一个表中某个字段是否含有指定的元素

table = (
    (('C1B1A1S', 'C1B1A1S-name'),),
    (('E1C1B1A1S', 'E1C1B1A1S-name'),),
    (('C2B1A1S', 'C2B1A1S-name'),),
    (('type4', 'E2C2B1A1S-name'),),
)

found = False
target = 'C2B1A1S-name'
for row, record in enumerate(table):
    for column, field in enumerate(record):
        for index, item in enumerate(field):
            if item == target:
                found = True
                break
        if found:
            break
    if found:
        break
if found:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")

# 使用异常实现
class FoundException(Exception): pass
try:
    for row, record in enumerate(table):
        for column, field in enumerate(record):
            for index, item in enumerate(field):
                if item == target:
                    raise FoundException()
except FoundException:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="异常" data-title="01_exception" id="___01_exception3" class="slide" data-transition="turnUp">
<div class="content " ref="异常/01_exception:3">
<h1>抛出异常</h1>

<p>在程序中我们可以使用 <code>raise</code> 手动抛出一个异常, 语法为:</p>

<pre class="highlight"><code class="language-python">raise exception(args)</code></pre>

<p>其中 <code>args</code> 是一个可选的参数, 一个用于描述异常信息的字符串.</p>

<p class="callout info">当我们在执行 python 脚本时, 如果指定了 <code>-o</code> 或 <code>-oo</code> 参数, 程序中的断言将不会被执行.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>exception</h1>

<p>至少应该存在一个 <code>except</code> 语句, 但 <code>else</code> 和 <code>finally</code> 都是可选的, 当没有异常被捕获到的时候,</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们的程序中出现一些错误的时, Python 默认会打印出错误信息, 并终止程序的运行.
# 比如我们定义一个字典, 并访问字典中不存在的一个键时
d = {'a':1, 'b':2}
#  d[6]
# 程序直接报错: KeyError: 6 错误, 并终止程序的运行.

# 但有些时候我们希望能够自己处理这些错误, 当遇到这些错误后,
# 我们可能希望输出可读性更好的自定义错误信息,
# 或是在发现这些错误信息后, 做一些相应的操作后, 让程序继续执行,
# 比如说在这个例子中, 当访问一个不存在的键时,
# 我们希望打印出一个提示信息, 并将这个键加到字典中
# 这时我们就需要使用 Pthon 中的异常处理机制
# 将可能会发生错误的代码放到 try 字句中
# 在用 except 捕获可能会发生的异常错误.
# 当有异常发生时, Python 会去 except 语句中查看是否有相应的异常信息
# 如果找到了, 就会执行except语句,
# 如果没有在 except 语句中找到对应的异常信息
# 则异常向上抛出, 抛给调用它的代码, 直到程序的调用出.
try:
    d[6]
    #  d['a'] / 0
# 而除数为 0 会抛出 ZeroDivisionError 异常
except Exception:
    print('Key does not exist in the dictionary d. Adding it.')

# 在这个例子中, 我们使用了 KeyError 异常.
# 执行脚本, 与我们的期待一样

#####################################
# 我们继续看这个例子, 修改这段代码:
#  d['a'] / 0
# 我们知道, 无论什么时候, 任何数除以 0 都是错误的.
# 所以这段代码会抛出异常,
# 虽然它能够正确捕获到异常, 但是异常显示的结果明显是不对的.
# 在所有的编程语言中, 都有各种各样的异常来针对不同的错误, Python 也不例外
# 所以我们可以通过增加不同的异常来捕获不同的错误.
# 当访问一个不存在的 键 时, 会抛出 KeyError 异常.
# 因此增加 KeyError 异常的处理
#  except KeyError:
    #  print('Key does not exist in the dictionary d. Adding it.')
# 而除数为 0 会抛出 ZeroDivisionError 异常
#  except ZeroDivisionError:
    #  print("Error, divisor is 0.")
# 当有多个 except 字句时, Python 会按照定义except 的顺序, 从上至下依次查找,
# 直到找到有符合的异常, 如果执行到最后一个 except 语句都没有符合的异常
# 则向上抛出这个异常直到程序的最顶端后打印出错误信息并终止程序.

#####################################
# 我们不仅可以在 except 语句中直接捕获这个异常, 还可以通过捕获发生异常的父异常来捕获到.
# 在这个例子中, KeyError 异常继承自它的父异常 `LookupError` 异常(从我给出的列表中可以看到),
# 因此我们还可以通过捕获 `LookupError` 异常来达到我们的目的.
# except LookupError as e:
#  except Exception:
    #  print('Error')
# 这里有一点需要注意一下,
# 如果有多个 except 语句, 一定要把范围小的异常放在最上面.
# 如果把 Exception 异常类放到了第一个位置,
# 因为 Exception 异常类是所有异常类的总父类, 即所有异常都继承自 Exception 异常类.
# 那么它就会捕获到任何发生的异常, 而下面的 except 也就不会被执行了.
# 因此通常将 Except 放到最后, 来捕获为捕获到的异常

# 在这个例子中, KeyError 范围小于 LookupError, 因为 KeyError 是 LookupError 的子类,
# 而 LookupError 又是 Exception 的子类.
# 所以通常在最后使用 Exception 来捕获我们没有指定的所有异常.

#####################################
# 我们还可以在一个 except 语句中同时获取多个异常,
# 这些异常以元组的形式出现, 如:
#  except (KeyError, LookupError):
# 这样, 当出现 IndexError 异常时, 我们也能在这个 except 语句中捕获到
# 注意: IndexError 也是 LookupError 的子类

#####################################
# 在这个例子中, 我们虽然捕获到了我们需要的异常信息.
# 但是在提示信息中, 我们希望能过获取到更详细的错误信息
# 这个时候就可以通过在 except 语句的最后使用 as 语法, 如:
#  except (KeyError, LookupError) as e:
    #  print('Key [{}] does not exist in the dictionary d. Adding it.'.format(e))

#####################################
# else
# 我们还可以在最后一个 except 语句后面添加 else 子句
# else 中的子句会在没有发生异常的时候被执行
#  else:
    #  print("No exception")

#####################################
# finally
# finally 语句则无论是否有异常抛出, 都会被执行
#  finally:
    #  print("Finally clause")

try:
    #  d['a']
    d['c']
    #  5/0
except (KeyError, LookupError) as e:
    print(e)
except Exception:
    print('Catch an exception')
else:
    print("No exception")
finally:
    print("Finally clause")</code></pre>

<h1>自定义异常</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 自定义异常实际上就是一种自定义类型(自定义类), 我们将会在后面讲解类.
# 但是创建一个类实在很简单, 只需使用 class 关键字即可创建一个类
# 其中的 `baseException` 指定自定义异常类的父类, 父类必须是 `Exception` 类, 或是 `Exception` 的某个子类.

# 考虑这样一个例子
# 查找一个表中某个字段是否含有指定的元素

table = (
    (('C1B1A1S', 'C1B1A1S-name'),),
    (('E1C1B1A1S', 'E1C1B1A1S-name'),),
    (('C2B1A1S', 'C2B1A1S-name'),),
    (('type4', 'E2C2B1A1S-name'),),
)

found = False
target = 'C2B1A1S-name'
for row, record in enumerate(table):
    for column, field in enumerate(record):
        for index, item in enumerate(field):
            if item == target:
                found = True
                break
        if found:
            break
    if found:
        break
if found:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")

# 使用异常实现
class FoundException(Exception): pass
try:
    for row, record in enumerate(table):
        for column, field in enumerate(record):
            for index, item in enumerate(field):
                if item == target:
                    raise FoundException()
except FoundException:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="异常" data-title="01_exception" id="___01_exception4" class="slide" data-transition="turnUp">
<div class="content " ref="异常/01_exception:4">
<h1>自定义异常</h1>

<p>语法:</p>

<pre class="highlight"><code class="language-python">class exceptionName (baseException): pass</code></pre>

<p>其中的 <code>baseException</code> 指定自定义异常类的父类, 父类必须是 <code>Exception</code> 类, 或是 <code>Exception</code> 的某个子类.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>exception</h1>

<p>至少应该存在一个 <code>except</code> 语句, 但 <code>else</code> 和 <code>finally</code> 都是可选的, 当没有异常被捕获到的时候,</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们的程序中出现一些错误的时, Python 默认会打印出错误信息, 并终止程序的运行.
# 比如我们定义一个字典, 并访问字典中不存在的一个键时
d = {'a':1, 'b':2}
#  d[6]
# 程序直接报错: KeyError: 6 错误, 并终止程序的运行.

# 但有些时候我们希望能够自己处理这些错误, 当遇到这些错误后,
# 我们可能希望输出可读性更好的自定义错误信息,
# 或是在发现这些错误信息后, 做一些相应的操作后, 让程序继续执行,
# 比如说在这个例子中, 当访问一个不存在的键时,
# 我们希望打印出一个提示信息, 并将这个键加到字典中
# 这时我们就需要使用 Pthon 中的异常处理机制
# 将可能会发生错误的代码放到 try 字句中
# 在用 except 捕获可能会发生的异常错误.
# 当有异常发生时, Python 会去 except 语句中查看是否有相应的异常信息
# 如果找到了, 就会执行except语句,
# 如果没有在 except 语句中找到对应的异常信息
# 则异常向上抛出, 抛给调用它的代码, 直到程序的调用出.
try:
    d[6]
    #  d['a'] / 0
# 而除数为 0 会抛出 ZeroDivisionError 异常
except Exception:
    print('Key does not exist in the dictionary d. Adding it.')

# 在这个例子中, 我们使用了 KeyError 异常.
# 执行脚本, 与我们的期待一样

#####################################
# 我们继续看这个例子, 修改这段代码:
#  d['a'] / 0
# 我们知道, 无论什么时候, 任何数除以 0 都是错误的.
# 所以这段代码会抛出异常,
# 虽然它能够正确捕获到异常, 但是异常显示的结果明显是不对的.
# 在所有的编程语言中, 都有各种各样的异常来针对不同的错误, Python 也不例外
# 所以我们可以通过增加不同的异常来捕获不同的错误.
# 当访问一个不存在的 键 时, 会抛出 KeyError 异常.
# 因此增加 KeyError 异常的处理
#  except KeyError:
    #  print('Key does not exist in the dictionary d. Adding it.')
# 而除数为 0 会抛出 ZeroDivisionError 异常
#  except ZeroDivisionError:
    #  print("Error, divisor is 0.")
# 当有多个 except 字句时, Python 会按照定义except 的顺序, 从上至下依次查找,
# 直到找到有符合的异常, 如果执行到最后一个 except 语句都没有符合的异常
# 则向上抛出这个异常直到程序的最顶端后打印出错误信息并终止程序.

#####################################
# 我们不仅可以在 except 语句中直接捕获这个异常, 还可以通过捕获发生异常的父异常来捕获到.
# 在这个例子中, KeyError 异常继承自它的父异常 `LookupError` 异常(从我给出的列表中可以看到),
# 因此我们还可以通过捕获 `LookupError` 异常来达到我们的目的.
# except LookupError as e:
#  except Exception:
    #  print('Error')
# 这里有一点需要注意一下,
# 如果有多个 except 语句, 一定要把范围小的异常放在最上面.
# 如果把 Exception 异常类放到了第一个位置,
# 因为 Exception 异常类是所有异常类的总父类, 即所有异常都继承自 Exception 异常类.
# 那么它就会捕获到任何发生的异常, 而下面的 except 也就不会被执行了.
# 因此通常将 Except 放到最后, 来捕获为捕获到的异常

# 在这个例子中, KeyError 范围小于 LookupError, 因为 KeyError 是 LookupError 的子类,
# 而 LookupError 又是 Exception 的子类.
# 所以通常在最后使用 Exception 来捕获我们没有指定的所有异常.

#####################################
# 我们还可以在一个 except 语句中同时获取多个异常,
# 这些异常以元组的形式出现, 如:
#  except (KeyError, LookupError):
# 这样, 当出现 IndexError 异常时, 我们也能在这个 except 语句中捕获到
# 注意: IndexError 也是 LookupError 的子类

#####################################
# 在这个例子中, 我们虽然捕获到了我们需要的异常信息.
# 但是在提示信息中, 我们希望能过获取到更详细的错误信息
# 这个时候就可以通过在 except 语句的最后使用 as 语法, 如:
#  except (KeyError, LookupError) as e:
    #  print('Key [{}] does not exist in the dictionary d. Adding it.'.format(e))

#####################################
# else
# 我们还可以在最后一个 except 语句后面添加 else 子句
# else 中的子句会在没有发生异常的时候被执行
#  else:
    #  print("No exception")

#####################################
# finally
# finally 语句则无论是否有异常抛出, 都会被执行
#  finally:
    #  print("Finally clause")

try:
    #  d['a']
    d['c']
    #  5/0
except (KeyError, LookupError) as e:
    print(e)
except Exception:
    print('Catch an exception')
else:
    print("No exception")
finally:
    print("Finally clause")</code></pre>

<h1>自定义异常</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 自定义异常实际上就是一种自定义类型(自定义类), 我们将会在后面讲解类.
# 但是创建一个类实在很简单, 只需使用 class 关键字即可创建一个类
# 其中的 `baseException` 指定自定义异常类的父类, 父类必须是 `Exception` 类, 或是 `Exception` 的某个子类.

# 考虑这样一个例子
# 查找一个表中某个字段是否含有指定的元素

table = (
    (('C1B1A1S', 'C1B1A1S-name'),),
    (('E1C1B1A1S', 'E1C1B1A1S-name'),),
    (('C2B1A1S', 'C2B1A1S-name'),),
    (('type4', 'E2C2B1A1S-name'),),
)

found = False
target = 'C2B1A1S-name'
for row, record in enumerate(table):
    for column, field in enumerate(record):
        for index, item in enumerate(field):
            if item == target:
                found = True
                break
        if found:
            break
    if found:
        break
if found:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")

# 使用异常实现
class FoundException(Exception): pass
try:
    for row, record in enumerate(table):
        for column, field in enumerate(record):
            for index, item in enumerate(field):
                if item == target:
                    raise FoundException()
except FoundException:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="异常" data-title="01_exception" id="___01_exception5" class="slide" data-transition="turnUp">
<div class="content " ref="异常/01_exception:5">
<h1>异常列表</h1>

<p>BaseException</p>

<ul>
<li>SystemExit</li>
<li>KeyboardInterrupt</li>
<li>GeneratorExit</li>
<li>Exception

<ul>
<li>StopIteration</li>
<li>StandardError</li>
<li>BufferError

<ul>
<li>ArithmeticError</li>
<li>FloatingPointError</li>
<li>OverflowError</li>
<li>ZeroDivisionError</li>
<li>AssertionError</li>
<li>AttributeError</li>
<li>EnvironmentError</li>
<li>IOError</li>
<li>OSError

<ul>
<li>WindowsError (Windows)</li>
<li>VMSError (VMS)</li>
</ul>
</li>
<li>EOFError</li>
<li>ImportError</li>
<li>LookupError

<ul>
<li>IndexError</li>
<li>KeyError</li>
</ul>
</li>
<li>MemoryError</li>
<li>NameError

<ul>
<li>UnboundLocalError</li>
</ul>
</li>
<li>ReferenceError</li>
<li>RuntimeError

<ul>
<li>NotImplementedError</li>
</ul>
</li>
<li>SyntaxError

<ul>
<li>IndentationError</li>
<li>TabError</li>
</ul>
</li>
<li>SystemError</li>
<li>TypeError</li>
<li>ValueError

<ul>
<li>UnicodeError</li>
<li>UnicodeDecodeError</li>
<li>UnicodeEncodeError</li>
<li>UnicodeTranslateError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Warning

<ul>
<li>DeprecationWarning</li>
<li>PendingDeprecationWarning</li>
<li>RuntimeWarning</li>
<li>SyntaxWarning</li>
<li>UserWarning</li>
<li>FutureWarning</li>
<li>ImportWarning</li>
<li>UnicodeWarning</li>
<li>BytesWarning</li>
</ul>
</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>exception</h1>

<p>至少应该存在一个 <code>except</code> 语句, 但 <code>else</code> 和 <code>finally</code> 都是可选的, 当没有异常被捕获到的时候,</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 当我们的程序中出现一些错误的时, Python 默认会打印出错误信息, 并终止程序的运行.
# 比如我们定义一个字典, 并访问字典中不存在的一个键时
d = {'a':1, 'b':2}
#  d[6]
# 程序直接报错: KeyError: 6 错误, 并终止程序的运行.

# 但有些时候我们希望能够自己处理这些错误, 当遇到这些错误后,
# 我们可能希望输出可读性更好的自定义错误信息,
# 或是在发现这些错误信息后, 做一些相应的操作后, 让程序继续执行,
# 比如说在这个例子中, 当访问一个不存在的键时,
# 我们希望打印出一个提示信息, 并将这个键加到字典中
# 这时我们就需要使用 Pthon 中的异常处理机制
# 将可能会发生错误的代码放到 try 字句中
# 在用 except 捕获可能会发生的异常错误.
# 当有异常发生时, Python 会去 except 语句中查看是否有相应的异常信息
# 如果找到了, 就会执行except语句,
# 如果没有在 except 语句中找到对应的异常信息
# 则异常向上抛出, 抛给调用它的代码, 直到程序的调用出.
try:
    d[6]
    #  d['a'] / 0
# 而除数为 0 会抛出 ZeroDivisionError 异常
except Exception:
    print('Key does not exist in the dictionary d. Adding it.')

# 在这个例子中, 我们使用了 KeyError 异常.
# 执行脚本, 与我们的期待一样

#####################################
# 我们继续看这个例子, 修改这段代码:
#  d['a'] / 0
# 我们知道, 无论什么时候, 任何数除以 0 都是错误的.
# 所以这段代码会抛出异常,
# 虽然它能够正确捕获到异常, 但是异常显示的结果明显是不对的.
# 在所有的编程语言中, 都有各种各样的异常来针对不同的错误, Python 也不例外
# 所以我们可以通过增加不同的异常来捕获不同的错误.
# 当访问一个不存在的 键 时, 会抛出 KeyError 异常.
# 因此增加 KeyError 异常的处理
#  except KeyError:
    #  print('Key does not exist in the dictionary d. Adding it.')
# 而除数为 0 会抛出 ZeroDivisionError 异常
#  except ZeroDivisionError:
    #  print("Error, divisor is 0.")
# 当有多个 except 字句时, Python 会按照定义except 的顺序, 从上至下依次查找,
# 直到找到有符合的异常, 如果执行到最后一个 except 语句都没有符合的异常
# 则向上抛出这个异常直到程序的最顶端后打印出错误信息并终止程序.

#####################################
# 我们不仅可以在 except 语句中直接捕获这个异常, 还可以通过捕获发生异常的父异常来捕获到.
# 在这个例子中, KeyError 异常继承自它的父异常 `LookupError` 异常(从我给出的列表中可以看到),
# 因此我们还可以通过捕获 `LookupError` 异常来达到我们的目的.
# except LookupError as e:
#  except Exception:
    #  print('Error')
# 这里有一点需要注意一下,
# 如果有多个 except 语句, 一定要把范围小的异常放在最上面.
# 如果把 Exception 异常类放到了第一个位置,
# 因为 Exception 异常类是所有异常类的总父类, 即所有异常都继承自 Exception 异常类.
# 那么它就会捕获到任何发生的异常, 而下面的 except 也就不会被执行了.
# 因此通常将 Except 放到最后, 来捕获为捕获到的异常

# 在这个例子中, KeyError 范围小于 LookupError, 因为 KeyError 是 LookupError 的子类,
# 而 LookupError 又是 Exception 的子类.
# 所以通常在最后使用 Exception 来捕获我们没有指定的所有异常.

#####################################
# 我们还可以在一个 except 语句中同时获取多个异常,
# 这些异常以元组的形式出现, 如:
#  except (KeyError, LookupError):
# 这样, 当出现 IndexError 异常时, 我们也能在这个 except 语句中捕获到
# 注意: IndexError 也是 LookupError 的子类

#####################################
# 在这个例子中, 我们虽然捕获到了我们需要的异常信息.
# 但是在提示信息中, 我们希望能过获取到更详细的错误信息
# 这个时候就可以通过在 except 语句的最后使用 as 语法, 如:
#  except (KeyError, LookupError) as e:
    #  print('Key [{}] does not exist in the dictionary d. Adding it.'.format(e))

#####################################
# else
# 我们还可以在最后一个 except 语句后面添加 else 子句
# else 中的子句会在没有发生异常的时候被执行
#  else:
    #  print("No exception")

#####################################
# finally
# finally 语句则无论是否有异常抛出, 都会被执行
#  finally:
    #  print("Finally clause")

try:
    #  d['a']
    d['c']
    #  5/0
except (KeyError, LookupError) as e:
    print(e)
except Exception:
    print('Catch an exception')
else:
    print("No exception")
finally:
    print("Finally clause")</code></pre>

<h1>自定义异常</h1>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# 自定义异常实际上就是一种自定义类型(自定义类), 我们将会在后面讲解类.
# 但是创建一个类实在很简单, 只需使用 class 关键字即可创建一个类
# 其中的 `baseException` 指定自定义异常类的父类, 父类必须是 `Exception` 类, 或是 `Exception` 的某个子类.

# 考虑这样一个例子
# 查找一个表中某个字段是否含有指定的元素

table = (
    (('C1B1A1S', 'C1B1A1S-name'),),
    (('E1C1B1A1S', 'E1C1B1A1S-name'),),
    (('C2B1A1S', 'C2B1A1S-name'),),
    (('type4', 'E2C2B1A1S-name'),),
)

found = False
target = 'C2B1A1S-name'
for row, record in enumerate(table):
    for column, field in enumerate(record):
        for index, item in enumerate(field):
            if item == target:
                found = True
                break
        if found:
            break
    if found:
        break
if found:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")

# 使用异常实现
class FoundException(Exception): pass
try:
    for row, record in enumerate(table):
        for column, field in enumerate(record):
            for index, item in enumerate(field):
                if item == target:
                    raise FoundException()
except FoundException:
    print("found at ({0}, {1}, {2})".format(row, column, index))
else:
    print("not found")</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="模块" data-title="00_modules" id="___00_modules" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="模块/00_modules">
<h1>模块 和 包</h1>

<ul>
<li>模块就是一个包含了实现某些功能的代码, 大部分 Python 模块都是使用 Python 编写的, 一个以 .py 结尾的普通的 Python 文件. Python 中提供了大量的内置模块, 可以通过 <a href="https://docs.python.org/3/library/">这里</a> 查看所有这些内置模块.</li>
<li>将多个模块文件放到一个包含有 <code>__init__.py</code> 文件的目录下, 就构建了一个 Python 包.</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>模块</h1>

<p>在开发的时候, 我们将某一功能通过函数或方法的方式封装起来, 这样每次我们要使用这个功能的时候, 就可以直接调用这个函数.</p>

<p>模块是同样的功能, 只是将多个函数或类放到一个 python 文件中, 用来实现某一组功能.</p>

<p>Python 中提供了大量的模块, 通过引用这些模块, 我们可以直接调用模块里的功能.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="模块" data-title="01_modules" id="___01_modules1" class="slide" data-transition="turnUp">
<div class="content " ref="模块/01_modules:1">
<h1>模块</h1>

<p>为了能够在我们的代码中使用其他库中的代码, 必须先要在我们的代码中引用这些库, 在 Python 中, 引用一个模块一共有两种主要语法:</p>

<h2><code>import</code></h2>

<ul>
<li><code>import importable</code></li>
<li><code>import importable1, importable2, ..., importableN</code></li>
<li><code>import importable as preferred_name</code></li>
</ul>

<p><code>importable</code> 可以是一个模块名, 包名, 或是模块下的某一个包.</p>

<pre class="highlight"><code class="language-python">import requests
import requests.api</code></pre>

<p class="callout info">import 后只能引用到模块级别. 而不能引用模块中的某个方法</p>

<h2><code>from...import...</code></h2>

<ul>
<li><code>from importable import object1, object2, ..., objectN</code></li>
<li><code>from importable import object as preferred_name</code></li>
<li><code>from importable import *</code></li>
</ul>

<p class="callout info">* 会导入模块中的所有变量和函数, 但是以下划线 <code>_</code> 开头的除外.</p>

<h2><code>__all__</code></h2>

<p>明确指定当使用 <code>*</code> 时可以导入的变量或函数, 如:</p>

<pre class="highlight"><code class="language-python">__all__ = ['find_index', 'test']</code></pre>

<h2>模块查找路径</h2>

<p>当我们引用一个 Python 模块时, python 会在默认的路径下查找我们要引用的库, 可以通过 <code>sys.path</code> 打印出这些路径信息.</p>

<pre class="highlight"><code class="language-python execute">import sys
print(sys.path)</code></pre>

<p>我们可以通过设定环境变量 <code>PYTHONPATH</code> 来曾加搜索路径, <code>PYTHONPATH</code> 应该指向一个目录.</p>

<pre class="highlight"><code class="language-bash">export PYTHONPATH=/home/zlock/custom/modules</code></pre>

<p>这样 <code>/home/zlock/custom/modules</code> 路径就会被放到 Python 的查找路径中, 它的位置紧跟在当前路径的下一个查找路径.</p>

<p class="callout info">我们可以通过 <code>python -c 'import requests'</code> 语句快速检测一个模块是否存在.</p>

<h2><code>__name__</code></h2>

<pre class="highlight"><code class="language-python">if __name__ == '__main__':
    suite</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>import 库</h1>

<p>让我们自定义一个简单的 Python 模块 <code>my_module.py</code>, 通过引用这个库来看一下 Python 中 import 的使用方法</p>

<pre class="highlight"><code class="language-python"># 首先在行首输出一段内容
print("imported my_module...")

# 定义一个变量
test = 'Test String'

# 定义一个简单的函数, 用来搜索列表中是否存在某个特定的值
def find_index(to_search, target):
    for i, value in enumerate(to_search):
        if value == target:
            return i

    # 如果没有找到, 则返回 -1
    return -1</code></pre>

<p>并且在当前目录下定义另一个 Python 文件 <code>intro.py</code></p>

<pre class="highlight"><code class="language-python"># 首先在这个文件中定义一个列表
courses = ['History', 'Math', 'Physics']</code></pre>

<p>现在, 如果我们想要使用 my_module 中的 find_index 方法. 必须使用 <code>import</code> 语句将这个模块导入到我们当前代码中.</p>

<pre class="highlight"><code class="language-python"># 使用 import 语句来引入这个模块
import my_module</code></pre>

<p>当我们使用 <code>import</code> 语句导入某个模块时, 实际上被导入的这个模块中的代码会被全部执行, 所以当我们执行代码后, 会看到 <code>my_module</code> 中的这条输出语句, 这也是为什么 <code>import</code> 语句可以导入其他模块中的变量和方法的原理. 实际上就是执行了一遍被导入模块中的方法.</p>

<p>当我们通过这种方式来导入一个模块之后, 并不能直接调用被导入模块中的方法或变量, 而是必须要通过<code>模块名.函数/变量</code> 的方式来使用.</p>

<pre class="highlight"><code class="language-python"># 输出 test 变量
print(my_module.test)

# 调用 find_index() 函数
index = my_module.find_index(courses, 'Math')
print(index)</code></pre>

<h2>通过 as 设定别名</h2>

<p>如果我们在代码中需要调用很多次 <code>find_index()</code>  方法, 每次都要使用 <code>my_module.find_index()</code> 的方式来访问这个函数, 或是当前代码中定义了 <code>my_module</code> 变量, 比如:</p>

<pre class="highlight"><code class="language-python">my_module = 5</code></pre>

<p>这时候在使用 <code>my_module.find_index()</code> 的方式访问这个变量时, 就会提示错误.</p>

<p>解决方法就是为这个模块指定别名, 在使用 <code>import</code> 语句导入一个模块时, 我们同时还可以使用 <code>as</code> 给这个模块指定一个别名, 如:</p>

<pre class="highlight"><code class="language-python">import my_module as mm
# 这时候, 我们就可以使用 mm 来代替 my_module 了

# 修改 my_module 为 mm
print(mm.test)
print(mm.find_index(courses, 'Math'))
# 现在一切就有正常了</code></pre>

<h1><code>from ... import ...</code></h1>

<p>除了上面这种方式外, Python 还支持我们只导入模块中的某一个或某些方法或变量, 格式为 <code>from...import...</code>, 如:</p>

<pre class="highlight"><code class="language-python"># 更改 import 语句
from my_module import find_index

# 通过这种方式导入的方法或变量
# 我们可以在代码中直接使用
# 而不需要在使用模块名或别名作为前缀了
# 修改 mm.find_index()
# 删掉 mm
print(test)
index = find_index(courses, 'Math')

# 执行代码
# 提示我们一个错误, 说 test 是未定义变量
# 这说明通过这种方式导入模块中的方法或是变量时
# 只有指定的方法或是变量才会被导入进来

# 把 test 变量追加到 import 语句中
# 多个变量和方法之间, 使用逗号分隔开
from my_module import find_index, test
# 再次执行, 代码可以被成功执行了</code></pre>

<p>其实我们还可以让代码变的更简单一些, 还是通过 as 设定别名的方式:</p>

<pre class="highlight"><code class="language-python"># 给 find_index 函数设置一个别名
from my_module import find_index as fi, test

# 替换掉 find_index
index = ff(courses, 'Math')</code></pre>

<h2>import *</h2>

<p>使用 <code>from...import...</code> 这种方式时, 如果我们想要从模块中的很多方法或是变量时, 必须得把所有这些需要导入进来的方法和函数名全都写到 import 语句中, 其实还有一种更简单的方式, 使用 <code>*</code> 来导入模块中的所有方法和变量, </p>

<pre class="highlight"><code class="language-python"># 使用 * 来调用所有
from my_module import *</code></pre>

<p>但是尽量不要使用这种方式, 如果被导入的库很大的话, 很容易造成混乱, 或者是造成命名冲突.</p>

<h2><strong>all</strong></h2>

<pre class="highlight"><code class="language-python"># 在 my_module.py 中使用
__all__ = ['find_index', 'test']</code></pre>

<h1>模块查找路径</h1>

<p>当我们导入一个模块时, Python 是怎么找到这些模块的呢? 或者说 Python 在哪些路径下查找这些模块呢?</p>

<p>如果我们引用的一个模块不是 Python 的内置模块, Python 会按照 <code>sys.path</code> 中的顺序依次查找库</p>

<pre class="highlight"><code class="language-python">import sys
print(sys.path)</code></pre>

<p>可以看到, Python 第一个查找路径是当前 python 脚本所在的路径, 这个跟在哪个目录下执行的这个脚本没有关系, 无论是在那个路径下执行的, 得到的都是一样的结果.</p>

<p>我们可以通过向这个路径附加一些路径信息来增加查找路径:</p>

<pre class="highlight"><code class="language-python">sys.path.append('/Users/gbyukg/Desktop')</code></pre>

<p>但是这样写对代码的可移植性造成影响. 另一个可行的方法是设置 <code>PYTHONPATH</code> 环境变量.</p>

<p>在 Python 中, 重复导入模块多次, 或是回环导入模块(比如模块A中引入了模块B, 而在模块B中又引用了模块A)不会引起任何问题, 因为 Python 在每次导入模块之前会首先查看模块是否已经被导入过, 一旦确定某个模块在当前生命周期中已经被导入, 则不会再次导入该模块了.</p>

<h1><code>__name__</code></h1>

<p>当我们在看 Python 源码的时候, 发现很多文件最下面都有类似这样的代码:</p>

<pre class="highlight"><code class="language-python">if __name__ == '__main__':
    suite</code></pre>

<p>当 Python 解释器解释执行一段源码文件前, 首先会定义一些特殊的变量, <code>__name__</code> 就是其中的一个属性, 我们可以直接打印出这个属性.</p>

<pre class="highlight"><code class="language-python">print(__name__)
# 执行代码, 输出结果是 `__main__`</code></pre>

<p>现在同样在 <code>my_module.py</code> 文件中输出这句话, 看一下结果是什么?</p>

<pre class="highlight"><code class="language-python"># 为了便于观察, 多输出一些信息
print('the value of name in my_module is: {}'.format(__name__))</code></pre>

<p>再次执行 <code>intro.py</code> 程序, 可以看到输出结果是 <code>the value of name in my_module is: my_module</code>. <code>__name__</code> 的值有两种结果:</p>

<ul>
<li>当 Python 文件直接被执行时, 它的值是 <code>__main__</code>
</li>
<li>当 Python 文件被当做一个模块引用时, 它的值就是模块名</li>
</ul>

<p>所以这个判断的意思就是: 当这个文件被 Python 直接调用执行时, 就执行判断里的语句. 这段代码里面一般都是用来测模块的测试用例的.</p>

<h1>Python 引用模块流程</h1>

<p>如果我们查看当前文件夹下的文件, 会发现多了一个 <code>.pyc</code> 的文件.</p>

<p>当 python 引入一个模块时, 首先会查找模块编译后的字节码文件 <code>模块名.pyo</code>, 这是一个优化后的模块的字节码文件, 如果找到该文件, 并且该文件的修改日期大于模块源文件(即.py)文件的修改日期, 则直接导入这个 pyo 文件.<br>
如果没有发现该文件, 则继续尝试查找名为 <code>模块名.pyc</code> 文件, 这是一个没有经过优化的模块的字节码文件, 如果找到该文件, 并且该文件的修改日期大于模块源文件的修改日期, 则直接引入该文件.<br>
如果没有发现该文件, Python 则尝试编译模块源文件来生成 <code>pyc</code> 或是 <code>pyo</code>, 最终引用编译后的字节码文件.</p>

<p>Python 之所以要先编译成字节码文件, 就是为了性能, 字节码文件可以直接被 Python 拿来运行, 免去了编译那一步, 并且字节码文件放到任何有相同版本的 Python 机器上, 都可以直接运行. 可以查看一下这个字节码文件的内容.</p>

<h1>编译 python 源码文件</h1>

<p>我们也可以手动编译一个 Python 文件: <code>python -O -m python_file.py</code>, <code>-O</code> 指定在生成字节码文件的同时进行优化, 也可以通过设置 <code>PYTHONOPTIMIZE</code> 环境变量达到同样的效果.<br>
如果指定了<code>-B</code> 参数将不会在磁盘上保存生成的字节码文件, 设置 <code>PYTHONDONTWRITEBYTECODE</code> 环境变量可以达到同样的效果.</p>

<p>使用编译后的字节码文件最大的优势就是提高执行速度, Python 在引入这些文件后, 无需在经过编译过程, 而可以直接使用. 同时也可以保护 Python 源码不被泄漏(虽然也有反编译软件).</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="模块" data-title="01_modules" id="___01_modules2" class="slide" data-transition="turnUp">
<div class="content " ref="模块/01_modules:2">
<h2>Python 引用模块流程</h2>

<p>当我们引用一个模块时, Python 首先查找 <code>模块名.pyo</code> 文件, 如果存在则引入该文件, 不存在, 则继续查找 <code>模块名.pyc</code> 文件, 存在则引入该文件, 若不存在, 则编译模块文件, 并引入模块.</p>

<p><img src="./file//_images/modules/import_modules.png" alt="import modules"></p>

<h2>编译 python 源码文件</h2>

<p>我们可以使用 Python 的 <code>-m</code> 参数来手动编译 Python 源文件来生成一个字节码文件:</p>

<pre class="highlight"><code class="language-shell">python -m filename.py</code></pre>

<p>如果指定了 <code>-O</code> 参数, 或是设置了 <code>PYTHONOPTIMIZE</code> 环境变量, 则在编译的过长中尝试进行优化操作.</p>

<p>如果指定了 <code>-B</code> 参数, 或是设置了 <code>PYTHONDONTWRITEBYTECODE</code> 环境变量, 则不会将生成的字节码文件保存到磁盘中.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>import 库</h1>

<p>让我们自定义一个简单的 Python 模块 <code>my_module.py</code>, 通过引用这个库来看一下 Python 中 import 的使用方法</p>

<pre class="highlight"><code class="language-python"># 首先在行首输出一段内容
print("imported my_module...")

# 定义一个变量
test = 'Test String'

# 定义一个简单的函数, 用来搜索列表中是否存在某个特定的值
def find_index(to_search, target):
    for i, value in enumerate(to_search):
        if value == target:
            return i

    # 如果没有找到, 则返回 -1
    return -1</code></pre>

<p>并且在当前目录下定义另一个 Python 文件 <code>intro.py</code></p>

<pre class="highlight"><code class="language-python"># 首先在这个文件中定义一个列表
courses = ['History', 'Math', 'Physics']</code></pre>

<p>现在, 如果我们想要使用 my_module 中的 find_index 方法. 必须使用 <code>import</code> 语句将这个模块导入到我们当前代码中.</p>

<pre class="highlight"><code class="language-python"># 使用 import 语句来引入这个模块
import my_module</code></pre>

<p>当我们使用 <code>import</code> 语句导入某个模块时, 实际上被导入的这个模块中的代码会被全部执行, 所以当我们执行代码后, 会看到 <code>my_module</code> 中的这条输出语句, 这也是为什么 <code>import</code> 语句可以导入其他模块中的变量和方法的原理. 实际上就是执行了一遍被导入模块中的方法.</p>

<p>当我们通过这种方式来导入一个模块之后, 并不能直接调用被导入模块中的方法或变量, 而是必须要通过<code>模块名.函数/变量</code> 的方式来使用.</p>

<pre class="highlight"><code class="language-python"># 输出 test 变量
print(my_module.test)

# 调用 find_index() 函数
index = my_module.find_index(courses, 'Math')
print(index)</code></pre>

<h2>通过 as 设定别名</h2>

<p>如果我们在代码中需要调用很多次 <code>find_index()</code>  方法, 每次都要使用 <code>my_module.find_index()</code> 的方式来访问这个函数, 或是当前代码中定义了 <code>my_module</code> 变量, 比如:</p>

<pre class="highlight"><code class="language-python">my_module = 5</code></pre>

<p>这时候在使用 <code>my_module.find_index()</code> 的方式访问这个变量时, 就会提示错误.</p>

<p>解决方法就是为这个模块指定别名, 在使用 <code>import</code> 语句导入一个模块时, 我们同时还可以使用 <code>as</code> 给这个模块指定一个别名, 如:</p>

<pre class="highlight"><code class="language-python">import my_module as mm
# 这时候, 我们就可以使用 mm 来代替 my_module 了

# 修改 my_module 为 mm
print(mm.test)
print(mm.find_index(courses, 'Math'))
# 现在一切就有正常了</code></pre>

<h1><code>from ... import ...</code></h1>

<p>除了上面这种方式外, Python 还支持我们只导入模块中的某一个或某些方法或变量, 格式为 <code>from...import...</code>, 如:</p>

<pre class="highlight"><code class="language-python"># 更改 import 语句
from my_module import find_index

# 通过这种方式导入的方法或变量
# 我们可以在代码中直接使用
# 而不需要在使用模块名或别名作为前缀了
# 修改 mm.find_index()
# 删掉 mm
print(test)
index = find_index(courses, 'Math')

# 执行代码
# 提示我们一个错误, 说 test 是未定义变量
# 这说明通过这种方式导入模块中的方法或是变量时
# 只有指定的方法或是变量才会被导入进来

# 把 test 变量追加到 import 语句中
# 多个变量和方法之间, 使用逗号分隔开
from my_module import find_index, test
# 再次执行, 代码可以被成功执行了</code></pre>

<p>其实我们还可以让代码变的更简单一些, 还是通过 as 设定别名的方式:</p>

<pre class="highlight"><code class="language-python"># 给 find_index 函数设置一个别名
from my_module import find_index as fi, test

# 替换掉 find_index
index = ff(courses, 'Math')</code></pre>

<h2>import *</h2>

<p>使用 <code>from...import...</code> 这种方式时, 如果我们想要从模块中的很多方法或是变量时, 必须得把所有这些需要导入进来的方法和函数名全都写到 import 语句中, 其实还有一种更简单的方式, 使用 <code>*</code> 来导入模块中的所有方法和变量, </p>

<pre class="highlight"><code class="language-python"># 使用 * 来调用所有
from my_module import *</code></pre>

<p>但是尽量不要使用这种方式, 如果被导入的库很大的话, 很容易造成混乱, 或者是造成命名冲突.</p>

<h2><strong>all</strong></h2>

<pre class="highlight"><code class="language-python"># 在 my_module.py 中使用
__all__ = ['find_index', 'test']</code></pre>

<h1>模块查找路径</h1>

<p>当我们导入一个模块时, Python 是怎么找到这些模块的呢? 或者说 Python 在哪些路径下查找这些模块呢?</p>

<p>如果我们引用的一个模块不是 Python 的内置模块, Python 会按照 <code>sys.path</code> 中的顺序依次查找库</p>

<pre class="highlight"><code class="language-python">import sys
print(sys.path)</code></pre>

<p>可以看到, Python 第一个查找路径是当前 python 脚本所在的路径, 这个跟在哪个目录下执行的这个脚本没有关系, 无论是在那个路径下执行的, 得到的都是一样的结果.</p>

<p>我们可以通过向这个路径附加一些路径信息来增加查找路径:</p>

<pre class="highlight"><code class="language-python">sys.path.append('/Users/gbyukg/Desktop')</code></pre>

<p>但是这样写对代码的可移植性造成影响. 另一个可行的方法是设置 <code>PYTHONPATH</code> 环境变量.</p>

<p>在 Python 中, 重复导入模块多次, 或是回环导入模块(比如模块A中引入了模块B, 而在模块B中又引用了模块A)不会引起任何问题, 因为 Python 在每次导入模块之前会首先查看模块是否已经被导入过, 一旦确定某个模块在当前生命周期中已经被导入, 则不会再次导入该模块了.</p>

<h1><code>__name__</code></h1>

<p>当我们在看 Python 源码的时候, 发现很多文件最下面都有类似这样的代码:</p>

<pre class="highlight"><code class="language-python">if __name__ == '__main__':
    suite</code></pre>

<p>当 Python 解释器解释执行一段源码文件前, 首先会定义一些特殊的变量, <code>__name__</code> 就是其中的一个属性, 我们可以直接打印出这个属性.</p>

<pre class="highlight"><code class="language-python">print(__name__)
# 执行代码, 输出结果是 `__main__`</code></pre>

<p>现在同样在 <code>my_module.py</code> 文件中输出这句话, 看一下结果是什么?</p>

<pre class="highlight"><code class="language-python"># 为了便于观察, 多输出一些信息
print('the value of name in my_module is: {}'.format(__name__))</code></pre>

<p>再次执行 <code>intro.py</code> 程序, 可以看到输出结果是 <code>the value of name in my_module is: my_module</code>. <code>__name__</code> 的值有两种结果:</p>

<ul>
<li>当 Python 文件直接被执行时, 它的值是 <code>__main__</code>
</li>
<li>当 Python 文件被当做一个模块引用时, 它的值就是模块名</li>
</ul>

<p>所以这个判断的意思就是: 当这个文件被 Python 直接调用执行时, 就执行判断里的语句. 这段代码里面一般都是用来测模块的测试用例的.</p>

<h1>Python 引用模块流程</h1>

<p>如果我们查看当前文件夹下的文件, 会发现多了一个 <code>.pyc</code> 的文件.</p>

<p>当 python 引入一个模块时, 首先会查找模块编译后的字节码文件 <code>模块名.pyo</code>, 这是一个优化后的模块的字节码文件, 如果找到该文件, 并且该文件的修改日期大于模块源文件(即.py)文件的修改日期, 则直接导入这个 pyo 文件.<br>
如果没有发现该文件, 则继续尝试查找名为 <code>模块名.pyc</code> 文件, 这是一个没有经过优化的模块的字节码文件, 如果找到该文件, 并且该文件的修改日期大于模块源文件的修改日期, 则直接引入该文件.<br>
如果没有发现该文件, Python 则尝试编译模块源文件来生成 <code>pyc</code> 或是 <code>pyo</code>, 最终引用编译后的字节码文件.</p>

<p>Python 之所以要先编译成字节码文件, 就是为了性能, 字节码文件可以直接被 Python 拿来运行, 免去了编译那一步, 并且字节码文件放到任何有相同版本的 Python 机器上, 都可以直接运行. 可以查看一下这个字节码文件的内容.</p>

<h1>编译 python 源码文件</h1>

<p>我们也可以手动编译一个 Python 文件: <code>python -O -m python_file.py</code>, <code>-O</code> 指定在生成字节码文件的同时进行优化, 也可以通过设置 <code>PYTHONOPTIMIZE</code> 环境变量达到同样的效果.<br>
如果指定了<code>-B</code> 参数将不会在磁盘上保存生成的字节码文件, 设置 <code>PYTHONDONTWRITEBYTECODE</code> 环境变量可以达到同样的效果.</p>

<p>使用编译后的字节码文件最大的优势就是提高执行速度, Python 在引入这些文件后, 无需在经过编译过程, 而可以直接使用. 同时也可以保护 Python 源码不被泄漏(虽然也有反编译软件).</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="模块" data-title="02_packages" id="___02_packages" class="slide" data-transition="none">
<div class="content " ref="模块/02_packages">
<h1>Python 中的包</h1>

<p>包就是包含了一个或多个 Python 模块和一个 <code>__init__.py</code> 文件的文件夹.</p>

<p>一个包的基本结构示意图:</p>

<pre class="highlight"><code>arithmetic
├── __init__.py
├── add.py
├── divide.py
├── multiply.py
└── subtract.py</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>package</h1>

<p>Python 中包的定义很简单, 就是一个目录, 首先这个目录下必须存在一个 <code>__init__.py</code> 的文件, 这个文件中的内容可以为空, 剩下就是一些 Python 的模块文件了, 在一个 包 中还可以包含多个子包.</p>

<p>包的作用就是把一系列相关功能放到一起, 这样维护是使用起来就比较方便了.</p>

<p>我这准备好了一个 <code>arithmetic</code> 目录, 结构很简单, 包含了一个 <code>__init__.py</code> 文件和一些 python 文件, 这些 python 中的代码非常简单, 都是只包含了一个简单函数的文件. 这就是一个包了, 可以看一下 <code>__init__.py</code>, 现在这个文件是一个空文件.</p>

<p>我在创建一个 <code>packages.py</code> 的文件用来使用这个包</p>

<pre class="highlight"><code class="language-python"># 引用一个包跟引用一个模块语法完全一样
# 使用 import 语句导入 arithmetic 中的 add 模块
import arithmetic.add

# 当引入这个包后
# 我们可以用 dir() 内置函数观察一下当前文件中有哪些东西
print(dir())
# 从输出中可以看到, 多了一个 `arithmetic`, 就是我们上面刚刚引入的这个包

# 我们可以使用另一个内置函数 help() 查看这个包中有哪些属性
print(help('arithmetic'))
# 查看包中的某个模块信息
print(help('arithmetic.add'))
# 可以看到有一个 add 方法

# 调用这个模块中的 add 方法
# 这里一定要注意, 第一个add 是包下的模块,
# 第二个 add 才是模块下的方法
result = arithmetic.add.add(1, 2)
# 打印出结果
print(result)

# 使用同样的方法导入
# 使用除法
# 注意这里模块名和方法名不同
result = arithmetic.divide.division(5, 2)

# 为了简介, 导入的时候也可以指定别名
arithmetic.add as add

# 从 add 模块中导入 add 方法
from arithmetic.add import add
result = add(5, 2)</code></pre>

<p>但是不管怎么写, 导入的时候每次都必须要指明 add 模块, 这样写很麻烦, 这是我们就可以通过修改 <code>__init__.py</code> 文件, 来指定默认导入的模块</p>

<pre class="highlight"><code class="language-python"># 在 init.py 文件中增加
import arithmetic.add

# 修改 package.py
import arithmetic.py
# 这样我们就已经导入了 add 模块
# 但是调用的地方还是很麻烦
result = arithmetic.add.add(5, 2)</code></pre>

<p>再次修改 init.py 文件</p>

<pre class="highlight"><code class="language-python">from arithmetic.add import add

# 调用的时候就可以直接使用包名.add了
result = arithmetic.add(5, 2)

# 最后都加进来
from arithmetic.add import add
from arithmetic.divide import division
from arithmetic.multiply import multiply
# 也可以写成 .
from .subtract import subtract</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="模块" data-title="03_future_module" id="___03_future_module" class="slide" data-transition="none">
<div class="content " ref="模块/03_future_module">
<h1>
<code>__future__</code> 模块</h1>

<p><code>__future__</code> 模块可以让我们在一个较低的 Python 版本中使用高版本中才有的某些功能, 或是将要在未来 Python 中增加的功能.</p>

<pre class="highlight"><code class="language-python">from __future__ import print_function
print('no new line', end='')</code></pre>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="文件操作" data-title="00_open" id="_____00_open1" class="slide" data-transition="none">
<div class="content " ref="文件操作/00_open:1">
<h1><code>open()</code></h1>

<p>在操作(读取或写入)一个文件之前, 首先需要打开这个文件, Python 为我们提供了内置函数 <code>open()</code> 来打开一个文件.</p>

<p>调用格式:<br>
<code>fileObj = open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></p>

<ul>
<li>
<code>file</code> 必填, 通常为要打开的文件名</li>
<li>
<code>mode</code> 可选, 打开文件的模式, 默认 <code>r</code>
</li>
<li>
<code>buffering</code>: 可选, 指定缓冲模式</li>
<li>
<code>encoding</code>: 可选, 指定文件的编码格式, 默认使用计算机的默认编码</li>
<li>
<code>errors</code>: 可选, 指定当出现编码错误时的描述字符串</li>
<li>
<code>newline</code>: 可选, 指定新行字符, 可选值有: <code>None</code>, <code></code>, <code>\n</code>, <code>r</code> 和 <code>\r\n</code>
</li>
<li>
<code>closefd</code>: 可选, 只能为 <code>True</code>
</li>
</ul>

<p><code>mode</code> 参数值:</p>

<table>
<thead>
<tr>
<th>可选值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>'r'</code></td>
<td>以只读的方式打开(默认)</td>
</tr>
<tr>
<td><code>'w'</code></td>
<td>以写的方式打开, 在打开文件的同时截取文件中的内容. 如果文件不存在, 则创建</td>
</tr>
<tr>
<td><code>'a'</code></td>
<td>以追加的方式打开. 如果文件不存在, 则创建</td>
</tr>
<tr>
<td><code>'b'</code></td>
<td>二进制模式</td>
</tr>
<tr>
<td><code>'r+'</code></td>
<td>以读写方式打开文件, 文件指针移动到文件起始位置</td>
</tr>
<tr>
<td><code>'w+'</code></td>
<td>以读写方式打开文件, 并截取文件中的内容. 如果文件不存在, 则创建</td>
</tr>
<tr>
<td><code>'a+'</code></td>
<td>以读写方式打开文件, 文件指针移动到文件末尾. 如果文件不存在, 则创建</td>
</tr>
</tbody>
</table>

<h2>文件对象</h2>

<p>通过 <code>open()</code> 方法打开一个文件后, 会返回给我们一个文件对象, 对文件的所有操作都是基于该文件对象的, 文件对象的一些属性:</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>file.closed</code></td>
<td>返回 True 如果文件已经被关闭, 否则返回 False</td>
</tr>
<tr>
<td><code>file.mode</code></td>
<td>返回被打开文件的访问权限</td>
</tr>
<tr>
<td><code>file.name</code></td>
<td>返回被打开文件的文件名</td>
</tr>
</tbody>
</table>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1># open</h1>

<p>在平时工作的时候, 我们想查看一个文件, 一共3个步骤:
- 首先是使用一个文本编辑器打开我们要查看的文件查看内容
- 查看文件内容
- 看完以后关掉这个文件</p>

<p>使用 Python, 或者是任何语言, 都是一样的操作, 打开文件, 读取里面的内容, 使用完以后关闭文件, 只是在 Python 里我们用 open() 方法打开一个文件, 而不是用一个文件编辑器.</p>

<pre class="highlight"><code class="language-python">f = open('test.txt', 'r')
# 第一个参数指定我们要打开的文件名
# 第二个参数指定打开文件时的权限, 读,写和追加

print(f.name) # 1
print(f.mode) # 2

# 在文件使用完以后, 我们应该关闭这个文件
# 因为没打开一个文件, 都会占用一定的系统资源,我们需要使用 close() 方法来释放这些资源
# 当然你要是不关闭也行, 当整个程序执行完毕退出以后, 所以打开的文件全部都会被自动关掉
# 但是对于生命周期很短, 打开的文件数量不是很多的程序来说, 不关闭也不是不可以的.
f.close()</code></pre>

<h2>读取文件内容</h2>

<pre class="highlight"><code class="language-python"># Python 还为我们提供了更便捷的方式, 使用 with 语句, 当执行完毕以后, 会自动为我们关闭文件
with open('test.txt', 'r') as f:
    # 我们把打开的文件对象赋给了变量 f
    # 并且变量 f 只能在该代码块中可见
    # 一旦退出代码块, 文件将被自动关闭

    # 文件对象本身是一个可迭代对象, 因此我们可以直接循环文件, 获取其中的内容
    # 这种方式获取文件内容时, 使用的是行缓冲模式
    for line in f:
        print(line)</code></pre>

<h2>read()</h2>

<pre class="highlight"><code class="language-python">f_contents = f.read()
print(f_contents)

# read 还可以接受一个参数, 用于指定读取多少个字节
f_contents = f.read(100)
print(f_contents)

# 再次执行一遍, 会看到输出了后面100个字符
# 而不是又从头开始读取
f_contents = f.read(100)
print(f_contents)

# 这是因为每个打开的文件都有一个文件指针, 用于指向下一次读取文件时的位置.
# 打开一个新文件时, 文件指针是0, 表示从第一个字符开始读取
# 每读取一个字符, 指针就会向后移动一个字节.
# 我们先读取了100个字符, 指针移动到100处的索引位置
# 所以在次读取时, 会接着读取内容, 而不是从头开始读

# 还可以通过 tell 获取当前
print(f.tell())

# 当文件内容全部读取完以后, 继续调用 read 读取文件, 会得到一个空的内容
# 我们可以通过判断读取到内容的长度判断是否达到文件结尾
f_contents = f.read(10)
while len(f_contents) &gt; 0:
    print(f_contents, end='')
    f_contents = f.read(10)</code></pre>

<h2>readline()</h2>

<pre class="highlight"><code class="language-python">f_contents = f.readline()
print(f_contents)</code></pre>

<h2>readlines()</h2>

<pre class="highlight"><code class="language-python">f_contents = f.readlines()
# 这是一个列表
print(f_contents)</code></pre>

<h1>写文件</h1>

<p>向一个以 <code>r</code> 打开的文件中写入文件, 提示错误, 文件不可写.</p>

<pre class="highlight"><code class="language-python">with open('test2.txt', 'w') as f:
    # 'w' 自动创建不存在文件

    # 注意, 写入文件时不会自动添加换行符
    # 使用 '\n' 表示换行符, 针对不同的操作系统, Python 会自动为我们转换
    f.write('string1')
    f.write('string2')
    f.write('string3')

    # 尝试在插入其它字符
    # 再次执行, 会发现之前写入的 string 已经没有了
    f.write('another line')

    # 这是因为当我们使用 'w' 打开一个文件时
    # 首先会自动截取文件中的内容, 就是清空
    # 可以使用 pass 语句, 表示打开文件后什么也不干
    pass
    # 执行完以后发现内容已经被清空了

    f.read() # 报错, 该成 `w+`

    # 虽然不报错了, 但是输出的还是为空? 这是为什么?
    # 刚才我们已经说过了, 每个文件里都有一个指针, 指向了当前读取到的文件内容的位置
    # 不只是读取内容会移动该指针, 写文件同样会移动指针
    # 所以如我们直接在下面读取文件内容时, 这个指针已经移动到文件的结尾了
    # 所以获取不到任何内容
    # seek()函数可以帮助我们移动指针的位置.
    f.seek(0)
    print(f.read())

    # 不截取文件
    # 'a+'
    # r+ 打开文件时会将文件指针移动到 0 位置, 写入是回覆盖文件中的内容.</code></pre>

<p>seek</p>

<pre class="highlight"><code class="language-python">    f.write('string1\n')
    f.write('string2\n')
    f.write('string3\n')

    f.seek(3)
    print(f.read(5))</code></pre>

<h2><code>flush()</code></h2>

<pre class="highlight"><code class="language-python">import time
with open('test.txt', 'w', buffering=3) as f:
    for i in range(6):
        f.write("current is: {}\n".format(i))
        #  f.flush()
        time.sleep(1)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="文件操作" data-title="00_open" id="_____00_open2" class="slide" data-transition="turnUp">
<div class="content " ref="文件操作/00_open:2">
<h1>常用方法</h1>

<h2><code>close()</code></h2>

<p>关闭一个已打开的文件.</p>

<h2>读取文件内容</h2>

<h3><code>f.read(N)</code></h3>

<p>读取文件中的内容, 该函数可以接受一个整数作为参数, 用于指定读取的字节数, 如果没有指定该参数, 则读取整个文件.</p>

<h3><code>f.readline()</code></h3>

<p>每次读取文件中的一行.</p>

<h3><code>f.readlines()</code></h3>

<p>使用 <code>readline()</code> 读取文件中的所有行, 并将读取到的这些行保存到列表中返回.</p>

<h2>写入文件</h2>

<h3><code>f.write(string)</code></h3>

<p>向一个以打开的有可写权限的文件中写入字符串 <code>string</code>, 若文件不存在, 则会自动创建.</p>

<h2>文件位置指针</h2>

<h3><code>f.tell()</code></h3>

<p>返回一个数值, 表示当前文件指针索引所在的位置.</p>

<h3><code>f.seek(offset[, from])</code></h3>

<p>将文件指针移动 <code>offset</code> 个字节.</p>

<p><code>from</code> 指明了指针移动时的参照位置</p>

<ul>
<li>
<code>0</code> 从文件起始位置开始计算 (默认)</li>
<li>
<code>1</code> 从当前指针所在位置开始计算</li>
<li>
<code>2</code> 从文件末尾开始计算</li>
</ul>

<p class="callout warning">从 Python3.2 以后, 如果以普通文本文件(打开时没有指定 <code>b</code>)方式打开的文件, 只允许从文件其实位置(0)开始移动文件指针.</p>

<h2><code>f.flush()</code></h2>

<p>刷新缓冲区</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1># open</h1>

<p>在平时工作的时候, 我们想查看一个文件, 一共3个步骤:
- 首先是使用一个文本编辑器打开我们要查看的文件查看内容
- 查看文件内容
- 看完以后关掉这个文件</p>

<p>使用 Python, 或者是任何语言, 都是一样的操作, 打开文件, 读取里面的内容, 使用完以后关闭文件, 只是在 Python 里我们用 open() 方法打开一个文件, 而不是用一个文件编辑器.</p>

<pre class="highlight"><code class="language-python">f = open('test.txt', 'r')
# 第一个参数指定我们要打开的文件名
# 第二个参数指定打开文件时的权限, 读,写和追加

print(f.name) # 1
print(f.mode) # 2

# 在文件使用完以后, 我们应该关闭这个文件
# 因为没打开一个文件, 都会占用一定的系统资源,我们需要使用 close() 方法来释放这些资源
# 当然你要是不关闭也行, 当整个程序执行完毕退出以后, 所以打开的文件全部都会被自动关掉
# 但是对于生命周期很短, 打开的文件数量不是很多的程序来说, 不关闭也不是不可以的.
f.close()</code></pre>

<h2>读取文件内容</h2>

<pre class="highlight"><code class="language-python"># Python 还为我们提供了更便捷的方式, 使用 with 语句, 当执行完毕以后, 会自动为我们关闭文件
with open('test.txt', 'r') as f:
    # 我们把打开的文件对象赋给了变量 f
    # 并且变量 f 只能在该代码块中可见
    # 一旦退出代码块, 文件将被自动关闭

    # 文件对象本身是一个可迭代对象, 因此我们可以直接循环文件, 获取其中的内容
    # 这种方式获取文件内容时, 使用的是行缓冲模式
    for line in f:
        print(line)</code></pre>

<h2>read()</h2>

<pre class="highlight"><code class="language-python">f_contents = f.read()
print(f_contents)

# read 还可以接受一个参数, 用于指定读取多少个字节
f_contents = f.read(100)
print(f_contents)

# 再次执行一遍, 会看到输出了后面100个字符
# 而不是又从头开始读取
f_contents = f.read(100)
print(f_contents)

# 这是因为每个打开的文件都有一个文件指针, 用于指向下一次读取文件时的位置.
# 打开一个新文件时, 文件指针是0, 表示从第一个字符开始读取
# 每读取一个字符, 指针就会向后移动一个字节.
# 我们先读取了100个字符, 指针移动到100处的索引位置
# 所以在次读取时, 会接着读取内容, 而不是从头开始读

# 还可以通过 tell 获取当前
print(f.tell())

# 当文件内容全部读取完以后, 继续调用 read 读取文件, 会得到一个空的内容
# 我们可以通过判断读取到内容的长度判断是否达到文件结尾
f_contents = f.read(10)
while len(f_contents) &gt; 0:
    print(f_contents, end='')
    f_contents = f.read(10)</code></pre>

<h2>readline()</h2>

<pre class="highlight"><code class="language-python">f_contents = f.readline()
print(f_contents)</code></pre>

<h2>readlines()</h2>

<pre class="highlight"><code class="language-python">f_contents = f.readlines()
# 这是一个列表
print(f_contents)</code></pre>

<h1>写文件</h1>

<p>向一个以 <code>r</code> 打开的文件中写入文件, 提示错误, 文件不可写.</p>

<pre class="highlight"><code class="language-python">with open('test2.txt', 'w') as f:
    # 'w' 自动创建不存在文件

    # 注意, 写入文件时不会自动添加换行符
    # 使用 '\n' 表示换行符, 针对不同的操作系统, Python 会自动为我们转换
    f.write('string1')
    f.write('string2')
    f.write('string3')

    # 尝试在插入其它字符
    # 再次执行, 会发现之前写入的 string 已经没有了
    f.write('another line')

    # 这是因为当我们使用 'w' 打开一个文件时
    # 首先会自动截取文件中的内容, 就是清空
    # 可以使用 pass 语句, 表示打开文件后什么也不干
    pass
    # 执行完以后发现内容已经被清空了

    f.read() # 报错, 该成 `w+`

    # 虽然不报错了, 但是输出的还是为空? 这是为什么?
    # 刚才我们已经说过了, 每个文件里都有一个指针, 指向了当前读取到的文件内容的位置
    # 不只是读取内容会移动该指针, 写文件同样会移动指针
    # 所以如我们直接在下面读取文件内容时, 这个指针已经移动到文件的结尾了
    # 所以获取不到任何内容
    # seek()函数可以帮助我们移动指针的位置.
    f.seek(0)
    print(f.read())

    # 不截取文件
    # 'a+'
    # r+ 打开文件时会将文件指针移动到 0 位置, 写入是回覆盖文件中的内容.</code></pre>

<p>seek</p>

<pre class="highlight"><code class="language-python">    f.write('string1\n')
    f.write('string2\n')
    f.write('string3\n')

    f.seek(3)
    print(f.read(5))</code></pre>

<h2><code>flush()</code></h2>

<pre class="highlight"><code class="language-python">import time
with open('test.txt', 'w', buffering=3) as f:
    for i in range(6):
        f.write("current is: {}\n".format(i))
        #  f.flush()
        time.sleep(1)</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="Python常用模块介绍" data-title="04_json" id="Python_______04_json" class="slide" data-transition="none">
<div class="content " ref="Python常用模块介绍/04_json">
<h1>json</h1>

<p><a href="http://amoffat.github.io/sh/">http://amoffat.github.io/sh/</a></p>
</div>
<canvas class="annotations"></canvas>
</div>
</div>
<div id="buttonNav">
  <div id="buttonPrev"><i class="fa fa-chevron-left fa-lg"></i> Previous</div><div id="buttonNext">Next <i class="fa fa-chevron-right fa-lg"></i></div>
</div>
<div id="pauseScreen">
  PAUSED
</div>

</body>
</html>
