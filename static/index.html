<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Python Training</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>

  
  <link rel="icon" href="../_images/clientdb.ico"/>
  

  <link rel="stylesheet" type="text/css" href=".//css/highlight/solarized_dark.css"  />
  <link rel="stylesheet" type="text/css" href=".//css/mermaid-6.0.0.css" />
  <link rel="stylesheet" type="text/css" href=".//css/font-awesome-4.4.0/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href=".//css/introjs-2.5.local.css">
  <link rel="stylesheet" type="text/css" href=".//css/jquery-ui-1.12.1.css">
  <link rel="stylesheet" type="text/css" href=".//css/showoff.css?v=0.19.0" />
  <link rel="stylesheet" type="text/css" href=".//css/zoomline-0.0.1.css">

  <script type="text/javascript" src=".//js/jquery-2.1.4.min.js"></script>
  <script type="text/javascript" src=".//js/jquery-ui-1.12.1.js"></script>

  <script type="text/javascript" src=".//js/jquery.cycle.all-2.8.0.js"></script>
  <script type="text/javascript" src=".//js/jquery.batchImageLoad-1.0.0.js"></script>
  <script type="text/javascript" src=".//js/jquery.parsequery.min-6a20f83.js"></script>
  <script type="text/javascript" src=".//js/jquery.doubletap-4ff02c5.js"></script>
  <script type="text/javascript" src=".//js/highlight.pack-9.2.0.js"></script>
  <script type="text/javascript" src=".//js/jTypeWriter-1.1.js"></script>
  <script type="text/javascript" src=".//js/bigtext-0.1.8.js"></script>
  <script type="text/javascript" src=".//js/zoomline-0.0.1.js"></script>
  <script type="text/javascript" src=".//js/simpleStrings-0.0.1.js"></script>
  <script type="text/javascript" src=".//js/mermaid-6.0.0-min.js"></script>

  <!-- waiting on https://github.com/usablica/intro.js/pull/727 -->
  <script type="text/javascript" src=".//js/intro-2.5.local.js"></script>

  <script type="text/javascript" src=".//js/coffee-script-1.1.3-pre.js"></script>

  <script type="text/javascript" src=".//js/annotations.js?v=0.19.0"></script>
  <script type="text/javascript" src=".//js/showoff.js?v=0.19.0"></script>

  
    <link rel="stylesheet" href=".//file/cusStyles.css" type="text/css"/>
  

  

  <script type="text/javascript">
    $(function(){
      setupPreso(false, './');
    });

    editUrl     = "";
    interactive = false;
    master      = false;

    keymap               = {
  "space": "NEXT",
  "d": "DEBUG",
  "up": "PREV",
  "left": "PREV",
  "pageup": "PREV",
  "down": "NEXT",
  "right": "NEXT",
  "pagedown": "NEXT",
  "R": "RELOAD",
  "r": "REFRESH",
  "c": "CONTENTS",
  "t": "CONTENTS",
  "h": "HELP",
  "/": "HELP",
  "?": "HELP",
  "b": "BLANK",
  ".": "BLANK",
  "F": "FOOTER",
  "f": "FOLLOW",
  "n": "NOTES",
  "esc": "CLEAR",
  "p": "PAUSE",
  "P": "PRESHOW",
  "x": "EXECUTE",
  "f5": "EXECUTE"
};
    keycode_dictionary   = {
  "0": "\\",
  "8": "backspace",
  "9": "tab",
  "12": "num",
  "13": "enter",
  "16": "shift",
  "17": "ctrl",
  "18": "alt",
  "19": "pause",
  "20": "caps",
  "27": "esc",
  "32": "space",
  "33": "pageup",
  "34": "pagedown",
  "35": "end",
  "36": "home",
  "37": "left",
  "38": "up",
  "39": "right",
  "40": "down",
  "44": "print",
  "45": "insert",
  "46": "delete",
  "48": "0",
  "49": "1",
  "50": "2",
  "51": "3",
  "52": "4",
  "53": "5",
  "54": "6",
  "55": "7",
  "56": "8",
  "57": "9",
  "59": ";",
  "61": "=",
  "65": "a",
  "66": "b",
  "67": "c",
  "68": "d",
  "69": "e",
  "70": "f",
  "71": "g",
  "72": "h",
  "73": "i",
  "74": "j",
  "75": "k",
  "76": "l",
  "77": "m",
  "78": "n",
  "79": "o",
  "80": "p",
  "81": "q",
  "82": "r",
  "83": "s",
  "84": "t",
  "85": "u",
  "86": "v",
  "87": "w",
  "88": "x",
  "89": "y",
  "90": "z",
  "91": "cmd",
  "92": "cmd",
  "93": "cmd",
  "96": "num_0",
  "97": "num_1",
  "98": "num_2",
  "99": "num_3",
  "100": "num_4",
  "101": "num_5",
  "102": "num_6",
  "103": "num_7",
  "104": "num_8",
  "105": "num_9",
  "106": "num_multiply",
  "107": "num_add",
  "108": "num_enter",
  "109": "num_subtract",
  "110": "num_decimal",
  "111": "num_divide",
  "112": "f1",
  "113": "f2",
  "114": "f3",
  "115": "f4",
  "116": "f5",
  "117": "f6",
  "118": "f7",
  "119": "f8",
  "120": "f9",
  "121": "f10",
  "122": "f11",
  "123": "f12",
  "124": "print",
  "144": "num",
  "145": "scroll",
  "173": "-",
  "186": ";",
  "187": "=",
  "188": ",",
  "189": "-",
  "190": ".",
  "191": "/",
  "192": "`",
  "219": "[",
  "220": "\\",
  "221": "]",
  "222": "'",
  "223": "`",
  "224": "cmd",
  "225": "alt",
  "57392": "ctrl",
  "63289": "num"
};
    keycode_shifted_keys = {
  "0": ")",
  "1": "!",
  "2": "@",
  "3": "#",
  "4": "$",
  "5": "%",
  "6": "^",
  "7": "&",
  "8": "*",
  "9": "(",
  "/": "?",
  ".": ">",
  ",": "<",
  "'": "\"",
  ";": ":",
  "[": "{",
  "]": "}",
  "\\": "|",
  "`": "~",
  "=": "+",
  "-": "_"
};
    user_translations    = {
};

    I18n = new translation({"name":"Showoff Presentation","menu":{"title":"Showoff Menu","table_of_contents":"Table of Contents","downloads":"Downloads","feedback":{"label":"Send Feedback","description":"This slide is...","worst":"Terrible","best":"Awesome","why":"Why...?","send":"Send"},"pace":{"label":"The presenter should...","slower":"Slow Down","faster":"Speed Up"},"question":{"label":"Ask a Question","placeholder":"Ask a question..."},"edit":"Edit Current Slide","clear_annotations":"Clear Annotations","language":"Content Language","close":"Close","help":"Press <code>?</code> for help.","anonymous":"All features are anonymous.","sending":"Sending..."},"navigation":{"next":"Next","previous":"Previous","sync":"Sync Presentation"},"loading":"loading presentation...","activity_complete":"Activity complete","follow":{"label":"Follow Mode:"},"refresh":"Are you sure you want to refresh the slide content?\n\n(Use `RELOAD` to fully reload the entire UI)","reload":"Are you sure you want to reload Showoff?","preshow":{"prompt":"Minutes from now to start?","resume":"Resuming in:"},"tour":{"reset":"Reset Hints","welcome":"<h3>Welcome to Showoff</h3>Let me show you around. After you finish this tour, it won't show again.","displayview":"Start by clicking this button to open the Display Window; then drag it onto the projector.","annotations":"Draw on your slides everywhere the presentation is displayed.","timer":"Set a countdown timer to help you stay on pace.","pace":"Audience members can use this to tell you if you're moving too quickly. Try to keep the indicator centered.","questions":"Questions asked by audience members are displayed here. You'll also see a count indicator on the Display Window when you have questions to answer.","notes":"Configure the notes display by zooming text, resizing the pane, or even popping it out into a new window.","slidesource":"The name of the slide is displayed here.","settings":"Would you like a different presenter layout? Choose that and other settings here.","edit":"This button will open your web-based editor--usually something like GitHub.","report":"Don't forget to report issues when you see them.","activity":{"count":"This will count down as audience members mark their activity complete. Their presentations will pause until completed.","complete":"Check this box when you're ready to move on. The presentation will pause while you're working."},"form":{"responses":"As questions are answered, they'll show up as a bar chart with the number of answers to each question on the right.","display":"Press this button to present a snapshot of the live responses on slide.","save":"Press this button to save your responses. The presentation will pause while answering."},"menu":"The menu in this corner allows independent navigation, file downloading, interactivity, and more."},"downloads":{"title":"File Downloads"},"help":{"title":"Help","next":"Move to the next slide.","prev":"Move to the previous slide.","contents":"Show the table of contents menu.","follow":"Toggle follow mode.","help":"Show this help dialog.","refresh":"Refresh slide content.","reload":"Completely reload Showoff.","blank":"Blank the screen.","footer":"Toggle the display footer.","notes":"Toggle notes display.","clear":"Clear code execution results.","pause":"Pause the presentation.","preshow":"Display slideshow of <tt>preshow</tt> images on a timer.","execute":"Execute the first visible code block.","debug":"Show debugging information.","close":"Close"},"stats":{"title":"Viewing Statistics","stray":"of your audience is not viewing the same slide you are.","idle":"of your audience is idle.","current":"Slides currently being viewed","elapsed":"Elapsed time spent on each slide","nodata":"No data to display.","allcurrent":"All audience members are viewing the presenter's slide."},"forms":{"display":"Display Results","save":"Save"},"presenter":{"topbar":{"annotations":"Annotations","edit":"Edit Slide","report":"Report Issue With Slide","stats":"Viewing Statistics","downloads":"Downloads","display":"Display Window","print":"Print Slides","settings":"Settings","newpage":"Open in a new page...","tooltip":{"annotations":"Enable the annotations subsystem.","edit":"Edit current slide in new window.","report":"Report an issue with the current slide.","stats":"See the slides your audience is interacting with.","downloads":"Open the file downloads in a menu or new page.","display":"Enable the Display Window; you should put this on the projector.","print":"Print slides using a new window.","settings":"Open the Settings dialog."}},"preview":{"next":"Next","previous":"Previous"},"mobile":{"update":"Update"},"notes":{"label":"Showoff Notes","personal":"Personal Notes"},"timer":{"label":"Timer:","start":"Start","pause":"Pause","resume":"Resume","cancel":"Cancel","unit":"minutes"},"pace":{"faster":"Speed Up!","slower":"Slow Down!"},"questions":"Audience Questions","annotation":{"tools":"Tools","lines":"Lines","shapes":"Shapes"},"status":{"label":"Slides:"},"settings":{"label":"Settings","close":"Close","follower":{"label":"Update Follower","tooltip":"Send slide change notifications.","description":"When this is enabled, the Showoff server will track your slide changes. Disable it to observe the presentation without inadvertently causing slide changes."},"remote":{"label":"Enable Remote","tooltip":"Enables tracking of other presenters.","description":"When this is enabled, you can load the presenter in another browser (typically on your mobile phone) to control the presentation."},"layout":{"label":"Layout","default":"Default Layout","thumbs":"Display thumbnail previews of the next and previous slides.","beside":"Display the next slide as a large preview in the main presenter view.","floating":"Open the next slide as a floating window.","confirmation":"Browser security requires confirmation before opening a new window.","open":"Open Window","cancel":"cancel","reset":{"label":"Clear Showoff settings.","tooltip":"Reset Showoff UI settings to default values."}},"language":{"label":"Content Language","tooltip":"Select from available translations, or autoselect based on your browser settings.","description":"This presentation is available in different languages. Choose the language you would like to view or leave it at <tt>automatic</tt> to use your browser settings."}},"print":{"label":"Choose type of printed notes","description":"Select the content you'd like to show under the slides.","none":"Don't include notes","notes":"Presenter Notes","handouts":"Audience Handouts"}},"language":{"auto":"Automatic","disable":"Disable Translations"},"error":{"file_not_found":"File Not Found!"}});

  </script>


  <script type="text/javascript">
    tours['showoff:activity'] = [
      {
        element: ".currentSlide .activityToggle",
        intro: I18n.t('tour.activity.complete')
      }
    ];

    tours['showoff:form'] = [
      {
        element: ".currentSlide input.save",
        intro: I18n.t('tour.form.save')
      }
    ];

    tours['showoff:menu'] = [
      {
        element: "#hamburger",
        intro: I18n.t('tour.menu')
      }
    ];

  </script>
</head>

<body>
<div id="questionsIndicator"></div>

<i id="hamburger" class="fa fa-bars fa-2x"></i>
<div id="sidebarWrapper">
    <div id="navigationHover"></div>
    <div id="feedbackSidebar" class="sideMenu">
    <img id="disconnected" src=".//css/disconnected.png">
    <h3>Showoff Menu</h3>
    <div id="navToggle" class="buttonWrapper"><i class=" fa fa-bookmark"></i> Table of Contents</div>
    <div id="navigation" class="submenu"></div>
    
    <hr>

    

    

    <div id="closeMenu" class="buttonWrapper"><i class="fa fa-close"></i> Close</div>
    <hr>

    <small>
        <p>Press <code>?</code> for help.</p>
        <p>All features are anonymous.</p>
    </small>
    </div>
    <div id="sidebarExit"></div>
</div>
<div id="help-modal" title="Help">
  <div id="help">
    <div>
      <span class="description">Move to the next slide.</span>
      <span class="action">NEXT</span>
      <span class="hotkeys"><span class="key">space</span><span class="key">down</span><span class="key">right</span><span class="key">pagedown</span></span>
    </div>
    <div>
      <span class="description">Move to the previous slide.</span>
      <span class="action">PREV</span>
      <span class="hotkeys"><span class="key">up</span><span class="key">left</span><span class="key">pageup</span></span>
    </div>
    <div>
      <span class="description">Show the table of contents menu.</span>
      <span class="action">CONTENTS</span>
      <span class="hotkeys"><span class="key">c</span><span class="key">t</span></span>
    </div>
    <div>
      <span class="description">Toggle follow mode.</span>
      <span class="action">FOLLOW</span>
      <span class="hotkeys"><span class="key">f</span></span>
    </div>
    <div>
      <span class="description">Show this help dialog.</span>
      <span class="action">HELP</span>
      <span class="hotkeys"><span class="key">h</span><span class="key">/</span><span class="key">?</span></span>
    </div>

    <hr />

    <div>
      <span class="description">Refresh slide content.</span>
      <span class="action">REFRESH</span>
      <span class="hotkeys"><span class="key">r</span></span>
    </div>
    <div>
      <span class="description">Completely reload Showoff.</span>
      <span class="action">RELOAD</span>
      <span class="hotkeys"><span class="key">R</span></span>
    </div>
    <div>
      <span class="description">Blank the screen.</span>
      <span class="action">BLANK</span>
      <span class="hotkeys"><span class="key">b</span><span class="key">.</span></span>
    </div>
    <div>
      <span class="description">Toggle the display footer.</span>
      <span class="action">FOOTER</span>
      <span class="hotkeys"><span class="key">F</span></span>
    </div>
    <div>
      <span class="description">Toggle notes display.</span>
      <span class="action">NOTES</span>
      <span class="hotkeys"><span class="key">n</span></span>
    </div>
    <div>
      <span class="description">Clear code execution results.</span>
      <span class="action">CLEAR</span>
      <span class="hotkeys"><span class="key">esc</span></span>
    </div>
    <div>
      <span class="description">Pause the presentation.</span>
      <span class="action">PAUSE</span>
      <span class="hotkeys"><span class="key">p</span></span>
    </div>
    <div>
      <span class="description">Display slideshow of <tt>preshow</tt> images on a timer.</span>
      <span class="action">PRESHOW</span>
      <span class="hotkeys"><span class="key">P</span></span>
    </div>
    <div>
      <span class="description">Execute the first visible code block.</span>
      <span class="action">EXECUTE</span>
      <span class="hotkeys"><span class="key">x</span><span class="key">f5</span></span>
    </div>

    <hr />

    <div>
      <span class="description">Show debugging information.</span>
      <span class="action">DEBUG</span>
      <span class="hotkeys"><span class="key">d</span></span>
    </div>
  </div>
</div>

<div id="preso"><center>loading presentation...</center></div>
<a id="synchronize"><i class="fa fa-link" aria-hidden="true" href="#"></i> Sync Presentation</a>
<div id="notes"></div>

<footer id="footer">
  <span id="followLabel" class="container">Follow Mode: <i id="followMode" class="fa fa-ban" aria-hidden="true"></i></span>
  <span id="slideInfo" class="container"></span>
  <span id="debugInfo" class="container"></span>
  <span id="notesInfo" class="container"></span>
  <span id="slideFilename" class="container"></span>
  <img id="disconnected" src=".//css/disconnected.png" />
</footer>

<div id="slides" class="offscreen" style="display:none;">
<div data-section="Python介绍" data-title="01_python" id="Python___01_python" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="Python介绍/01_python">
<h1>Python</h1>

<p><a href="https://www.python.org/">https://www.python.org</a></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>Python</h1>

<p>Python 属于解释型语言, 代码是在运行时候解释的, 不同于编译型语言, 解释性语言最让人诟病的就是速度了. 但是既然是解释性语言, 就一定是跨平台的了, 只要是在不同的平台上安装同样的编译器即可.</p>

<p>python 本身这门既可以 面向对象开发, 也可以是 面向过程</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="Python介绍" data-title="02_author" id="Python___02_author" class="slide" data-transition="none">
<div class="content " ref="Python介绍/02_author">
<h1>Python 作者</h1>

<p>Python 作者 <a href="https://en.wikipedia.org/wiki/Guido_van_Rossum">Guido van Rossum</a> 在 1991 年创建了第一个Python的编译器.</p>

<p><img src="./file//_images/introduction/Guido.png" alt="Alt text"></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>大部分人觉得对这些人的了解没有用, 但有些时候, 对他们有了一定的了解, 也会对我们有一些帮助的, 比如 C 语言和 UNIX 之父 丹尼斯·里奇, 他在 1970年创建了 C 语言, 并用C语言开发的 UNIX 操作系统, 如果知道这些, 你就会知道, 为什么现在所有计算机的起始时间是从 1970 年开始, 因为那一年创建的Unix操作系统,</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="Python介绍" data-title="03_whyPython" id="Python___03_whyPython" class="slide" data-transition="none">
<div class="content " ref="Python介绍/03_whyPython">
<h1>为什么选择 Python</h1>

<ul>
<li><p>语法简洁易懂<br>
Python 作者在设计之初就以 容易阅读，容易使用，容易记忆，容易学习为初衷来设计的, 以此来激发人们学习编程的兴趣</p></li>
<li><p>对操作系统友好<br>
Python既能够像 C 语言那样, 全面调用操作系统的接口(比如后面要将的关于文件系统, 信号, 进程等), 又可以像 shell那样轻松编程, 是 DevOps 的首选语言.</p></li>
<li>
<p>丰富的扩展库  </p>

<ul>
<li>迄今为止, 世界上已经包含了上千个 Python 库, 从web开发, 到操作系统级别的库, 再到机器学习的库. <a href="https://pypi.python.org/pypi/pip">Python 库列表</a>
</li>
<li>
<a href="https://github.com/vinta/awesome-python">awesome Python</a> 这是一个份 Python 库列表, 列举了最常用的一些库.</li>
</ul>
</li>
<li><p>可应用在多个领域<br>
Python 应用的领域极为广泛, 从大的方面来说, 包括 web 开发, 桌面程序(包括命令行工具), 计算机科学领域开发(尤其是在机器学习领域, 虽然 R 语言也应用在该领域中, 但对比起晦涩难懂的语法, 以及Python丰富的库, Python是当今世界上在该领域上应用最广泛的语言, 其中最著名的当属 Google 的 <a href="https://github.com/tensorflow/tensorflow">tensorflow</a>.</p></li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>还有著名的DevOps ansible, 也是用 Python 写的</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="Python介绍" data-title="04_trend" id="Python___04_trend" class="slide" data-transition="none">
<div class="content " ref="Python介绍/04_trend">
<h1>Python 趋势</h1>

<p><img src="./file//_images/introduction/trend.png" alt="Alt text"></p>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="01_version" id="__Python_01_version" class="slide" data-transition="none">
<div class="content " ref="安装Python/01_version">
<h1>版本选择</h1>

<p>Python当前主要存在两个版本</p>

<ul>
<li>Python2 最新版本为 <code>2.7</code>, 这也是大部分操作系统默认自带的 Python 版本.</li>
<li>
<strong>Python3</strong> 最新版本为 <code>3.6</code>
</li>
</ul>

<p>2008 年, Python3 被引入, Python3 被设计为向下不兼容模式, 这意味着在 Python2 下运行良好的程序, 在 Python3 中可能会异常退出或崩溃.</p>

<p>但是 Python 提供了一些列的工具来帮助我们将 Python2 的代码迁移到 Python3 中.</p>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="02_pythonInstall" id="__Python_02_pythonInstall1" class="slide" data-transition="none">
<div class="content " ref="安装Python/02_pythonInstall:1">
<h1>从源码安装 Python</h1>

<h2>准备</h2>

<pre class="highlight"><code class="language-bash">yum install -y \
    zlib-devel \
    readline-devel \
    bzip2-devel \
    libsq3-devel \
    openssl-devel </code></pre>

<h2>编译&amp;安装</h2>

<pre class="highlight"><code class="language-bash">./configure --prefix=/usr/local/python2.7 &amp;&amp; \
make &amp;&amp; \
make install</code></pre>

<p>查看 Python 版本</p>

<pre class="highlight"><code class="language-shell execute">/usr/local/python2.7/bin/python -V</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>当确定好 Python 版本后, 就可以安装 Python 了.</p>

<p>作为一名 DevOps, 平时接触最多的操作系统就是 类Unix系统了. 大部分自动化运维脚本都是在这些系统上跑的. 所以安装主要是针对 类 Linux/Unix 系统的
对于基于Windows和Mac上的Python非常简单, 一直下一步下一步就可以了.</p>

<p>虽然一般大部分系统主流操作系统中都已经预先安装好了 Python, 但某些情况下, 如预安装的 Python 版本不符合我们的要求, 或在系统上运行的多个 Python 项目使用了不同的 Python 版本等.</p>

<p>在Linux系统上使用包管理工具(如 yum, apt)安装也很简单, 这里也不多做介绍了.</p>

<p>我们主要介绍一下从源码安装 Python, python的源码可以从官网下载到, 也可以从 github 上下载到.</p>

<p><code>wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz</code><br>
<code>tar -Jxvf Python-3.6.2.tar.xz</code></p>

<p>在编译Python源码之前, 我们首先要安装一些库文件, 这些库是安装 Python 时所依赖的库, 但并不是必须的, 当编译 Python 时, 只有开启某些功能时, 才会需要相应的库, 或者说只有某些库存在时, 才会开启Python的某些功能. 比如要使用 ssl 功能, 系统就要先与装好 openssl 的 dev 库</p>

<p>执行 <code>configure</code> 和 <code>make</code> 命令开始编译和安装 Python 源码  </p>

<p>这里对 configure 和 make 做一下简单的说明:<br>
这种安装方式不止是针对 Python, 对大部分 C 编写的软件都适用, 之所以说是大部分, 是那些使用了 <code>autotools</code> 工具来管理源码安装的, 有些 C 工具或 C 库并不使用 <code>autotools</code> 而是其他工具, 比如 <code>cmake</code>, 这时候 <code>configure</code> 和 <code>make</code> 就有可能不生效了</p>

<p>当安装好python 后, 可以执行 <code>python -V</code> 查看 python 版本信息</p>

<p>python 也支持交互模式, 直接输入 <code>python</code> 命令就可进入, 输入 <code>exit()</code> 退出交互模式, 或直接使用快捷键 <code>CTRL-D</code>, <code>CTRL-D</code> 是什么意思?</p>

<hr>

<p>从源码安装虽然是一种可行的方式.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="02_pythonInstall" id="__Python_02_pythonInstall2" class="slide bullets incremental" data-transition="fade">
<div class="content bullets incremental" ref="安装Python/02_pythonInstall:2">
<h2>autotools</h2>

<p><em>configure 是由 autotools 系列工具生成出来的 SHELL 脚本文件, 该脚本最主要作用 检测安装环境(包括必要的库,头文件等是否存在); 软件的功能性的配置(打开/关闭 XXX功能) 以及生成 Makefile.</em></p>

<blockquote>
<p>autotools 由一系列工具组成, 包括:</p>
</blockquote>

<ul>
<li> - <code>autoconf</code> 用于生成 configure shell 脚本 执行 <code>./configure -h</code> 查看帮助信息.</li>
<li> - <code>automake</code> 由 autoconf 调用, 生成 Makefile 文件</li>
<li> - <code>libtool</code> 根据配置生成共享库文件</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>当确定好 Python 版本后, 就可以安装 Python 了.</p>

<p>作为一名 DevOps, 平时接触最多的操作系统就是 类Unix系统了. 大部分自动化运维脚本都是在这些系统上跑的. 所以安装主要是针对 类 Linux/Unix 系统的
对于基于Windows和Mac上的Python非常简单, 一直下一步下一步就可以了.</p>

<p>虽然一般大部分系统主流操作系统中都已经预先安装好了 Python, 但某些情况下, 如预安装的 Python 版本不符合我们的要求, 或在系统上运行的多个 Python 项目使用了不同的 Python 版本等.</p>

<p>在Linux系统上使用包管理工具(如 yum, apt)安装也很简单, 这里也不多做介绍了.</p>

<p>我们主要介绍一下从源码安装 Python, python的源码可以从官网下载到, 也可以从 github 上下载到.</p>

<p><code>wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz</code><br>
<code>tar -Jxvf Python-3.6.2.tar.xz</code></p>

<p>在编译Python源码之前, 我们首先要安装一些库文件, 这些库是安装 Python 时所依赖的库, 但并不是必须的, 当编译 Python 时, 只有开启某些功能时, 才会需要相应的库, 或者说只有某些库存在时, 才会开启Python的某些功能. 比如要使用 ssl 功能, 系统就要先与装好 openssl 的 dev 库</p>

<p>执行 <code>configure</code> 和 <code>make</code> 命令开始编译和安装 Python 源码  </p>

<p>这里对 configure 和 make 做一下简单的说明:<br>
这种安装方式不止是针对 Python, 对大部分 C 编写的软件都适用, 之所以说是大部分, 是那些使用了 <code>autotools</code> 工具来管理源码安装的, 有些 C 工具或 C 库并不使用 <code>autotools</code> 而是其他工具, 比如 <code>cmake</code>, 这时候 <code>configure</code> 和 <code>make</code> 就有可能不生效了</p>

<p>当安装好python 后, 可以执行 <code>python -V</code> 查看 python 版本信息</p>

<p>python 也支持交互模式, 直接输入 <code>python</code> 命令就可进入, 输入 <code>exit()</code> 退出交互模式, 或直接使用快捷键 <code>CTRL-D</code>, <code>CTRL-D</code> 是什么意思?</p>

<hr>

<p>从源码安装虽然是一种可行的方式.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="03_pyenv" id="__Python_03_pyenv1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="安装Python/03_pyenv:1">
<h1>pyenv</h1>

<p><a href="https://github.com/pyenv/pyenv">https://github.com/pyenv/pyenv</a></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pyenv 介绍</h1>

<p>虽然从源码编译安装Python没有问题, 但是一些工具的出现将会大大提高我们的效率. <code>pyenv</code> 就是其中一个工具, 使用它我们可以快速的安装一个 Python.</p>

<p>安装 pyenv 非常简单, 只需要将源码下载到本地, 并设置好一些环境变量即可.</p>

<p>当 pyenv 安装好之后, 就可以使用了.</p>

<p><code>pyenv local XXX</code> 该命令会在当前目录下创建一个隐藏文件 .python-version, 该文件内记录了 Python 的版本信息, 就是我们在命令行指定的这个参数, 每次当我们进入到这个目录内之后, pyenv 就会自动切换到这个文件中指定的 Python 版本, 有点 <code>automount</code> 的意思. 当退出这个目录后, Python 又被设定成 <code>global</code> 中指定的 Python 版本了.</p>

<p><code>pyenv -v</code> 在安装好 pyenv 之后, 就可以使用 <code>-v</code> 参数查看我们安装好的 pyenv 的版本, 同时也可以验证我们是否正确的安装了 <code>pyenv</code></p>

<p>如何查看我们可以安装哪些 Python 的版本呢? <code>pyenv install --list</code></p>

<pre class="highlight"><code class="language-bash">
# 列出所有可以安装的 Python 版本
pyenv install --list

# 安装 Python 3.6
pyenv install 3.6.2

# 查看当前使用的 Python 版本
pyenv version
# 查看系统已经安装好了的 Python 版本
pyenv versions

# 查看当前Python 版本
python -V

# 指定要使用的 Python 版本(全局)
# ~/.pyenv/version
pyenv global 3.6.2
python -V

# 为当前所在项目设置 Python 环境
pyenv local 2.7.13
python -V
cat .python-version

# 取消针对当前项目的设置
pyenv local --unset</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="03_pyenv" id="__Python_03_pyenv2" class="slide" data-transition="turnUp">
<div class="content " ref="安装Python/03_pyenv:2">
<h1>从 pyenv 安装Python</h1>

<p>pyenv 主要是用 <code>SHELL</code> 编写的工具, 它可以然我们在系统中同时安装多个 Python 版本, 在已安装的 Python 版本中随意地进行切换.</p>

<h2>安装 pyenv</h2>

<pre class="highlight"><code class="language-bash"># 获取源码
git clone https://github.com/pyenv/pyenv.git ~/.pyenv

# 设置 PVENV_ROOT 环境变量, 注意如果你使用的是其他shell, 如 ZSH, 请使用 .zshenv 代替 .bash_profile 文件.
echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.bash_profile
echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.bash_profile
echo 'eval "$(pyenv init -)"' &gt;&gt; ~/.bash_profile

# 使修改生效, 或重新登录shell
. ~/.bash_profile</code></pre>

<p class="callout warning">以上我们是将pyenv安装到了当前用户下, 所以仅对当前用户生效.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pyenv 介绍</h1>

<p>虽然从源码编译安装Python没有问题, 但是一些工具的出现将会大大提高我们的效率. <code>pyenv</code> 就是其中一个工具, 使用它我们可以快速的安装一个 Python.</p>

<p>安装 pyenv 非常简单, 只需要将源码下载到本地, 并设置好一些环境变量即可.</p>

<p>当 pyenv 安装好之后, 就可以使用了.</p>

<p><code>pyenv local XXX</code> 该命令会在当前目录下创建一个隐藏文件 .python-version, 该文件内记录了 Python 的版本信息, 就是我们在命令行指定的这个参数, 每次当我们进入到这个目录内之后, pyenv 就会自动切换到这个文件中指定的 Python 版本, 有点 <code>automount</code> 的意思. 当退出这个目录后, Python 又被设定成 <code>global</code> 中指定的 Python 版本了.</p>

<p><code>pyenv -v</code> 在安装好 pyenv 之后, 就可以使用 <code>-v</code> 参数查看我们安装好的 pyenv 的版本, 同时也可以验证我们是否正确的安装了 <code>pyenv</code></p>

<p>如何查看我们可以安装哪些 Python 的版本呢? <code>pyenv install --list</code></p>

<pre class="highlight"><code class="language-bash">
# 列出所有可以安装的 Python 版本
pyenv install --list

# 安装 Python 3.6
pyenv install 3.6.2

# 查看当前使用的 Python 版本
pyenv version
# 查看系统已经安装好了的 Python 版本
pyenv versions

# 查看当前Python 版本
python -V

# 指定要使用的 Python 版本(全局)
# ~/.pyenv/version
pyenv global 3.6.2
python -V

# 为当前所在项目设置 Python 环境
pyenv local 2.7.13
python -V
cat .python-version

# 取消针对当前项目的设置
pyenv local --unset</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="03_pyenv" id="__Python_03_pyenv3" class="slide" data-transition="turnUp">
<div class="content " ref="安装Python/03_pyenv:3">
<h2>使用 pyenv</h2>

<p>查看 <code>pyven</code> 版本信息</p>

<pre class="highlight"><code class="language-shell execute">pyenv -v</code></pre>

<p>获取帮助信息</p>

<pre class="highlight"><code class="language-shell execute">pyenv -h</code></pre>

<p>获取子命令帮助信息</p>

<pre class="highlight"><code class="language-shell execute">pyenv install -h</code></pre>

<p>查看可以安装的 Python 版本</p>

<pre class="highlight"><code class="language-shell execute">pyenv install -l</code></pre>

<p>安装指定的 Python 版本</p>

<pre class="highlight"><code class="language-bash">pyenv install 3.6.2</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pyenv 介绍</h1>

<p>虽然从源码编译安装Python没有问题, 但是一些工具的出现将会大大提高我们的效率. <code>pyenv</code> 就是其中一个工具, 使用它我们可以快速的安装一个 Python.</p>

<p>安装 pyenv 非常简单, 只需要将源码下载到本地, 并设置好一些环境变量即可.</p>

<p>当 pyenv 安装好之后, 就可以使用了.</p>

<p><code>pyenv local XXX</code> 该命令会在当前目录下创建一个隐藏文件 .python-version, 该文件内记录了 Python 的版本信息, 就是我们在命令行指定的这个参数, 每次当我们进入到这个目录内之后, pyenv 就会自动切换到这个文件中指定的 Python 版本, 有点 <code>automount</code> 的意思. 当退出这个目录后, Python 又被设定成 <code>global</code> 中指定的 Python 版本了.</p>

<p><code>pyenv -v</code> 在安装好 pyenv 之后, 就可以使用 <code>-v</code> 参数查看我们安装好的 pyenv 的版本, 同时也可以验证我们是否正确的安装了 <code>pyenv</code></p>

<p>如何查看我们可以安装哪些 Python 的版本呢? <code>pyenv install --list</code></p>

<pre class="highlight"><code class="language-bash">
# 列出所有可以安装的 Python 版本
pyenv install --list

# 安装 Python 3.6
pyenv install 3.6.2

# 查看当前使用的 Python 版本
pyenv version
# 查看系统已经安装好了的 Python 版本
pyenv versions

# 查看当前Python 版本
python -V

# 指定要使用的 Python 版本(全局)
# ~/.pyenv/version
pyenv global 3.6.2
python -V

# 为当前所在项目设置 Python 环境
pyenv local 2.7.13
python -V
cat .python-version

# 取消针对当前项目的设置
pyenv local --unset</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="03_pyenv" id="__Python_03_pyenv4" class="slide" data-transition="turnUp">
<div class="content " ref="安装Python/03_pyenv:4">
<h1>pyenv 常用命令</h1>

<p>查看系统中安装了哪些 Python 版本</p>

<pre class="highlight"><code class="language-shell execute">pyenv versions</code></pre>

<p>查看当前 pyenv 使用的 Python 版本</p>

<pre class="highlight"><code class="language-shell execute">pyenv version</code></pre>

<p>设置默认的 Python 版本</p>

<pre class="highlight"><code class="language-bash">pyenv global 3.6.2</code></pre>

<p>为当前目录设置 Python 版本</p>

<pre class="highlight"><code class="language-bash">pyenv local 3.6.2</code></pre>

<p>显示当前使用的 pyenv 的路径信息</p>

<pre class="highlight"><code class="language-shell execute">pyenv which python</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pyenv 介绍</h1>

<p>虽然从源码编译安装Python没有问题, 但是一些工具的出现将会大大提高我们的效率. <code>pyenv</code> 就是其中一个工具, 使用它我们可以快速的安装一个 Python.</p>

<p>安装 pyenv 非常简单, 只需要将源码下载到本地, 并设置好一些环境变量即可.</p>

<p>当 pyenv 安装好之后, 就可以使用了.</p>

<p><code>pyenv local XXX</code> 该命令会在当前目录下创建一个隐藏文件 .python-version, 该文件内记录了 Python 的版本信息, 就是我们在命令行指定的这个参数, 每次当我们进入到这个目录内之后, pyenv 就会自动切换到这个文件中指定的 Python 版本, 有点 <code>automount</code> 的意思. 当退出这个目录后, Python 又被设定成 <code>global</code> 中指定的 Python 版本了.</p>

<p><code>pyenv -v</code> 在安装好 pyenv 之后, 就可以使用 <code>-v</code> 参数查看我们安装好的 pyenv 的版本, 同时也可以验证我们是否正确的安装了 <code>pyenv</code></p>

<p>如何查看我们可以安装哪些 Python 的版本呢? <code>pyenv install --list</code></p>

<pre class="highlight"><code class="language-bash">
# 列出所有可以安装的 Python 版本
pyenv install --list

# 安装 Python 3.6
pyenv install 3.6.2

# 查看当前使用的 Python 版本
pyenv version
# 查看系统已经安装好了的 Python 版本
pyenv versions

# 查看当前Python 版本
python -V

# 指定要使用的 Python 版本(全局)
# ~/.pyenv/version
pyenv global 3.6.2
python -V

# 为当前所在项目设置 Python 环境
pyenv local 2.7.13
python -V
cat .python-version

# 取消针对当前项目的设置
pyenv local --unset</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="04_pip" id="__Python_04_pip1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="安装Python/04_pip:1">
<h1>pip</h1>

<p>Python Package Manager: <a href="https://pypi.python.org/pypi/pip">https://pypi.python.org/pypi/pip</a></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pip</h1>

<p>至此我们已经安装好 Python 了, 有了基本的开发环境, 但这还不够, 在大部分开发过程中, 我们会使用很多 Python 的第三方库, Python 为我们提供了很好的包管理工具, 这就是 <code>pip</code>, 使用它, 我们可以快速地安装或更新 Python 库.</p>

<p><code>pip help</code> 首先, 第一个命令还是如何查看 pip 的帮助文档信息.<br>
<code>pip help install</code> 还可以查看子命令的帮助文档.
=====222222rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr里以 <code>requests</code> 库为例来展示如何使用 pip</p>

<ul>
<li>
<code>pip search requests</code> 在安装一个扩展库之前, 我们可以使用 <code>search</code> 子命令来查询该扩展库.</li>
<li>
<code>pip install reauests</code> 在找到该库以后, 就可以使用 install 命令来安装扩展库了</li>
<li>
<code>pip list</code> 安装完以后, 我们可以使用 <code>pip list</code> 命令来查看库是否已经被安装好了, 该命名会展示所有当前系统中已经安装好了的库</li>
<li>
<code>pip show --verbose requests</code> 显示当前已经安装库的详细信息</li>
<li>
<code>pip uninstall requests</code> 也可以使用 <code>uninstall</code> 来卸载已经安装的库.</li>
</ul>

<p>刚才我们使用 <code>pip install requests</code> 命令直接安装了 request 库, 这默认将安装最新版本的库, 在安装的时候, 我们还可以指定要安装的版本,如: <code>pip install requests==2.0.0</code> 表示将安装指定的版本, <code>pip install requests&gt;=2.0.0</code></p>

<p>如果当我们开发的一个项目需要很多依赖库, 一个一个安装这些苦将非常痛苦, 并且为了不出现 "这段代码在我电脑上运行没有问题啊" 这种问题, 所有开发者应该严格使用一直的库版本. 我们可以将所有这些依赖库以及版本信息写入到一个文件中, 在用 <code>pip install</code> 时候使用 <code>-r</code> 选项指定这个文件, 则该文件中的所有库都将被安装, 并且该文件还可以被放到版本控制中, 方便追中依赖库的更新信息.</p>

<p>pip 为我们提供了 <code>freeze</code> 命令, 该命令会将当前系统上安装的所有依赖和版本信息都打印出来, 这些信息就可以作为 <code>install -r</code> 选项的输入文件. <code>pip freeze</code>, <code>pip freeze &gt; requirements.txt</code>, <code>pip install -r requirements.txt</code></p>

<p>刚才我们一直在使用 <code>pip list</code> 命令查看当前系统已安装的库信息, 它还有一个比较常用的选项 <code>-o/----outdated</code>, 可以使用 <code>pip help list</code> 查看帮助文档, 该参数会列出当前系统中可更新的库.  </p>

<p>使用 <code>pip install</code> 的 <code>-U</code> 参数, 可以让我们更新某个库.<br>
如果当前系统中存在大量已经过期的库(或者说有更新的库), 想要安装这些库, 如果手动一个一个来更新就比较费时了, 这有一段代码可用来更新当前系统中的所有库. <code>pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U</code></p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="04_pip" id="__Python_04_pip2" class="slide incremental" data-transition="turnUp">
<div class="content incremental" ref="安装Python/04_pip:2">
<h1>进入 pip</h1>

<p>获取帮助信息</p>

<pre class="highlight"><code class="language-shell execute">pip -h</code></pre>

<p>获取子命令的帮助信息</p>

<pre class="highlight"><code class="language-shell execute">pip install -h</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pip</h1>

<p>至此我们已经安装好 Python 了, 有了基本的开发环境, 但这还不够, 在大部分开发过程中, 我们会使用很多 Python 的第三方库, Python 为我们提供了很好的包管理工具, 这就是 <code>pip</code>, 使用它, 我们可以快速地安装或更新 Python 库.</p>

<p><code>pip help</code> 首先, 第一个命令还是如何查看 pip 的帮助文档信息.<br>
<code>pip help install</code> 还可以查看子命令的帮助文档.
=====222222rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr里以 <code>requests</code> 库为例来展示如何使用 pip</p>

<ul>
<li>
<code>pip search requests</code> 在安装一个扩展库之前, 我们可以使用 <code>search</code> 子命令来查询该扩展库.</li>
<li>
<code>pip install reauests</code> 在找到该库以后, 就可以使用 install 命令来安装扩展库了</li>
<li>
<code>pip list</code> 安装完以后, 我们可以使用 <code>pip list</code> 命令来查看库是否已经被安装好了, 该命名会展示所有当前系统中已经安装好了的库</li>
<li>
<code>pip show --verbose requests</code> 显示当前已经安装库的详细信息</li>
<li>
<code>pip uninstall requests</code> 也可以使用 <code>uninstall</code> 来卸载已经安装的库.</li>
</ul>

<p>刚才我们使用 <code>pip install requests</code> 命令直接安装了 request 库, 这默认将安装最新版本的库, 在安装的时候, 我们还可以指定要安装的版本,如: <code>pip install requests==2.0.0</code> 表示将安装指定的版本, <code>pip install requests&gt;=2.0.0</code></p>

<p>如果当我们开发的一个项目需要很多依赖库, 一个一个安装这些苦将非常痛苦, 并且为了不出现 "这段代码在我电脑上运行没有问题啊" 这种问题, 所有开发者应该严格使用一直的库版本. 我们可以将所有这些依赖库以及版本信息写入到一个文件中, 在用 <code>pip install</code> 时候使用 <code>-r</code> 选项指定这个文件, 则该文件中的所有库都将被安装, 并且该文件还可以被放到版本控制中, 方便追中依赖库的更新信息.</p>

<p>pip 为我们提供了 <code>freeze</code> 命令, 该命令会将当前系统上安装的所有依赖和版本信息都打印出来, 这些信息就可以作为 <code>install -r</code> 选项的输入文件. <code>pip freeze</code>, <code>pip freeze &gt; requirements.txt</code>, <code>pip install -r requirements.txt</code></p>

<p>刚才我们一直在使用 <code>pip list</code> 命令查看当前系统已安装的库信息, 它还有一个比较常用的选项 <code>-o/----outdated</code>, 可以使用 <code>pip help list</code> 查看帮助文档, 该参数会列出当前系统中可更新的库.  </p>

<p>使用 <code>pip install</code> 的 <code>-U</code> 参数, 可以让我们更新某个库.<br>
如果当前系统中存在大量已经过期的库(或者说有更新的库), 想要安装这些库, 如果手动一个一个来更新就比较费时了, 这有一段代码可用来更新当前系统中的所有库. <code>pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U</code></p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="04_pip" id="__Python_04_pip3" class="slide incremental" data-transition="turnUp">
<div class="content incremental" ref="安装Python/04_pip:3">
<h1>pip install/uninstall</h1>

<pre class="highlight"><code class="language-bash">pip search requests

# install package
pip install requests

# 安装指定版本
pip install requests==2.0.0.

# minimum version
pip install requests&gt;=2.18.3

# 从文件安装
pip install -r requirements.txt

# 卸载库
pip uninstall requests

# 卸载 requirement.txt 文件中的所有包
pip uninstall -r requirement.txt

# 卸载时不提示确认信息
pip uninstall -y requests</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pip</h1>

<p>至此我们已经安装好 Python 了, 有了基本的开发环境, 但这还不够, 在大部分开发过程中, 我们会使用很多 Python 的第三方库, Python 为我们提供了很好的包管理工具, 这就是 <code>pip</code>, 使用它, 我们可以快速地安装或更新 Python 库.</p>

<p><code>pip help</code> 首先, 第一个命令还是如何查看 pip 的帮助文档信息.<br>
<code>pip help install</code> 还可以查看子命令的帮助文档.
=====222222rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr里以 <code>requests</code> 库为例来展示如何使用 pip</p>

<ul>
<li>
<code>pip search requests</code> 在安装一个扩展库之前, 我们可以使用 <code>search</code> 子命令来查询该扩展库.</li>
<li>
<code>pip install reauests</code> 在找到该库以后, 就可以使用 install 命令来安装扩展库了</li>
<li>
<code>pip list</code> 安装完以后, 我们可以使用 <code>pip list</code> 命令来查看库是否已经被安装好了, 该命名会展示所有当前系统中已经安装好了的库</li>
<li>
<code>pip show --verbose requests</code> 显示当前已经安装库的详细信息</li>
<li>
<code>pip uninstall requests</code> 也可以使用 <code>uninstall</code> 来卸载已经安装的库.</li>
</ul>

<p>刚才我们使用 <code>pip install requests</code> 命令直接安装了 request 库, 这默认将安装最新版本的库, 在安装的时候, 我们还可以指定要安装的版本,如: <code>pip install requests==2.0.0</code> 表示将安装指定的版本, <code>pip install requests&gt;=2.0.0</code></p>

<p>如果当我们开发的一个项目需要很多依赖库, 一个一个安装这些苦将非常痛苦, 并且为了不出现 "这段代码在我电脑上运行没有问题啊" 这种问题, 所有开发者应该严格使用一直的库版本. 我们可以将所有这些依赖库以及版本信息写入到一个文件中, 在用 <code>pip install</code> 时候使用 <code>-r</code> 选项指定这个文件, 则该文件中的所有库都将被安装, 并且该文件还可以被放到版本控制中, 方便追中依赖库的更新信息.</p>

<p>pip 为我们提供了 <code>freeze</code> 命令, 该命令会将当前系统上安装的所有依赖和版本信息都打印出来, 这些信息就可以作为 <code>install -r</code> 选项的输入文件. <code>pip freeze</code>, <code>pip freeze &gt; requirements.txt</code>, <code>pip install -r requirements.txt</code></p>

<p>刚才我们一直在使用 <code>pip list</code> 命令查看当前系统已安装的库信息, 它还有一个比较常用的选项 <code>-o/----outdated</code>, 可以使用 <code>pip help list</code> 查看帮助文档, 该参数会列出当前系统中可更新的库.  </p>

<p>使用 <code>pip install</code> 的 <code>-U</code> 参数, 可以让我们更新某个库.<br>
如果当前系统中存在大量已经过期的库(或者说有更新的库), 想要安装这些库, 如果手动一个一个来更新就比较费时了, 这有一段代码可用来更新当前系统中的所有库. <code>pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U</code></p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="04_pip" id="__Python_04_pip4" class="slide incremental" data-transition="turnUp">
<div class="content incremental" ref="安装Python/04_pip:4">
<h1>pip 其他常用命令</h1>

<pre class="highlight"><code class="language-bash"># 列出当前已经安装的库
pip list

# 显示当前已安装库的详细信息
pip show Pympler
pip show --verbose Pympler

# 打印出当前系统中安装的库及其版本信息
pip freeze

# 查看那些库有更新.
pip list -o

# 更新库
pip install -U requests

# 列出当前已安装库信息
pip freeze

# 更新所有
pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U </code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pip</h1>

<p>至此我们已经安装好 Python 了, 有了基本的开发环境, 但这还不够, 在大部分开发过程中, 我们会使用很多 Python 的第三方库, Python 为我们提供了很好的包管理工具, 这就是 <code>pip</code>, 使用它, 我们可以快速地安装或更新 Python 库.</p>

<p><code>pip help</code> 首先, 第一个命令还是如何查看 pip 的帮助文档信息.<br>
<code>pip help install</code> 还可以查看子命令的帮助文档.
=====222222rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr里以 <code>requests</code> 库为例来展示如何使用 pip</p>

<ul>
<li>
<code>pip search requests</code> 在安装一个扩展库之前, 我们可以使用 <code>search</code> 子命令来查询该扩展库.</li>
<li>
<code>pip install reauests</code> 在找到该库以后, 就可以使用 install 命令来安装扩展库了</li>
<li>
<code>pip list</code> 安装完以后, 我们可以使用 <code>pip list</code> 命令来查看库是否已经被安装好了, 该命名会展示所有当前系统中已经安装好了的库</li>
<li>
<code>pip show --verbose requests</code> 显示当前已经安装库的详细信息</li>
<li>
<code>pip uninstall requests</code> 也可以使用 <code>uninstall</code> 来卸载已经安装的库.</li>
</ul>

<p>刚才我们使用 <code>pip install requests</code> 命令直接安装了 request 库, 这默认将安装最新版本的库, 在安装的时候, 我们还可以指定要安装的版本,如: <code>pip install requests==2.0.0</code> 表示将安装指定的版本, <code>pip install requests&gt;=2.0.0</code></p>

<p>如果当我们开发的一个项目需要很多依赖库, 一个一个安装这些苦将非常痛苦, 并且为了不出现 "这段代码在我电脑上运行没有问题啊" 这种问题, 所有开发者应该严格使用一直的库版本. 我们可以将所有这些依赖库以及版本信息写入到一个文件中, 在用 <code>pip install</code> 时候使用 <code>-r</code> 选项指定这个文件, 则该文件中的所有库都将被安装, 并且该文件还可以被放到版本控制中, 方便追中依赖库的更新信息.</p>

<p>pip 为我们提供了 <code>freeze</code> 命令, 该命令会将当前系统上安装的所有依赖和版本信息都打印出来, 这些信息就可以作为 <code>install -r</code> 选项的输入文件. <code>pip freeze</code>, <code>pip freeze &gt; requirements.txt</code>, <code>pip install -r requirements.txt</code></p>

<p>刚才我们一直在使用 <code>pip list</code> 命令查看当前系统已安装的库信息, 它还有一个比较常用的选项 <code>-o/----outdated</code>, 可以使用 <code>pip help list</code> 查看帮助文档, 该参数会列出当前系统中可更新的库.  </p>

<p>使用 <code>pip install</code> 的 <code>-U</code> 参数, 可以让我们更新某个库.<br>
如果当前系统中存在大量已经过期的库(或者说有更新的库), 想要安装这些库, 如果手动一个一个来更新就比较费时了, 这有一段代码可用来更新当前系统中的所有库. <code>pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U</code></p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="04_pip" id="__Python_04_pip5" class="slide incremental" data-transition="turnUp">
<div class="content incremental" ref="安装Python/04_pip:5">
<h1>pip requirments.txt</h1>

<pre class="highlight"><code class="language-bash">#
####### requirements.txt #######
#
###### 没有指定特定版本信息的第三方库 ######
nose
nose-cov
beautifulsoup4
#
###### 明确指定了要第三方库要使用的版本 ######
#   See https://www.python.org/dev/peps/pep-0440/#version-specifiers
docopt == 0.6.1             # Version Matching. Must be version 0.6.1
keyring &gt;= 4.1.1            # Minimum version 4.1.1
coverage != 3.5             # Version Exclusion. Anything except version 3.5
Mopidy-Dirble ~= 1.1        # Compatible release. Same as &gt;= 1.1, == 1.*
#
###### 引用其他 requirements.txt 文件 ######
-r other-requirements.txt</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>pip</h1>

<p>至此我们已经安装好 Python 了, 有了基本的开发环境, 但这还不够, 在大部分开发过程中, 我们会使用很多 Python 的第三方库, Python 为我们提供了很好的包管理工具, 这就是 <code>pip</code>, 使用它, 我们可以快速地安装或更新 Python 库.</p>

<p><code>pip help</code> 首先, 第一个命令还是如何查看 pip 的帮助文档信息.<br>
<code>pip help install</code> 还可以查看子命令的帮助文档.
=====222222rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr里以 <code>requests</code> 库为例来展示如何使用 pip</p>

<ul>
<li>
<code>pip search requests</code> 在安装一个扩展库之前, 我们可以使用 <code>search</code> 子命令来查询该扩展库.</li>
<li>
<code>pip install reauests</code> 在找到该库以后, 就可以使用 install 命令来安装扩展库了</li>
<li>
<code>pip list</code> 安装完以后, 我们可以使用 <code>pip list</code> 命令来查看库是否已经被安装好了, 该命名会展示所有当前系统中已经安装好了的库</li>
<li>
<code>pip show --verbose requests</code> 显示当前已经安装库的详细信息</li>
<li>
<code>pip uninstall requests</code> 也可以使用 <code>uninstall</code> 来卸载已经安装的库.</li>
</ul>

<p>刚才我们使用 <code>pip install requests</code> 命令直接安装了 request 库, 这默认将安装最新版本的库, 在安装的时候, 我们还可以指定要安装的版本,如: <code>pip install requests==2.0.0</code> 表示将安装指定的版本, <code>pip install requests&gt;=2.0.0</code></p>

<p>如果当我们开发的一个项目需要很多依赖库, 一个一个安装这些苦将非常痛苦, 并且为了不出现 "这段代码在我电脑上运行没有问题啊" 这种问题, 所有开发者应该严格使用一直的库版本. 我们可以将所有这些依赖库以及版本信息写入到一个文件中, 在用 <code>pip install</code> 时候使用 <code>-r</code> 选项指定这个文件, 则该文件中的所有库都将被安装, 并且该文件还可以被放到版本控制中, 方便追中依赖库的更新信息.</p>

<p>pip 为我们提供了 <code>freeze</code> 命令, 该命令会将当前系统上安装的所有依赖和版本信息都打印出来, 这些信息就可以作为 <code>install -r</code> 选项的输入文件. <code>pip freeze</code>, <code>pip freeze &gt; requirements.txt</code>, <code>pip install -r requirements.txt</code></p>

<p>刚才我们一直在使用 <code>pip list</code> 命令查看当前系统已安装的库信息, 它还有一个比较常用的选项 <code>-o/----outdated</code>, 可以使用 <code>pip help list</code> 查看帮助文档, 该参数会列出当前系统中可更新的库.  </p>

<p>使用 <code>pip install</code> 的 <code>-U</code> 参数, 可以让我们更新某个库.<br>
如果当前系统中存在大量已经过期的库(或者说有更新的库), 想要安装这些库, 如果手动一个一个来更新就比较费时了, 这有一段代码可用来更新当前系统中的所有库. <code>pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U</code></p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="05_virtualenv" id="__Python_05_virtualenv1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="安装Python/05_virtualenv:1">
<h1>virtualenv</h1>

<p><a href="https://virtualenv.pypa.io/en/stable">https://virtualenv.pypa.io/en/stable</a></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>virtualenv</h1>

<p>现在大家想象一下, 你当前维护了多个不同的 Python 项目, 而这些项目中既有 Python2 开发的, 又有 Python3 开发的, 即使是使用相同 Python 版本开发的, 这些 Python 项目不可能会使用完全一样的库, 甚至会出现不同的项目使用同一个库的不同版本.</p>

<p>这时我们就需要为每个项目创建一个相对独立的开发环境, 而 virtualenv 就是为我们提供一个虚拟的开发环境, 它能在同一台电脑上创建多个独立的虚拟开发环境, 每个虚拟环境都是相互独立的,(说到虚拟环境, 大家一定要与虚拟机的那个虚拟区别开来, virtualenv中的虚拟仅仅是作用在文件夹层级的, 说白了就是每个虚拟环境仅仅是一个目录罢了. 它只是通过设定一些环境变量指向这个目录). 当启用一个虚拟环境时, 执行 python 的所有命令都将来自于这个虚拟环境, 并且所安装的所有扩展库也都将安装到这个虚拟环境中, 这样就达到了多个虚拟环境以及和系统之间相互隔离的目的.</p>

<p>安装 <code>virtualenv</code> 非常简单, 使用 <code>pip</code> 命令就可以直接安装了.</p>

<p>安装好以后, <code>pip show --verbose virtualenv</code> 查看详细信息</p>

<p>安装好 <code>virtualenv</code> 后就可以使用了, 首先第一个命令就是创建一个虚拟的环境, 格式为 <code>virtual proj1</code>, 该命令会在当前目录下创建一个名为 <code>proj1</code> 的子目录, 也可以加上 <code>-v</code> 参数显示详细信息.</p>

<p>该命令会在当前目录下创建一个新目录 proj1, 并包含以下子目录:</p>

<ul>
<li>
<code>include</code> 包含了 Python 的头文件</li>
<li>
<code>lib</code> 包含了 Python 中的库文件, 新安装的库将全部存放在 lib/pythonXX/site-packages/ 目录下</li>
<li>
<code>bin</code> 生成的一些可执行文件, 包括 Python, pip 等等</li>
</ul>

<h2>激活环境</h2>

<p>在初始化好一个虚拟环境后, 需要先进行激活, 只有激活之后才可以使用.<br>
当初始化完一个项目目录后, 处于未激活状态, 在能够使用这个虚拟环境之前, 首先需要激活:</p>

<p>使用 <code>export</code> 可以看到 <code>PATH</code>, <code>PS1</code> 都被修改了, 并增加了一个新的环境变量 <code>VIRTUAL_ENV</code>, 指向了当前项目目录<br>
当激活了一个环境以后, 通过 <code>pip</code> 安装的新库文件将全部被安装到 <code>lib/pythonXX/site-packages/</code> 路径下.</p>

<blockquote>
<p><code>PS4</code> 简单介绍一下</p>
</blockquote>

<p><code>pip install requests</code><br>
<code>pip show requests</code>: 查看路径 <code>Location: /root/proj1/lib/python3.6/site-packages</code></p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="安装Python" data-title="05_virtualenv" id="__Python_05_virtualenv2" class="slide" data-transition="turnUp">
<div class="content " ref="安装Python/05_virtualenv:2">
<h1>virtualenv 使用</h1>

<h2>安装 <code>virtualenv</code>
</h2>

<p>使用 <code>pip</code> 安装 virtualenv</p>

<pre class="highlight"><code class="language-bash">pip install virtualenv</code></pre>

<h2>创建虚拟环境</h2>

<pre class="highlight"><code class="language-bash">virtualenv proj1</code></pre>

<p>该命令会在当前目录下创建一个新目录 proj1, 并包含以下子目录:</p>

<ul>
<li>
<code>include</code> 包含了 Python 的头文件</li>
<li>
<code>lib</code> 包含了 Python 中的库文件, 新安装的库将全部存放在 lib/pythonXX/site-packages/ 目录下</li>
<li>
<code>bin</code> 生成的一些可执行文件, 包括 Python, pip 等等</li>
</ul>

<h2>指定 Python 版本</h2>

<pre class="highlight"><code class="language-bash">virtualenv proj2 --python /root/.pyenv/versions/2.7.13/bin/python</code></pre>

<h2>激活环境</h2>

<pre class="highlight"><code class="language-bash">. proj1/bin/activate</code></pre>

<h2>取消激活</h2>

<pre class="highlight"><code class="language-bash">. proj1/bin/activate</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>virtualenv</h1>

<p>现在大家想象一下, 你当前维护了多个不同的 Python 项目, 而这些项目中既有 Python2 开发的, 又有 Python3 开发的, 即使是使用相同 Python 版本开发的, 这些 Python 项目不可能会使用完全一样的库, 甚至会出现不同的项目使用同一个库的不同版本.</p>

<p>这时我们就需要为每个项目创建一个相对独立的开发环境, 而 virtualenv 就是为我们提供一个虚拟的开发环境, 它能在同一台电脑上创建多个独立的虚拟开发环境, 每个虚拟环境都是相互独立的,(说到虚拟环境, 大家一定要与虚拟机的那个虚拟区别开来, virtualenv中的虚拟仅仅是作用在文件夹层级的, 说白了就是每个虚拟环境仅仅是一个目录罢了. 它只是通过设定一些环境变量指向这个目录). 当启用一个虚拟环境时, 执行 python 的所有命令都将来自于这个虚拟环境, 并且所安装的所有扩展库也都将安装到这个虚拟环境中, 这样就达到了多个虚拟环境以及和系统之间相互隔离的目的.</p>

<p>安装 <code>virtualenv</code> 非常简单, 使用 <code>pip</code> 命令就可以直接安装了.</p>

<p>安装好以后, <code>pip show --verbose virtualenv</code> 查看详细信息</p>

<p>安装好 <code>virtualenv</code> 后就可以使用了, 首先第一个命令就是创建一个虚拟的环境, 格式为 <code>virtual proj1</code>, 该命令会在当前目录下创建一个名为 <code>proj1</code> 的子目录, 也可以加上 <code>-v</code> 参数显示详细信息.</p>

<p>该命令会在当前目录下创建一个新目录 proj1, 并包含以下子目录:</p>

<ul>
<li>
<code>include</code> 包含了 Python 的头文件</li>
<li>
<code>lib</code> 包含了 Python 中的库文件, 新安装的库将全部存放在 lib/pythonXX/site-packages/ 目录下</li>
<li>
<code>bin</code> 生成的一些可执行文件, 包括 Python, pip 等等</li>
</ul>

<h2>激活环境</h2>

<p>在初始化好一个虚拟环境后, 需要先进行激活, 只有激活之后才可以使用.<br>
当初始化完一个项目目录后, 处于未激活状态, 在能够使用这个虚拟环境之前, 首先需要激活:</p>

<p>使用 <code>export</code> 可以看到 <code>PATH</code>, <code>PS1</code> 都被修改了, 并增加了一个新的环境变量 <code>VIRTUAL_ENV</code>, 指向了当前项目目录<br>
当激活了一个环境以后, 通过 <code>pip</code> 安装的新库文件将全部被安装到 <code>lib/pythonXX/site-packages/</code> 路径下.</p>

<blockquote>
<p><code>PS4</code> 简单介绍一下</p>
</blockquote>

<p><code>pip install requests</code><br>
<code>pip show requests</code>: 查看路径 <code>Location: /root/proj1/lib/python3.6/site-packages</code></p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="00_varaibles" id="_______00_varaibles1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/00_varaibles:1">
<h1>变量</h1>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>Python 变量</h1>

<p>如果违背了上述两条规则, Python 将会报出语法错误.</p>

<h2>约定俗成</h2>

<p>这里还有两条定义变量时约定俗成的规定, 虽然不想上面那两条硬性规定那样, 如果不符合规则, Python 会报出语法错误. 但为了代码的健壮性, 在定义变量时, 最好还要符合以下两条规则:</p>

<ul>
<li>不要使用 Python 中预定义好的变量名做为自己的变量名</li>
</ul>

<p>在 Python 中, 内置的很多 内置变量 和 内置函数, 这些内置变量和函数可以方便我们使用 Python. Python中的 <code>dir()</code> 函数来查看任意一个对象的内置方法和属性.</p>

<p><code>dir(__builtins__)</code> 可以帮助我们获取所有内置变量和函数.</p>

<pre class="highlight"><code class="language-python">id # id() 是一个内置函数, 该函数的作用是打印出变量或者一个对象的唯一 ID 号, 有点类似于 C 语言中指针地址的意思, 但是这个 id 与内存地址不是同一个东西.
type(id) # 使用 type() 函数查看 id
id(1)
id('a')
a = 1
id(a)
id = 500 # 为 id 赋值, 没有出现任何错误信息
id # 可以正确打印出 500 这个值, 说明已经为id赋值了新的值 500
type(id) # 此时再看 ID 的类型, 会发现 id 已经变成 int 类型了
id(1) # 此时在用 id 获取对象的唯一标识号, 会发现已经报错了.</code></pre>

<ul>
<li>不要定义以双下划线dunder(__)开头和结尾的变量, Python中定义一些列有特殊作用的变量和函数, 都是以双下划线开头和结尾的. 为了防止将来Python新增加的特殊作用的变量或函数与自己定义的重复, 尽量不要在变量名的前后都加上双下划线.</li>
</ul>

<p>虽然不遵守以上两点规则, Python 并不会给出任何错误提示, 但我们应当尽量避免这种事情发生.</p>

<h1>定义变量</h1>

<p>Python 属于编译型语言, 并且是弱类型的, python 中的变量会在被执行的过程中定义具体的类型, 所以我们在声明 Python 的变量时, 无需指定变量的具体类型, 也不会像 PHP 或 JavaScript 那样使用任何定义变量的关键字.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="00_varaibles" id="_______00_varaibles2" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/00_varaibles:2">
<h1>变量命名规则</h1>

<p>与大部分其他编程语言类似, 变量名是由一个不包含空格的任意个数的字符序列组成, 包括字母, 数字和下划线, 并且符合以下两个规则:</p>

<ul><li><p>变量名必须以字母`[a-zA-Z]`或下划线(`_`)开头,并且变量名 <b>区分大小写</b></p></li></ul>

<pre class="highlight"><code class="language-python"># 两个完全不同的变量
city = 'dl'
City = 'DL'</code></pre>

<ul><li><p>不能使用 Python 中的关键字作为变量的名字.</p></li></ul>

<pre class="highlight"><code class="language-python execute">import keyword
print(keyword.kwlist)</code></pre>

<p><a href="https://docs.python.org/2/library/functions.html">Python2 built-in</a>
<a href="https://docs.python.org/3.6/library/functions.html">Python3 built-in</a></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>Python 变量</h1>

<p>如果违背了上述两条规则, Python 将会报出语法错误.</p>

<h2>约定俗成</h2>

<p>这里还有两条定义变量时约定俗成的规定, 虽然不想上面那两条硬性规定那样, 如果不符合规则, Python 会报出语法错误. 但为了代码的健壮性, 在定义变量时, 最好还要符合以下两条规则:</p>

<ul>
<li>不要使用 Python 中预定义好的变量名做为自己的变量名</li>
</ul>

<p>在 Python 中, 内置的很多 内置变量 和 内置函数, 这些内置变量和函数可以方便我们使用 Python. Python中的 <code>dir()</code> 函数来查看任意一个对象的内置方法和属性.</p>

<p><code>dir(__builtins__)</code> 可以帮助我们获取所有内置变量和函数.</p>

<pre class="highlight"><code class="language-python">id # id() 是一个内置函数, 该函数的作用是打印出变量或者一个对象的唯一 ID 号, 有点类似于 C 语言中指针地址的意思, 但是这个 id 与内存地址不是同一个东西.
type(id) # 使用 type() 函数查看 id
id(1)
id('a')
a = 1
id(a)
id = 500 # 为 id 赋值, 没有出现任何错误信息
id # 可以正确打印出 500 这个值, 说明已经为id赋值了新的值 500
type(id) # 此时再看 ID 的类型, 会发现 id 已经变成 int 类型了
id(1) # 此时在用 id 获取对象的唯一标识号, 会发现已经报错了.</code></pre>

<ul>
<li>不要定义以双下划线dunder(__)开头和结尾的变量, Python中定义一些列有特殊作用的变量和函数, 都是以双下划线开头和结尾的. 为了防止将来Python新增加的特殊作用的变量或函数与自己定义的重复, 尽量不要在变量名的前后都加上双下划线.</li>
</ul>

<p>虽然不遵守以上两点规则, Python 并不会给出任何错误提示, 但我们应当尽量避免这种事情发生.</p>

<h1>定义变量</h1>

<p>Python 属于编译型语言, 并且是弱类型的, python 中的变量会在被执行的过程中定义具体的类型, 所以我们在声明 Python 的变量时, 无需指定变量的具体类型, 也不会像 PHP 或 JavaScript 那样使用任何定义变量的关键字.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="00_varaibles" id="_______00_varaibles3" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/00_varaibles:3">
<h1>约定俗成</h1>

<p>以上两条是定于变量名的硬性规定, 如果不符合以上两条规则中的任意一条, 都会导致语法错误.</p>

<p>但定义一个变量一般还需要遵守以下两点约定俗成的规则, 虽然不符合以下两点的变量名不会有任何错误, 但是为了保证代码的健壮性, 尽量都要符合这两点规则:</p>

<ul><li><p>不要使用 Python 中预定义好的变量名做为自己的变量名.</p></li></ul>

<pre class="highlight"><code class="language-python execute"># 查看 Python 中的内置变量和函数
print(dir(__builtins__))</code></pre>

<ul><li><p>不要定义以双下划线dunder(`__`)开头和结尾的变量.</p></li></ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>Python 变量</h1>

<p>如果违背了上述两条规则, Python 将会报出语法错误.</p>

<h2>约定俗成</h2>

<p>这里还有两条定义变量时约定俗成的规定, 虽然不想上面那两条硬性规定那样, 如果不符合规则, Python 会报出语法错误. 但为了代码的健壮性, 在定义变量时, 最好还要符合以下两条规则:</p>

<ul>
<li>不要使用 Python 中预定义好的变量名做为自己的变量名</li>
</ul>

<p>在 Python 中, 内置的很多 内置变量 和 内置函数, 这些内置变量和函数可以方便我们使用 Python. Python中的 <code>dir()</code> 函数来查看任意一个对象的内置方法和属性.</p>

<p><code>dir(__builtins__)</code> 可以帮助我们获取所有内置变量和函数.</p>

<pre class="highlight"><code class="language-python">id # id() 是一个内置函数, 该函数的作用是打印出变量或者一个对象的唯一 ID 号, 有点类似于 C 语言中指针地址的意思, 但是这个 id 与内存地址不是同一个东西.
type(id) # 使用 type() 函数查看 id
id(1)
id('a')
a = 1
id(a)
id = 500 # 为 id 赋值, 没有出现任何错误信息
id # 可以正确打印出 500 这个值, 说明已经为id赋值了新的值 500
type(id) # 此时再看 ID 的类型, 会发现 id 已经变成 int 类型了
id(1) # 此时在用 id 获取对象的唯一标识号, 会发现已经报错了.</code></pre>

<ul>
<li>不要定义以双下划线dunder(__)开头和结尾的变量, Python中定义一些列有特殊作用的变量和函数, 都是以双下划线开头和结尾的. 为了防止将来Python新增加的特殊作用的变量或函数与自己定义的重复, 尽量不要在变量名的前后都加上双下划线.</li>
</ul>

<p>虽然不遵守以上两点规则, Python 并不会给出任何错误提示, 但我们应当尽量避免这种事情发生.</p>

<h1>定义变量</h1>

<p>Python 属于编译型语言, 并且是弱类型的, python 中的变量会在被执行的过程中定义具体的类型, 所以我们在声明 Python 的变量时, 无需指定变量的具体类型, 也不会像 PHP 或 JavaScript 那样使用任何定义变量的关键字.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="00_varaibles" id="_______00_varaibles4" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/00_varaibles:4">
<h1>定义变量</h1>

<p>自动被解释成 <code>字符串</code></p>

<pre class="highlight"><code class="language-python">language = 'Python'</code></pre>

<p>自动被解释成 <code>整数</code></p>

<pre class="highlight"><code class="language-python">major_version = 3</code></pre>

<p>自动被解释成 <code>浮点数</code></p>

<pre class="highlight"><code class="language-python">mainor_version = 36.1</code></pre>

<p>自动被解释成 <code>列表</code></p>

<pre class="highlight"><code class="language-python">python_versions = [3, 36, 1]</code></pre>

<p><code>del</code> 删除变量</p>

<pre class="highlight"><code class="language-python">del language</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>Python 变量</h1>

<p>如果违背了上述两条规则, Python 将会报出语法错误.</p>

<h2>约定俗成</h2>

<p>这里还有两条定义变量时约定俗成的规定, 虽然不想上面那两条硬性规定那样, 如果不符合规则, Python 会报出语法错误. 但为了代码的健壮性, 在定义变量时, 最好还要符合以下两条规则:</p>

<ul>
<li>不要使用 Python 中预定义好的变量名做为自己的变量名</li>
</ul>

<p>在 Python 中, 内置的很多 内置变量 和 内置函数, 这些内置变量和函数可以方便我们使用 Python. Python中的 <code>dir()</code> 函数来查看任意一个对象的内置方法和属性.</p>

<p><code>dir(__builtins__)</code> 可以帮助我们获取所有内置变量和函数.</p>

<pre class="highlight"><code class="language-python">id # id() 是一个内置函数, 该函数的作用是打印出变量或者一个对象的唯一 ID 号, 有点类似于 C 语言中指针地址的意思, 但是这个 id 与内存地址不是同一个东西.
type(id) # 使用 type() 函数查看 id
id(1)
id('a')
a = 1
id(a)
id = 500 # 为 id 赋值, 没有出现任何错误信息
id # 可以正确打印出 500 这个值, 说明已经为id赋值了新的值 500
type(id) # 此时再看 ID 的类型, 会发现 id 已经变成 int 类型了
id(1) # 此时在用 id 获取对象的唯一标识号, 会发现已经报错了.</code></pre>

<ul>
<li>不要定义以双下划线dunder(__)开头和结尾的变量, Python中定义一些列有特殊作用的变量和函数, 都是以双下划线开头和结尾的. 为了防止将来Python新增加的特殊作用的变量或函数与自己定义的重复, 尽量不要在变量名的前后都加上双下划线.</li>
</ul>

<p>虽然不遵守以上两点规则, Python 并不会给出任何错误提示, 但我们应当尽量避免这种事情发生.</p>

<h1>定义变量</h1>

<p>Python 属于编译型语言, 并且是弱类型的, python 中的变量会在被执行的过程中定义具体的类型, 所以我们在声明 Python 的变量时, 无需指定变量的具体类型, 也不会像 PHP 或 JavaScript 那样使用任何定义变量的关键字.</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/01_number:1">
<h1>数字类型</h1>

<p>在 Python 中, 数字类型可划分为两类:</p>

<ul>
<li>整数类型

<ul>
<li>布尔类型</li>
</ul>
</li>
<li>浮点数</li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number2" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:2">
<h1>整数类型</h1>

<p>在Python中, 整型大小的限制取决于宿主计算机的内存大小. 当数值过大时, Python 会自动分配一块内存来存放该值, 因此在Python中, 很少能出现整数溢出的情况.</p>

<pre class="highlight"><code class="language-python execute">print(100 ** 100)</code></pre>

<h1>定义整数变量</h1>

<ul><li><p>使用数字字面量定义整数类型变量</p></li></ul>

<pre class="highlight"><code class="language-python">int1 = 95</code></pre>

<ul><li><p>使用内置函数 int()</p></li></ul>

<pre class="highlight"><code class="language-python">int2 = int(95)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number3" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:3">
<h1>整数运算</h1>

<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th style="text-align: center">简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>x + y</td>
<td>加</td>
<td style="text-align: center">+=</td>
</tr>
<tr>
<td>x - y</td>
<td>减</td>
<td style="text-align: center">-=</td>
</tr>
<tr>
<td>x * y</td>
<td>乘</td>
<td style="text-align: center">*=</td>
</tr>
<tr>
<td>x / y</td>
<td>除(*)</td>
<td style="text-align: center">/=</td>
</tr>
<tr>
<td>x // y</td>
<td>地板除</td>
<td style="text-align: center">//=</td>
</tr>
<tr>
<td>x % y</td>
<td>模运算</td>
<td style="text-align: center">%=</td>
</tr>
<tr>
<td>x ** y</td>
<td>幂运算</td>
<td style="text-align: center">**=</td>
</tr>
<tr>
<td>-x</td>
<td>负数</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td>+x</td>
<td>正数</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td>abs(x)</td>
<td>绝对值</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td>divmod(x, y)</td>
<td>返回一个元组, 包含 x/y 的商和余数</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td>pow(x, y)</td>
<td>x 的 y 次幂</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number4" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:4">
<h1>整数运算示例</h1>

<p>小数除</p>

<pre class="highlight"><code class="language-python execute">print(5 / 3)</code></pre>

<p>Python2</p>

<pre class="highlight"><code class="language-python execute">print(5.0 / 3)</code></pre>

<p>Python2 引用 division 模块</p>

<pre class="highlight"><code class="language-python execute">from __future__ import division
print(5.0 / 3)</code></pre>

<p>地板除</p>

<pre class="highlight"><code class="language-python execute">print(5 // 3)</code></pre>

<p>绝对值</p>

<pre class="highlight"><code class="language-python execute">print(abs(-8))</code></pre>

<p>取整(舍掉小数位)</p>

<pre class="highlight"><code class="language-python execute">print(int(3.7))</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number5" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:5">
<h1>Python2 中的 long 整型</h1>

<p>在 Python2 中, 除了 <code>int</code> 类型之外, 还存在 <code>long</code> 类型, 在整数值后面追加 <code>L</code> 或 <code>l</code>(推荐使用大写L, 显示直观), 即可定义一个 <code>long int</code> 类型的变量</p>

<pre class="highlight"><code class="language-python">int_l = 2L
type(int_l)</code></pre>

<p>使用内置函数 <code>long()</code> 创建长整型变量</p>

<pre class="highlight"><code class="language-python">int_l = long()</code></pre>

<p>如果一个 <code>int</code> 类型的值大小超出最大限制, 将会被自动转换成 <code>long</code> 类型</p>

<pre class="highlight"><code class="language-python">import sys
type(sys.maxsize)
type(sys.maxsize + 1)</code></pre>

<p class="callout info">在 Python3 中, 摒弃了 <code>long</code> 类型, 因此在 Python3 中后缀 <code>L</code> 将会导致语法错误, 并且内置函数 <code>long()</code> 也已经不复存在了. 取而代之, 全部使用 <code>int</code> 类型.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number6" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:6">
<h1>整数类型的本质</h1>

<p>在 Python 中, <strong>一切皆对象</strong>, 包括一个整数或一个整数变量</p>

<pre class="highlight"><code class="language-python execute">print(dir(5))</code></pre>

<p>在 Python 中, 数值类型的值为 <strong>只读</strong> 的. 可以通过内置函数 <code>id()</code> 可以获取到 Python 对象的唯一ID.</p>

<p><img src="./file//_images/datatype/val.png" alt="Alt text">
<img src="./file//_images/datatype/val1-2.png" alt="Alt text"></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number7" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:7">
<h1>整型的进制与位运算</h1>

<p>Python 同样支持数字的不同进制表示形式:
  - 十进制 <code>18</code>, 对应的转换函数 <code>int(N)</code></p>

<ul>
<li><p>二进制 <code>0b10010</code>, 对应的转换函数 <code>bin(N)</code></p></li>
<li><p>八进制 <code>022</code>, 对应的转换函数 <code>oct(N)</code></p></li>
<li><p>十六进制 <code>0x12</code>, 对应的转换函数 <code>hex(N)</code></p></li>
</ul>

<p><img src="./file//_images/datatype/hex.png" alt="Alt text"></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number8" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:8">
<h1>位运算</h1>

<p>位运算符</p>

<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th style="text-align: center">简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>i | j</td>
<td>或: 只要一个为1, 结果即为1</td>
<td style="text-align: center">\</td>
</tr>
<tr>
<td><code>i ^ j</code></td>
<td>异或: 相同为0, 不同为1</td>
<td style="text-align: center"><sup>=</sup></td>
</tr>
<tr>
<td><code>i &amp; j</code></td>
<td>并且: 全部为1, 值为1, 否则为0</td>
<td style="text-align: center">&amp;=</td>
</tr>
<tr>
<td><code>i &lt;&lt; j</code></td>
<td>向左移位:</td>
<td style="text-align: center">&lt;&lt;=</td>
</tr>
<tr>
<td><code>i &gt;&gt; j</code></td>
<td>向右移位:</td>
<td style="text-align: center">&gt;&gt;=</td>
</tr>
<tr>
<td><code>~i</code></td>
<td>取反: 1-&gt;0, 0-&gt;1</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number9" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:9">
<h1>位运算使用场景</h1>

<p>用途最多就是作为标志位, 如 Linux 权限位.</p>

<ul>
<li>
<code>1</code>: 执行权限</li>
<li>
<code>2</code>: 写权限</li>
<li>
<code>4</code>: 读权限</li>
</ul>

<p><img src="./file//_images/datatype/linux_permission.png" alt="Alt text"></p>

<h2>位运算示例</h2>

<p>打开/关闭 Linux 权限位</p>

<pre><code>  0 1 0 0              0 1 1 0 
| 0 0 1 0  = 4 | 2   &amp; 1 1 0 1  = 4 &amp; ~2
----------           ----------
  0 1 1 0              0 1 0 0
</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number10" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/01_number:10">
<h1>bool型</h1>

<p>布尔类型属于整数类型的一种, 只存在两个值:</p>

<ul>
<li><p><code>True</code>: 一切非0值和非空值, 转换成整数是为 <code>1</code></p></li>
<li><p><code>False</code>: 0 和 空值, 转换成整数时为 <code>0</code></p></li>
</ul>

<p>可以像其它数据类型一样, 调用内置函数 <code>bool()</code> 返回一个布尔对象.</p>

<pre class="highlight"><code class="language-python">bool()       # False
bool(0)      # False
bool('')     # False
bool(-4)     # True
bool('str')  # True</code></pre>

<p>bool 的特殊作用</p>

<pre class="highlight"><code class="language-python">['val1', 'val2'][True]   # 'val2'
['val1', 'val2'][False]  # 'val1'
['val1', 'val2'][1 &gt; 2]  # 'val1'</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number11" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/01_number:11">
<h1>比较关系运算符</h1>

<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>如果两个操作数的值相等，则条件为真.</td>
<td>(a == b)求值结果为 false</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>如果两个操作数的值不相等，则条件为真.</td>
<td>(a != b)求值结果为 true</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>如果左操作数的值大于右操作数的值，则条件成为真.</td>
<td>(a &gt; b)求值结果为 false</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>如果左操作数的值小于右操作数的值，则条件成为真.</td>
<td>(a &lt; b)求值结果为 true</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>如果左操作数的值大于或等于右操作数的值，则条件成为真.</td>
<td>(a &gt;= b)求值结果为 false</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>如果左操作数的值小于或等于右操作数的值，则条件成为真.</td>
<td>(a &lt;= b)求值结果为 true</td>
</tr>
</tbody>
</table>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number12" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/01_number:12">
<h1>浮点数</h1>

<p>在Python中, 浮点数用64位来表示的, 与 C 语言中的 double(双精度) 类型一样.</p>

<pre class="highlight"><code class="language-python">f1 = 1.234</code></pre>

<p>使用 <code>float()</code> 内置函数创建浮点数</p>

<pre class="highlight"><code class="language-python">f2 = float(1.234)

@@@ python
int(3.81)    # 3 直接舍掉小数部分
round(3.81)  # 四舍五入</code></pre>

<p>查看浮点数 <code>float</code> 帮助信息</p>

<pre class="highlight"><code class="language-python execute">help(float)</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number13" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:13">
<h1>浮点数的本质</h1>

<p>十进制小数
</p>
<p><code>
123.456 = 1*10<sup>2</sup> + 2*10<sup>1</sup> + 3*10<sup>0</sup> + 4*10<sup>-1</sup> + 5*10<sup>-2</sup> + 6*10<sup>-3</sup> = 1.23456*10<sup>2</sup>
</code></p>


<p>二进制小数</p>

<p></p>
<p><code>
1.01101 = 1*2<sup>0</sup> + 0*2<sup>-1</sup> + 1*2<sup>-2</sup> + 1*2<sup>-3</sup> + 0*2<sup>-4</sup> + 1*2<sup>-5</sup> = 0.25 + 0.125 + 0.03125 = 0.40625
</code></p>

<p>浮点数内存结构图(定点数)</p>

<p><img src="./file//_images/datatype/float.png" alt="浮点数内存结构图"></p>

<hr>

<p>指数位示意图</p>

<p><img src="./file//_images/datatype/exponent.png" alt="浮点数内存结构图"></p>

<p>指数(e)转换规则: <code>指数 + 基数</code><br>
其中基数(bias)为: <code>2<sup>k-1</sup> - 1</code><br>
<code>k</code> 为指数位的字节长度, 对于32位浮点数是 8 个字节, 对于 64 为浮点数来说, 是 11 位, 这是由 <code>IEEE</code> 标准规定的.</p>

<p>浮点数转换规则:
<code>
V = (-1)<sup>s</sup> × M × 2<sup>E</sup>
</code>, 
<code>
E = e - bias
</code></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="01_number" id="_______01_number14" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/01_number:14">
<h1>match 库</h1>

<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>math.sin(x)</td>
<td>x 的正弦值</td>
</tr>
<tr>
<td>math.cos(x)</td>
<td>x 的余弦值</td>
</tr>
<tr>
<td>math.tan(x)</td>
<td>x 的正切值</td>
</tr>
<tr>
<td>math.sin(x)</td>
<td>x 的余切值</td>
</tr>
<tr>
<td>math.pi</td>
<td>圆周率 PI</td>
</tr>
<tr>
<td>math.fabs(x)</td>
<td>绝对值</td>
</tr>
<tr>
<td>math.floor(x)</td>
<td>小于 x 的最大整数</td>
</tr>
<tr>
<td>math.ceil(x)</td>
<td>大于 x 的最小整数</td>
</tr>
</tbody>
</table>

<pre class="highlight"><code class="language-python">import math
math.floor(3.81) # 小于3.81的最大整数
3
math.ceil(3.81)  # 大于3.81的最小整数
4</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<p>&lt;!SLIDE center subsection&gt;</p>

<h1>数字类型</h1>

<p><code>int2 = int()</code> 如果不给 <code>int()</code> 提供任何参数, 则返回数字 0</p>

<h1>整数运算</h1>

<p>既然是数字类型, 就一定要支持数学运算符</p>

<p>这里需要重点说一下除法运算符<code>/</code>, 在 Python 2, 它属于地板除, 就是只会返回除法结果中的<code>商</code>, 而在 Python3 中, 这中方式变了, 除法运算在遇到不能整除的情况, 都会返回浮点数, 而不是整数商部分.</p>

<h2>Python2 中的 long 整型</h2>

<p><code>sys.maxsize == 2 ** 63 - 1</code>, 说明 int 是 64 位的, 之所以 <code>** 63</code> 是因为头一位是作为符号位的, 所以不计算在内.<br>
<code>2 ** 63 - 1</code> 返回的值是 <code>9223372036854775807L</code> 后面追加了 <code>L</code> 说明是 long 类型的, 但是 <code>int</code> 类型的最大值明明是这个, 为什么这里会转成 <code>long</code> 类型呢? 这是因为当我们计算 <code>2 ** 63</code> 次幂的时候, 已经超过了 int 类型的最大值, 所以自动转换成了 <code>long</code> 类型.<br>
<code>type(9223372036854775807)</code> 和 <code>type(9223372036854775808)</code> 分别为 <code>int</code> 型 和 <code>long</code> 型</p>

<h1>整数的本质</h1>

<ul>
<li>一切皆对象</li>
</ul>

<p>这意味着, 当我们定义了一个整数变量, 我们可以像访问其他对象属性的格式那样访问整数类型对象中的方法.</p>

<p>首先用 <code>dir(int)</code> 列出整数类型有哪些方法.</p>

<pre class="highlight"><code class="language-python">a = -5
a.__abs__() # 绝对值
a.__add__(3) # 加</code></pre>

<p>使用内置函数 help 可以帮我们查看这些帮助信息: <code>help(int)</code></p>

<ul>
<li>数值类型的值为只读的.</li>
</ul>

<p>这意味着, 一旦创建一个数值类型的对象, 它的值将再也无法改变. 注意, 这里说的是数值类型的对象. 并不是指向这个数值类型对象的变量,  我们知道, 在 C 语言中, 一个变量指向的是一块内存地址, 而这个地址中直接保存了这个数值, 比如 <code>val1 = 15</code>, 当我们为 val1 重新赋值 <code>val1 = 16</code>时, <code>val1</code> 本身指向的这个内存地址并没有改变, 而是内存中的值发生了变化, 而 Python 中恰恰相反, 内存中的值没发生变化, 而是val1指向了新的地址,  这有点类似与 C 语言中 使用const修饰一个指针: <code>const char * a;</code> 的意思.</p>

<h1>整型的进制</h1>

<p>二进制的存在, 是因为计算机只能识别 0 和 1, 或者说 高电位和地点为<br>
而八进制的存在时以为计算机中每个字节有8位, 就像人的手指有10根, 所以存在10进制是一样的道理<br>
为什么会存在十六进制呢? </p>

<h1>位运算</h1>

<p>每门编程语言都支持为运算, 但到时什么时候应该使用位运算呢? 为运算最常用的目的之一就是作为标志位, 比如 Linux 的权限运算. 每个位置都作为一个开关位, 我们常用0和1, 或 true 和 false 表示一个标志位或开关. 每个整数都至少占用32个字节, 而在现代的计算机中, 64位系统一个整数至少占用64个字节, 而如果使用位运算的话, 一个整数就可以表示64个标志位.</p>

<h1>浮点数</h1>

<p>定点数: 小数点固定的位于实数所有数字中间的某个位置</p>

<p>| round(x, n)  | 按照四舍五入的方式截取小数 x 的后 n 位 |</p>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string1" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="基本数据类型/02_string:1">
<h1>字符串类型</h1>

<p>和数字类型一样, 字符串同样是不可变对象. 为一个变量重新赋值一个新字符串值时, 实际上是创建了一个新的字符串对象, 并将该变量指向这个新创建的字符串对象.</p>

<p>创建字符串内置函数 <code>str()</code></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string2" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:2">
<h1>创建字符串对象</h1>

<p>使用字符串字面量值</p>

<pre class="highlight"><code class="language-python execute">s1 = 'string1'
print(s1)</code></pre>

<p><code>str()</code> 内置函数</p>

<pre class="highlight"><code class="language-python execute">print(str('string'))</code></pre>

<p>多行字符串</p>

<pre class="highlight"><code class="language-python execute">s2 = 'this \
is \
one \
line'
print(s2)</code></pre>

<p>三引号(triple quoted string)</p>

<pre class="highlight"><code class="language-python execute">s3 = """This is a multiple lines string.
line2
    line3
"""
print(s3)</code></pre>

<p>括号中的字符串</p>

<pre class="highlight"><code class="language-python execute">s4 = ("This is the nice way to join two long string "
"togeter; it relies on string literal concatenation.")
print(s4)</code></pre>

<p class="callout info">在 Python 中, 单引号与双引号意义完全相同, 因此上面的示例都可以使用双引号来代替</p>

<h1>字符串相加</h1>

<p>我们可以使用 <code>+</code> 将多个字符串拼接到一起, 形成一个新的字符串.</p>

<pre class="highlight"><code class="language-python execute">a = 's'
b = 'tr'
c = 'ing'
print(a + b + c)</code></pre>

<p class="callout warning">字符串对象与数字对象一样, 属于不可变类型, 当使用 <code>+</code> 拼接多个字符串时, 每遇到一个 <code>+</code> 都将生成一个新的字符串对象, 效率低下.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string3" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:3">
<h1>Python2 与 Python3 中的字符串</h1>

<p>分别在 Python2 和 Python3 中执行以下代码片段</p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

print("你好, 拍森")</code></pre>

<p><a href="http://www.ltg.ed.ac.uk/%7Erichard/utf-8.cgi">utf-8 编码查询</a></p>

<p class="callout info">Python2 默认使用 ASCII 编码, 而 Python3 中使用 UNICODE 作为默认的编码值.</p>

<p>解决办法:</p>

<ul>
<li><code># -*- coding: utf-8 -*-</code></li>
<li><code># encoding: utf-8</code></li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string4" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:4">
<h1>转义字符</h1>

<table>
<thead>
<tr>
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\newline</code></td>
<td>转义换行</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义 \</td>
</tr>
<tr>
<td>``</td>
<td>转义 '</td>
</tr>
<tr>
<td><code>\"</code></td>
<td>转义 "</td>
</tr>
<tr>
<td><code>\a</code></td>
<td>ASCII 铃音字符</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>回退字符</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页*</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>垂直制表(VT)</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车(CR) ，将当前位置移到本行开头(输入的字符会覆盖当前字符)</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
</tr>
<tr>
<td><code>\uhhhh</code></td>
<td>16位的十六进制值</td>
</tr>
<tr>
<td><code>\Uhhhhhhhh</code></td>
<td>32位的十六进制值</td>
</tr>
</tbody>
</table>

<p>引号转义</p>

<pre class="highlight"><code class="language-python">a = "Single 'quotes' are fine; \"doubles\" must be escaped."
b = 'Single quotes must be escaped; "doubles" are fine.'
c = '''both single 'quotes' and double "quotes" are fine.'''</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string5" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:5">
<h1>原始字符串(raw)</h1>

<p>有时候一个字符串中包含了大量需要转义的字符(正则表达式), 可以通过在字符串前加上 <code>r</code> 字符, 来表示这是一个原始字符串, 不要做任何转义.</p>

<pre class="highlight"><code class="language-python execute">print(r"123456\rab")</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string6" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:6">
<h1>字符串比较</h1>

<p>字符串支持像整数类型那样的比较运算符操作, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>, 和 <code>&gt;=</code>.</p>

<p>对比两个字符串时, 字符串将被拆分成一个一个的字符, 字符会被转正对应的数字, 然后对两个字符串中的每个字符进行对比.</p>

<p><img src="./file//_images/datatype/string_com1.png" alt="string_com1.png">
<img src="./file//_images/datatype/string_com2.png" alt="string_com2.png"></p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string7" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:7">
<h1>字符串索引</h1>

<p>在 Python 中, 我们可以通过下标索引的方式访问字符串中的某个或某一段子字符串(称之为: 切片), 格式为: <code>s[N]</code>, 其中 <code>N</code> 为字符索引位置, 其取值范围 <code>0 &lt;= N &lt; len(s)</code> 或 <code>-1 &lt;= N &lt;= -(len(s))</code>.</p>

<p><img src="./file//_images/datatype/string_index.png" alt="string_com2.png"></p>

<pre class="highlight"><code class="language-python execute">s = 'Light ray'
print(s[0])
print(s[-2])</code></pre>

<p class="callout info">如果索引超出字符串范围, 将抛出 <code>IndexError</code> 异常.</p>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string8" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:8">
<h1>字符切片</h1>

<p>切片: 从字符串中提取子字符串片段, 格式为:</p>

<p><code>seq[start:stop:step]</code>, 其中:</p>

<ul>
<li>
<code>start</code>: 表示字符串起始索引位置, 其值可为正, 也可为负, 忽略不写表示从 0 开始</li>
<li>
<code>stop</code> 字符串终止索引位置, 其值可为正, 也可为负, 忽略不写表示到字符串结尾</li>
<li>
<code>step</code> 步长, 默认为 1</li>
</ul>

<p>最终截取到的字符串为: <code>start &lt;= 片段 &lt; stop</code></p>

<p class="callout info"><code>seq</code> 可以是任何序列对象, 包括后面要讲到的 <code>tuple</code>, <code>list</code> 等等.</p>

<p>切片操作可以作用到字符串的任意一端:</p>

<ul>
<li><p><code>步长为正</code>: 从左至右, <code>start &lt; stop</code></p></li>
<li><p><code>步长为负</code>: 从右至左, <code>start &gt; stop</code></p></li>
</ul>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string9" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:9">
<h1>字符切片示例</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]
s[:2]
s[3:6]
s[13:]
s[7:-5]
s[0:-5:3]
s[::]
s[::3]</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]
s[::-1]
s[-1:2:-2]</code></pre>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="基本数据类型" data-title="02_string" id="_______02_string10" class="slide" data-transition="turnUp">
<div class="content " ref="基本数据类型/02_string:10">
<h1>字符串操作</h1>
</div>
<div class="notes-section notes"><div class="personal">
<h1>Personal Notes</h1>
<h1>转义字符, 进度条实现</h1>

<p>windows 下使用 <code>\r\n</code> 换行, HTTP 头信息中也同样使用 <code>\r\n</code>, 类 Unix 系统, 使用一个字符 <code>\n</code> 即可</p>

<p><code>\r</code> 需要注意一下.</p>

<pre class="highlight"><code class="language-shell">#!/usr/bin/env bash

for i in {1..5}; do
    echo -en "${i}%\r"
    sleep 0.5
done
echo ''

@@@ python
#!/usr/bin/env python

from time import sleep
import sys

for i in range(21):
    sys.stdout.write('\r')
    # the exact output you're looking for:
    sys.stdout.write("[%-20s] %d%%" % ('='*i, 5*i))
    sys.stdout.flush()
    sleep(0.25)</code></pre>

<h1>字符串索引</h1>

<p>从上图可以看出, Python 不仅支持正数的索引下标, 同时还支持负数的索引下标: 表示从字符串的右边开始计算.</p>

<h1>切片</h1>

<p><img src="./file//_images/datatype/string_slicing.png" alt="string_com2.png"></p>

<p>步长为正</p>

<pre class="highlight"><code class="language-python">s = 'he ate camel food'
s[0:2]    # he
s[:2]     # he
s[3:6]    # ate
s[13:]    # food
s[7:-5]   # camel
s[0:-5:3] # ha m o
s[::]     # he ate camel food
s[::3]    # ha m d</code></pre>

<p>步长为负</p>

<pre class="highlight"><code class="language-python">s[5:2:-1]  # eta
s[::-1]    # doof lemac eta eh
s[-1:2:-2] # do ea t</code></pre>
</div></div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="00_section" id="_____00_section" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="集合类型/00_section">
<h1>Section Header</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="01_slide" id="_____01_slide" class="slide" data-transition="none">
<div class="content " ref="集合类型/01_slide">
<h1>My Presentation</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="集合类型" data-title="02_slide" id="_____02_slide" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="集合类型/02_slide">
<h1>Bullet Points</h1>

<ul>
<li>first point</li>
<li>second point</li>
<li>third point</li>
</ul>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="逻辑控制" data-title="00_section" id="_____00_section" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="逻辑控制/00_section">
<h1>Section Header</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="逻辑控制" data-title="01_slide" id="_____01_slide" class="slide" data-transition="none">
<div class="content " ref="逻辑控制/01_slide">
<h1>My Presentation</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="逻辑控制" data-title="02_slide" id="_____02_slide" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="逻辑控制/02_slide">
<h1>Bullet Points</h1>

<ul>
<li>first point</li>
<li>second point</li>
<li>third point</li>
</ul>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="00_section" id="___00_section" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="函数/00_section">
<h1>Section Header</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="01_slide" id="___01_slide" class="slide" data-transition="none">
<div class="content " ref="函数/01_slide">
<h1>My Presentation</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="函数" data-title="02_slide" id="___02_slide" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="函数/02_slide">
<h1>Bullet Points</h1>

<ul>
<li>first point</li>
<li>second point</li>
<li>third point</li>
</ul>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="模块" data-title="00_section" id="___00_section" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="模块/00_section">
<h1>Section Header</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="模块" data-title="01_slide" id="___01_slide" class="slide" data-transition="none">
<div class="content " ref="模块/01_slide">
<h1>My Presentation</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="模块" data-title="02_slide" id="___02_slide" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="模块/02_slide">
<h1>Bullet Points</h1>

<ul>
<li>first point</li>
<li>second point</li>
<li>third point</li>
</ul>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="00_section" id="_____00_section" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="面向对象/00_section">
<h1>Section Header</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="01_slide" id="_____01_slide" class="slide" data-transition="none">
<div class="content " ref="面向对象/01_slide">
<h1>My Presentation</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="面向对象" data-title="02_slide" id="_____02_slide" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="面向对象/02_slide">
<h1>Bullet Points</h1>

<ul>
<li>first point</li>
<li>second point</li>
<li>third point</li>
</ul>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="文件操作" data-title="00_section" id="_____00_section" class="slide center subsection" data-transition="none">
<div class="content center subsection" ref="文件操作/00_section">
<h1>Section Header</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="文件操作" data-title="01_slide" id="_____01_slide" class="slide" data-transition="none">
<div class="content " ref="文件操作/01_slide">
<h1>My Presentation</h1>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="文件操作" data-title="02_slide" id="_____02_slide" class="slide bullets incremental" data-transition="none">
<div class="content bullets incremental" ref="文件操作/02_slide">
<h1>Bullet Points</h1>

<ul>
<li>first point</li>
<li>second point</li>
<li>third point</li>
</ul>
</div>
<canvas class="annotations"></canvas>
</div>
<div data-section="Python常用模块介绍" data-title="01_json" id="Python_______01_json" class="slide" data-transition="none">
<div class="content " ref="Python常用模块介绍/01_json">
<h1>json</h1>
</div>
<canvas class="annotations"></canvas>
</div>
</div>
<div id="buttonNav">
  <div id="buttonPrev"><i class="fa fa-chevron-left fa-lg"></i> Previous</div><div id="buttonNext">Next <i class="fa fa-chevron-right fa-lg"></i></div>
</div>
<div id="pauseScreen">
  PAUSED
</div>

</body>
</html>
